## 131. 将静态资源缓存在本地的方式有哪些？

将静态资源缓存在本地是提升网页加载速度和用户体验的重要手段。以下是常见的几种方式及其实现方法：

---

### 1. **HTTP 缓存（浏览器缓存）**
通过设置 HTTP 响应头，利用浏览器自身的缓存机制。

#### 常用响应头：
- **`Cache-Control`**：控制缓存行为。
    - `max-age=3600`：资源缓存 1 小时。
    - `no-cache`：每次请求需要验证缓存是否过期。
    - `no-store`：禁止缓存。
    - `public`：允许代理服务器缓存。
    - `private`：仅允许浏览器缓存。

- **`Expires`**：指定资源的过期时间（HTTP/1.0，已逐渐被 `Cache-Control` 替代）。
  ```http
  Expires: Wed, 21 Oct 2025 07:28:00 GMT
  ```

- **`ETag` / `Last-Modified`**：用于缓存验证（协商缓存）。
    - 服务器通过 `ETag` 或 `Last-Modified` 标识资源版本。
    - 浏览器发送 `If-None-Match` 或 `If-Modified-Since` 请求头验证缓存是否有效。

#### 示例（Nginx 配置）：
```nginx
location /static/ {
    expires 1y;
    add_header Cache-Control "public";
}
```

---

### 2. **Service Worker 缓存**
通过 Service Worker 拦截请求并缓存静态资源，实现离线访问。

#### 实现步骤：
1. 注册 Service Worker。
2. 在 `install` 事件中缓存资源。
3. 在 `fetch` 事件中返回缓存内容。

#### 示例代码：
```javascript
// 注册 Service Worker
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
}

// sw.js
const CACHE_NAME = 'static-v1';
const ASSETS = ['/styles.css', '/app.js', '/logo.png'];

self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open(CACHE_NAME).then((cache) => cache.addAll(ASSETS))
    );
});

self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request).then((response) => {
            return response || fetch(event.request);
        })
    );
});
```

---

### 3. **Web Storage**
适用于缓存少量数据（如 JSON 配置、用户偏好设置）。

#### 方法：
- **`localStorage`**：持久化存储，需手动清理。
- **`sessionStorage`**：会话级存储，关闭标签页后失效。

#### 示例：
```javascript
// 存储
localStorage.setItem('userSettings', JSON.stringify({ theme: 'dark' }));

// 读取
const settings = JSON.parse(localStorage.getItem('userSettings'));
```

---

### 4. **IndexedDB**
适用于缓存大量结构化数据（如离线应用数据）。

#### 示例：
```javascript
const request = indexedDB.open('myDatabase', 1);

request.onupgradeneeded = (event) => {
    const db = event.target.result;
    const store = db.createObjectStore('files', { keyPath: 'id' });
};

request.onsuccess = (event) => {
    const db = event.target.result;
    const tx = db.transaction('files', 'readwrite');
    const store = tx.objectStore('files');
    store.put({ id: 1, data: 'cached content' });
};
```

---

### 5. **Application Cache（已废弃）**
⚠️ 不推荐使用（已被 Service Worker 替代）。

---

### 6. **文件系统缓存（File System API）**
适用于需要缓存文件内容的场景（如 PWA 中的文件读写）。

#### 示例：
```javascript
navigator.storage.getDirectory().then((root) => {
    root.getFileHandle('config.json', { create: true });
});
```

---

### 7. **CDN 缓存**
通过 CDN 边缘节点缓存静态资源，减少回源请求。

#### 配置方式：
- 在 CDN 控制台设置缓存规则（如缓存时间、忽略查询参数）。

---

### 8. **Webpack 文件哈希**
通过文件名哈希实现长期缓存（内容变化时文件名变化）。

#### 配置示例（webpack.config.js）：
```javascript
output: {
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].js',
}
```

---

### 9. **Manifest 文件（PWA）**
通过 `manifest.json` 定义离线缓存资源。

#### 示例：
```json
{
    "name": "My App",
    "icons": [
        {
            "src": "/icon-192.png",
            "type": "image/png",
            "sizes": "192x192"
        }
    ]
}
```

---

### 总结
| 方式                | 适用场景                     | 特点                          |
|---------------------|----------------------------|-------------------------------|
| HTTP 缓存           | 所有静态资源                | 依赖浏览器，配置简单           |
| Service Worker      | PWA、离线应用               | 完全控制缓存逻辑               |
| Web Storage         | 小数据缓存                  | 键值对存储，容量小             |
| IndexedDB           | 大量结构化数据              | 异步操作，支持事务             |
| Webpack 哈希        | 前端工程化项目              | 内容变化时自动更新文件名       |

**推荐组合**：
- 对静态资源使用 **HTTP 缓存** + **Webpack 哈希**。
- 对 PWA 使用 **Service Worker** + **IndexedDB**。

通过合理选择缓存策略，可以显著提升应用性能！ 🚀