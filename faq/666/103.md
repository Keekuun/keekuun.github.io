## 103. 如何禁止别人调试自己的前端页面代码？

禁止别人调试前端代码是一个常见的需求，但需要明确的是，**前端代码本质上是公开的**，因为浏览器需要下载并执行这些代码。不过，可以通过一些技术手段增加调试难度，防止普通用户轻易修改或分析代码。以下是几种常见的方法：

---

## **1. 禁用开发者工具（DevTools）**
通过监听 `F12`、`Ctrl+Shift+I` 等快捷键或右键菜单事件，阻止用户打开开发者工具。

### **示例代码**
```typescript
// 监听键盘事件
document.addEventListener('keydown', (e) => {
  // 检测 F12、Ctrl+Shift+I、Ctrl+Shift+J 等
  if (
    e.key === 'F12' ||
    (e.ctrlKey && e.shiftKey && e.key === 'I') ||
    (e.ctrlKey && e.shiftKey && e.key === 'J') ||
    (e.ctrlKey && e.key === 'U')
  ) {
    e.preventDefault();
    alert('开发者工具已禁用！');
  }
});

// 禁用右键菜单
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  alert('右键菜单已禁用！');
});
```

### **缺点**
- 用户可以通过浏览器设置绕过（如直接通过菜单打开 DevTools）。
- 无法阻止 `curl` 或 `Postman` 直接请求接口。

---

## **2. 代码混淆（Obfuscation）**
使用工具对 JavaScript 代码进行混淆，使其难以阅读和调试。

### **推荐工具**
- **[JavaScript Obfuscator](https://obfuscator.io/)**（在线工具）
- **[Terser](https://github.com/terser/terser)**（压缩 + 混淆）
- **[Webpack + UglifyJS](https://webpack.js.org/plugins/uglifyjs-webpack-plugin/)**（构建时混淆）

### **示例混淆后代码**
```javascript
// 原始代码
function hello() {
  console.log("Hello, World!");
}

// 混淆后代码
function _0x1a2b(){console['log']('Hello, World!');}
```
### **优点**
- 大幅增加逆向难度。
- 不影响功能执行。

### **缺点**
- 仍然可以被调试，只是更难读懂。

---

## **3. 检测 DevTools 是否打开**
通过检测窗口大小变化或 `debugger` 语句，干扰调试。

### **示例代码**
```typescript
// 检测 DevTools 是否打开
(function() {
  const threshold = 160; // 窗口宽度变化阈值
  let lastWidth = window.innerWidth;

  setInterval(() => {
    const currentWidth = window.innerWidth;
    if (Math.abs(currentWidth - lastWidth) > threshold) {
      // 如果窗口大小异常变化，可能是 DevTools
      console.log('检测到开发者工具！');
      document.body.innerHTML = '<h1>禁止调试！</h1>';
    }
    lastWidth = currentWidth;
  }, 500);
})();

// 无限 debugger
setInterval(() => {
  debugger;
}, 1000);
```

### **缺点**
- 用户可以通过禁用断点或修改代码绕过。
- 可能影响用户体验。

---

## **4. 使用 WebAssembly（WASM）**
将核心逻辑用 C/C++/Rust 编写，编译成 WebAssembly，使代码更难逆向。

### **适用场景**
- 加密算法、游戏逻辑等高性能需求。
- 关键业务逻辑保护。

### **缺点**
- 开发成本高。
- 仍然可以通过 WASM 调试工具分析。

---

## **5. 服务端校验**
前端防调试只是辅助，关键逻辑应放在服务端校验：
- **接口签名**（如 JWT + 时间戳）。
- **数据加密**（如 AES 加密通信）。
- **权限控制**（如 IP 白名单、Token 校验）。

---

## **6. 禁用 Source Map**
在构建时关闭 `source-map`，防止用户还原原始代码。
```javascript
// webpack.config.js
module.exports = {
  devtool: 'none', // 不生成 source-map
};
```

---

## **7. 使用 CSP（Content Security Policy）**
通过 HTTP 头限制脚本加载，防止注入攻击。
```http
Content-Security-Policy: script-src 'self'
```

---

## **总结**
| 方法 | 效果 | 适用场景 |
|------|------|----------|
| **禁用 DevTools** | ⭐⭐ | 简单防护，可绕过 |
| **代码混淆** | ⭐⭐⭐⭐ | 通用方案，增加逆向难度 |
| **检测 DevTools** | ⭐⭐ | 干扰调试，可绕过 |
| **WebAssembly** | ⭐⭐⭐⭐ | 高性能 + 高安全性 |
| **服务端校验** | ⭐⭐⭐⭐⭐ | 必须配合使用 |
| **禁用 Source Map** | ⭐⭐⭐ | 防止还原代码 |
| **CSP** | ⭐⭐ | 防止脚本注入 |

### **最佳实践**
1. **代码混淆**（必须做）。
2. **关键逻辑放服务端**（核心防护）。
3. **可选的 DevTools 检测**（增加调试难度）。

---

## **⚠️ 重要提醒**
- **前端无法完全防调试**，只能增加难度。
- **安全的核心在服务端**，前端只是辅助。
- 过度防护可能影响用户体验（如无限 `debugger` 会导致页面卡死）。