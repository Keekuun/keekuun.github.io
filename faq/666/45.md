## 45. 一直在 window 上面挂东西是否有什么风险

# 在 window 对象上挂载属性的风险分析

在 JavaScript 中，`window` 对象是全局对象，在浏览器环境中所有全局变量和函数都是 `window` 对象的属性。虽然直接在 `window` 上挂载属性很方便，但这样做存在一些潜在风险：

## 1. 命名冲突风险

### 问题表现
```javascript
// 不同库都可能在 window 上挂载同名属性
window.utils = { ... }; // 你的代码
window.utils = { ... }; // 第三方库代码
// 你的 utils 被覆盖了
```

### 解决方案
```typescript
// 使用命名空间模式
window.MyApp = window.MyApp || {};
MyApp.utils = { ... };

// 或者使用模块化系统 (推荐)
// 使用 ES Modules 或 CommonJS 避免污染全局命名空间
```

## 2. 内存泄漏风险

### 问题表现
```javascript
function setup() {
  window.myData = {
    // 大数据结构...
    element: document.getElementById('big-element')
  };
}
// 即使不再需要，myData 仍然占用内存
```

### 解决方案
```typescript
// 1. 使用弱引用
const data = new WeakMap();
data.set(element, { ... });

// 2. 明确清理机制
class DataManager {
  private static instance: DataManager;
  private data: Record<string, any> = {};

  static getInstance() {
    if (!DataManager.instance) {
      DataManager.instance = new DataManager();
    }
    return DataManager.instance;
  }

  set(key: string, value: any) {
    this.data[key] = value;
  }

  clear(key: string) {
    delete this.data[key];
  }

  destroy() {
    this.data = {};
  }
}

// 使用
const manager = DataManager.getInstance();
manager.set('myData', { ... });
// 不再需要时
manager.clear('myData');
```

## 3. 安全风险

### 问题表现
```javascript
window.userToken = 'eyJhbGciOiJIUzI1NiIs...'; // 敏感数据暴露
```

### 解决方案
```typescript
// 1. 使用闭包保护敏感数据
const authModule = (() => {
  let token: string | null = null;

  return {
    setToken: (newToken: string) => {
      token = newToken;
    },
    getToken: () => {
      return token;
    }
  };
})();

// 2. 使用浏览器安全存储
// 敏感数据存储在 sessionStorage/localStorage 或 HttpOnly cookies 中
```

## 4. 性能影响

### 问题表现
```javascript
// 大量全局变量会增加全局查找时间
window.a = 1;
window.b = 2;
// ... 100个这样的变量
```

### 解决方案
```typescript
// 1. 使用模块化设计
// 每个功能模块有自己的作用域

// 2. 使用单例模式
class AppState {
  private static instance: AppState;
  private state: Record<string, any> = {};

  private constructor() {}

  public static getInstance(): AppState {
    if (!AppState.instance) {
      AppState.instance = new AppState();
    }
    return AppState.instance;
  }

  public set(key: string, value: any): void {
    this.state[key] = value;
  }

  public get(key: string): any {
    return this.state[key];
  }
}

// 使用
AppState.getInstance().set('key', value);
```

## 5. 代码可维护性问题

### 问题表现
```javascript
// 分散在各处的 window 属性设置
window.featureX = { ... }; // 文件A
window.featureY = { ... }; // 文件B
```

### 解决方案
```typescript
// 1. 集中管理全局变量
class GlobalRegistry {
  private static registry: Record<string, any> = {};

  static register(key: string, value: any): void {
    if (this.registry[key]) {
      console.warn(`Overwriting existing global: ${key}`);
    }
    this.registry[key] = value;
  }

  static get(key: string): any {
    return this.registry[key];
  }

  static getAll(): Record<string, any> {
    return {...this.registry};
  }
}

// 2. 使用 TypeScript 接口增强类型安全
declare global {
  interface Window {
    myApp?: {
      version: string;
      utils: {
        // 具体类型定义
      };
    };
  }
}

// 使用时
if (!window.myApp) {
  window.myApp = {
    version: '1.0.0',
    utils: { ... }
  };
}
```

## 6. 最佳实践总结

1. **最小化全局暴露**：只暴露必要的接口到 `window` 对象
   ```typescript
   // 只暴露一个命名空间
   window.MyApp = {
     init: () => { /* ... */ },
     config: { /* ... */ }
   };
   ```

2. **使用模块系统**：优先使用 ES Modules 或 CommonJS
   ```javascript
   // 使用 import/export 而不是挂载到 window
   export function utility() { /* ... */ }
   ```

3. **类型安全**：使用 TypeScript 增强全局变量类型
   ```typescript
   declare global {
     interface Window {
       _gaq?: any[];
       dataLayer?: any[];
     }
   }
   ```

4. **清理机制**：提供明确的销毁方法
   ```typescript
   class GlobalState {
     private static data: Record<string, any> = {};
   
     static set(key: string, value: any) {
       this.data[key] = value;
     }
   
     static clear() {
       this.data = {};
     }
   }
   ```

5. **性能优化**：避免在 `window` 上存储大对象
   ```typescript
   // 使用 WeakMap 存储 DOM 相关数据
   const elementData = new WeakMap<HTMLElement, any>();
   ```

6. **安全考虑**：永远不要在 `window` 上存储敏感信息
   ```typescript
   // 错误做法
   window.userCredentials = { username: 'admin', password: '123456' };
 
   // 正确做法
   const authService = {
     login: (credentials: Credentials) => { /* 直接发送到后端 */ }
   };
   ```

通过遵循这些最佳实践，你可以最大限度地减少在 `window` 对象上挂载属性带来的风险，同时保持代码的灵活性和可维护性。
