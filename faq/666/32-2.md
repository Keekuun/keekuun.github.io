## 32. 如何解决页面请求接口大规模并发问题

衍生问题：前端如何实现多接口原子操作，保证多个接口要么全部成功，要么全部失败？

> 问题：如果我有一个操作，首先需要查询配置、用户信息、产品详情填充到表单一个中，然后表单保存又分了三个接口更新配置、更新用户信息、更新产品等，后端没有给批量接口，都是零散的接口，前端怎么保存快速高效并且保证三者都成功保存或都失败呢

针对这种多接口原子操作场景，前端可以通过以下方案实现事务型保存，这里给出完整的TypeScript实现方案：

### 一、事务控制方案设计

```typescript
// src/utils/transaction.ts
interface TransactionOperation {
  execute: () => Promise<any>;
  rollback?: (error: any) => Promise<void>;
}

class TransactionError extends Error {
  constructor(
    public originalError: any,
    public failedOperationIndex: number,
    message = 'Transaction failed'
  ) {
    super(message);
  }
}

export async function runTransaction(
  operations: TransactionOperation[],
  options?: {
    maxRetries?: number;
    timeout?: number;
  }
) {
  const { maxRetries = 1, timeout = 10000 } = options || {};
  const results: any[] = [];
  let lastError: any = null;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      // 超时控制
      const abortController = new AbortController();
      const timeoutId = setTimeout(() => {
        abortController.abort(`Transaction timeout after ${timeout}ms`);
      }, timeout);

      // 执行所有操作
      for (let i = 0; i < operations.length; i++) {
        const op = operations[i];
        try {
          const result = await op.execute();
          results[i] = result;
        } catch (error) {
          lastError = new TransactionError(error, i);
          throw lastError;
        }
      }

      clearTimeout(timeoutId);
      return results; // 全部成功时返回结果数组
    } catch (error) {
      if (attempt === maxRetries) {
        // 最终失败时执行回滚
        await rollbackOperations(operations, lastError);
        throw error;
      }
      // 重试间隔
      await new Promise(resolve => setTimeout(resolve, 500 * (attempt + 1)));
    }
  }
}

async function rollbackOperations(
  operations: TransactionOperation[],
  error: TransactionError
) {
  // 从失败点逆向回滚
  for (let i = error.failedOperationIndex - 1; i >= 0; i--) {
    const op = operations[i];
    if (op.rollback) {
      try {
        await op.rollback(error.originalError);
      } catch (rollbackError) {
        console.error(`Rollback failed at operation ${i}:`, rollbackError);
      }
    }
  }
}
```

### 二、具体业务场景实现

#### 1. 表单数据加载阶段
```typescript
// src/services/form-service.ts
async function loadFormData(userId: string, productId: string) {
  return Promise.all([
    fetchConfig(),
    fetchUserInfo(userId),
    fetchProductDetail(productId)
  ]);
}
```

#### 2. 表单提交阶段（事务型保存）
```typescript
// src/services/form-service.ts
interface FormData {
  config: any;
  user: any;
  product: any;
}

async function submitForm(data: FormData) {
  // 准备事务操作
  const operations: TransactionOperation[] = [
    {
      execute: () => api.updateConfig(data.config),
      rollback: (error) => revertConfig(data.config.originalVersion)
    },
    {
      execute: () => api.updateUser(data.user),
      rollback: (error) => revertUser(data.user.originalVersion)
    },
    {
      execute: () => api.updateProduct(data.product),
      // 产品更新不需要回滚（业务规则决定）
    }
  ];

  try {
    const results = await runTransaction(operations, {
      maxRetries: 2,
      timeout: 15000
    });
  
    return {
      success: true,
      configVersion: results[0].version,
      userVersion: results[1].version,
      productVersion: results[2].version
    };
  } catch (error) {
    if (error instanceof TransactionError) {
      console.error(`Operation ${error.failedOperationIndex} failed`, error);
    }
    throw new Error('保存失败，所有更改已回滚');
  }
}
```

### 三、备选方案（当后端不支持版本回滚时）

```typescript
// 使用补偿性事务方案
async function submitFormWithCompensation(data: FormData) {
  const state = {
    configUpdated: false,
    userUpdated: false,
    productUpdated: false
  };

  try {
    // 阶段1：尝试更新
    const configResult = await api.updateConfig(data.config);
    state.configUpdated = true;

    const userResult = await api.updateUser(data.user);
    state.userUpdated = true;

    const productResult = await api.updateProduct(data.product);
    state.productUpdated = true;

    return { success: true };
  } catch (error) {
    // 阶段2：补偿处理
    const compensations = [];
  
    if (state.productUpdated && !state.userUpdated) {
      compensations.push(api.revertProduct(data.product.id));
    }
  
    if (state.userUpdated && !state.configUpdated) {
      compensations.push(api.revertUser(data.user.id));
    }

    await Promise.all(compensations);
    throw new Error('保存失败，已执行补偿操作');
  }
}
```

### 四、优化方案对比

| 方案                | 优点                      | 缺点                          | 适用场景                  |
|---------------------|--------------------------|-----------------------------|-------------------------|
| 事务控制方案         | 强一致性，自动回滚         | 需要后端支持版本回滚           | 金融、订单等关键业务       |
| 补偿性事务方案       | 不依赖后端特殊接口         | 补偿逻辑复杂，可能部分成功      | 普通业务表单               |
| 乐观锁方案           | 实现简单                 | 冲突率高时用户体验差           | 低并发编辑场景             |
| 批量接口封装方案     | 减少请求次数             | 需要后端配合改造               | 新系统开发阶段             |

### 五、生产环境最佳实践

1. **添加请求指纹**：
```typescript
// 防止重复提交
let submitFingerprint = '';

async function safeSubmit(data: FormData) {
  const fp = hashFormData(data);
  if (submitFingerprint === fp) {
    throw new Error('请勿重复提交相同表单');
  }

  submitFingerprint = fp;
  try {
    return await submitForm(data);
  } finally {
    submitFingerprint = '';
  }
}
```

2. **可视化重试机制**：
```typescript
function showRetryDialog(error) {
  return new Promise((resolve) => {
    // 显示弹窗让用户选择重试
    modal.confirm({
      title: '保存失败',
      content: error.message,
      onOk: () => resolve(true),
      onCancel: () => resolve(false)
    });
  });
}

async function submitWithRetry(data: FormData) {
  let retryCount = 0;

  while (retryCount < 3) {
    try {
      return await submitForm(data);
    } catch (error) {
      if (!await showRetryDialog(error)) break;
      retryCount++;
    }
  }

  throw new Error('超过最大重试次数');
}
```

3. **性能监控埋点**：
```typescript
const submitMetrics = {
  startTime: 0,
  endTime: 0,

  start() {
    this.startTime = performance.now();
  },

  end(success: boolean) {
    this.endTime = performance.now();
    monitor.track('formSubmit', {
      duration: this.endTime - this.startTime,
      success,
      formType: 'complex'
    });
  }
};

async function monitoredSubmit(data: FormData) {
  submitMetrics.start();
  try {
    const result = await submitForm(data);
    submitMetrics.end(true);
    return result;
  } catch (error) {
    submitMetrics.end(false);
    throw error;
  }
}
```

### 六、与后端协作建议

1. **理想方案**：
```markdown
请后端提供以下接口之一：
1. 批量操作接口：POST /api/batch-update
2. 事务型接口：POST /api/transaction
3. 版本化更新接口：PUT /resources/{id}?version={version}

请求体示例：
{
  "operations": [
    { "type": "config", "data": {...}, "version": 123 },
    { "type": "user", "data": {...}, "version": 456 }
  ]
}
```

2. **临时解决方案**：
- 使用前端事务控制方案
- 重要操作增加二次确认
- 实现自动冲突检测

这种方案可以在保证业务一致性的前提下，即便后端接口零散也能实现可靠的多操作事务处理。根据业务重要性选择适合的实现层级，关键业务建议最终推动后端实现原子操作接口。
