## 42. 函数式编程了解多少？

函数式编程是一种以数学函数为基础的编程范式，与面向对象编程(OOP)和过程式编程并列的三大主流编程范式之一。

## 一、函数式编程核心概念

### 1. 一等函数（First-class Functions）

> 一等函数是指函数可以像其他数据类型一样被传递、返回和赋值。它们可以作为参数传递给其他函数，也可以从函数中返回。


```typescript
// 函数可以像变量一样被传递
const greet = (name: string) => `Hello, ${name}!`;
const logger = (fn: (s: string) => string) => (text: string) => {
  console.log(fn(text));
  return fn(text);
};

const loggedGreet = logger(greet);
loggedGreet("World"); // 输出: Hello, World!
```

### 2. 纯函数（Pure Functions）

> 纯函数是指在相同的输入下，总是返回相同的输出，并且没有副作用（不修改外部状态）。

```typescript
// 纯函数示例
const sum = (a: number, b: number): number => a + b;

// 非纯函数示例（依赖外部状态）
let taxRate = 0.1;
const calculateTax = (amount: number): number => amount * taxRate;
```

### 3. 不可变性（Immutability）
```typescript
// 不可变数据操作
const original = [1, 2, 3];
const updated = [...original, 4]; // 不修改原数组

// 对象不可变更新
const user = { name: "Alice", age: 30 };
const updatedUser = { ...user, age: 31 };
```

## 二、函数式编程关键技术

### 1. 高阶函数（Higher-order Functions）

> 高阶函数是指接受函数作为参数或返回一个函数的函数。这是函数式编程的核心特性之一。

```typescript
// 接受函数作为参数
const map = <T, U>(arr: T[], fn: (item: T) => U): U[] => arr.map(fn);

// 返回函数的函数
const multiplier = (factor: number) => (x: number) => x * factor;
const double = multiplier(2);
console.log(double(5)); // 10
```

### 2. 函数组合（Function Composition）

> 函数组合是指将多个函数组合成一个新函数，使得新函数的输出是前一个函数的输入。

```typescript
// 基本组合
const compose = <T>(...fns: Array<(arg: T) => T>) => (x: T) => 
  fns.reduceRight((acc, fn) => fn(acc), x);

const add1 = (x: number) => x + 1;
const square = (x: number) => x * x;
const addThenSquare = compose(square, add1);

console.log(addThenSquare(2)); // (2 + 1)^2 = 9
```

### 3. 柯里化（Currying）

> 柯里化是将一个接受多个参数的函数转换为一系列接受单一参数的函数。

```typescript
// 手动柯里化
const curriedAdd = (a: number) => (b: number) => a + b;
const add5 = curriedAdd(5);
console.log(add5(3)); // 8

// 自动柯里化工具函数
const curry = <T>(fn: (...args: any[]) => T) => {
  const arity = fn.length;

  return function curried(...args: any[]): any {
    if (args.length >= arity) {
      return fn(...args);
    }
    return (...moreArgs: any[]) => curried(...args, ...moreArgs);
  };
};

const curriedSum = curry((a: number, b: number, c: number) => a + b + c);
console.log(curriedSum(1)(2)(3)); // 6
```

## 三、函数式编程实践模式

### 1. 声明式编程（Declarative Style）
```typescript
// 命令式 vs 声明式

// 命令式（How）
const imperativeSum = (nums: number[]): number => {
  let total = 0;
  for (const num of nums) {
    total += num;
  }
  return total;
};

// 声明式（What）
const declarativeSum = (nums: number[]): number => 
  nums.reduce((acc, num) => acc + num, 0);
```

### 2. 惰性求值（Lazy Evaluation）
```typescript
// 生成无限序列
function* fibonacci(): Generator<number> {
  let [a, b] = [0, 1];
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

// 只计算需要的部分
const firstTen = Array.from(
  { length: 10 },
  (_, i) => [...fibonacci()][i]
);
```

### 3. 模式匹配（Pattern Matching）
```typescript
// TypeScript中的模拟模式匹配
type Result<T, E> = 
  | { kind: "ok"; value: T } 
  | { kind: "error"; error: E };

const match = <T, E, R>(
  result: Result<T, E>, 
  patterns: {
    ok: (value: T) => R;
    error: (error: E) => R;
  }
): R => {
  switch (result.kind) {
    case "ok": return patterns.ok(result.value);
    case "error": return patterns.error(result.error);
  }
};

// 使用示例
const result: Result<number, string> = { kind: "ok", value: 42 };
const value = match(result, {
  ok: v => v * 2,
  error: e => 0
});
```

## 四、函数式编程在TypeScript中的应用

### 1. 常用工具类型
```typescript
// 函数式工具类型
type Predicate<T> = (value: T) => boolean;
type Mapper<T, U> = (value: T) => U;
type Reducer<T, U> = (accumulator: U, value: T) => U;

// 实用函数
const filter = <T>(predicate: Predicate<T>) => (arr: T[]) => arr.filter(predicate);
const map = <T, U>(mapper: Mapper<T, U>) => (arr: T[]) => arr.map(mapper);
```

### 2. Either/Maybe处理副作用
```typescript
// Either类型
type Either<L, R> = Left<L> | Right<R>;

class Left<L> {
  constructor(readonly value: L) {}
  isLeft(): this is Left<L> { return true; }
  isRight(): this is Right<never> { return false; }
}

class Right<R> {
  constructor(readonly value: R) {}
  isLeft(): this is Left<never> { return false; }
  isRight(): this is Right<R> { return true; }
}

// 使用示例
const safeDivide = (a: number, b: number): Either<string, number> => 
  b === 0 ? new Left("Division by zero") : new Right(a / b);

const result = safeDivide(10, 2);
if (result.isRight()) {
  console.log(result.value); // 5
}
```

### 3. IO Monad处理副作用
```typescript
// IO Monad实现
class IO<T> {
  constructor(private effect: () => T) {}

  static of<T>(value: T): IO<T> {
    return new IO(() => value);
  }

  map<U>(f: (value: T) => U): IO<U> {
    return new IO(() => f(this.effect()));
  }

  chain<U>(f: (value: T) => IO<U>): IO<U> {
    return new IO(() => f(this.effect()).effect());
  }

  run(): T {
    return this.effect();
  }
}

// 使用示例
const getEnvVar = (name: string): IO<string | undefined> => 
  new IO(() => process.env[name]);

const program = getEnvVar("HOME")
  .map(home => `Home directory is ${home}`)
  .map(console.log);

program.run(); // 执行副作用
```

## 五、函数式编程与面向对象编程对比

### 1. 设计哲学对比
| 特性                | 函数式编程               | 面向对象编程             |
|---------------------|-------------------------|-------------------------|
| 核心单元            | 函数                    | 对象                    |
| 状态管理            | 不可变数据              | 可变对象状态            |
| 主要组合方式        | 函数组合                | 对象组合/继承           |
| 设计重点            | 数据转换流程            | 对象间关系              |
| 典型语言            | Haskell, Clojure       | Java, C++              |

### 2. 混合使用示例
```typescript
// 函数式风格的类
class FunctionalStack<T> {
  private constructor(private readonly items: readonly T[]) {}

  static empty<T>(): FunctionalStack<T> {
    return new FunctionalStack([]);
  }

  push(item: T): FunctionalStack<T> {
    return new FunctionalStack([...this.items, item]);
  }

  pop(): [T | undefined, FunctionalStack<T>] {
    const newItems = this.items.slice(0, -1);
    return [this.items[this.items.length - 1], new FunctionalStack(newItems)];
  }

  map<U>(f: (item: T) => U): FunctionalStack<U> {
    return new FunctionalStack(this.items.map(f));
  }
}

// 使用示例
const stack = FunctionalStack.empty<number>();
const stack1 = stack.push(1).push(2);
const [popped, stack2] = stack1.pop();
```

## 六、函数式编程的优缺点

### 1. 优势
```typescript
// 1. 更易推理的代码
const pureFunction = (a: number, b: number) => a + b;

// 2. 更好的可测试性
test('adds numbers', () => {
  expect(pureFunction(2, 3)).toBe(5);
});

// 3. 天然的并发安全性
const processInParallel = (data: number[]) => {
  return Promise.all(data.map(async x => pureFunction(x, 10)));
};
```

### 2. 挑战
```typescript
// 1. 学习曲线陡峭
const monadicCode = someValue
  .flatMap(x => parse(x))
  .flatMap(y => validate(y))
  .getOrElse(defaultValue);

// 2. 性能考虑（内存和CPU）
const bigArray = Array(1e6).fill(0);
const transformed = bigArray.map(x => x + 1); // 创建新数组

// 3. 与现有代码库集成
class LegacyComponent {
  state = { count: 0 };

  // 非纯方法
  increment() {
    this.setState({ count: this.state.count + 1 });
  }
}
```

## 七、现代JavaScript/TypeScript中的FP特性

### 1. 内置高阶函数
```typescript
const numbers = [1, 2, 3, 4];

// 函数式数组操作
const doubledEvens = numbers
  .filter(n => n % 2 === 0)  // [2, 4]
  .map(n => n * 2);           // [4, 8]

// 对象操作
const person = { name: "Alice", age: 30 };
const updated = Object.entries(person)
  .map(([key, value]) => [key, typeof value === 'number' ? value + 1 : value])
  .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
```

### 2. 现代异步模式
```typescript
// Promise链式调用
fetch('/api/data')
  .then(response => response.json())
  .then(data => processData(data))
  .catch(error => handleError(error));

// async/await
const loadData = async () => {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    return processData(data);
  } catch (error) {
    handleError(error);
  }
};
```

## 八、函数式编程资源推荐

### 1. 学习资源
```typescript
const resources = {
  books: [
    "Functional Programming in JavaScript (by Luis Atencio)",
    "Mostly Adequate Guide to FP (by Brian Lonsdorf)"
  ],
  libraries: [
    "fp-ts (TypeScript)",
    "Ramda (JavaScript)",
    "lodash/fp"
  ],
  concepts: [
    "Functor/Applicative/Monad",
    "Algebraic Data Types",
    "Lenses"
  ]
};
```

### 2. 实用建议
```typescript
// 渐进式采用FP
const adoptionStrategy = [
  "从纯函数开始",
  "尝试不可变数据",
  "使用高阶函数",
  "探索函数组合",
  "逐步引入更高级概念"
];
```

函数式编程是一种强大的编程范式，它能够：
1. 提高代码的可预测性和可维护性
2. 简化复杂的数据转换流程
3. 更好地处理异步和并发场景
4. 促进声明式的编程风格

在TypeScript中，我们可以逐步采用函数式编程理念，结合类型系统的优势，构建更健壮、更易推理的应用程序。建议从纯函数和不可变性开始，逐步探索更高级的函数式概念。
