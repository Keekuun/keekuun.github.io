## 100. 列表分页，快速翻页下的竞态问题

在列表分页场景中，**快速翻页**可能引发**竞态问题（Race Condition）**，即先发起的请求后返回，导致页面显示的数据与当前分页状态不一致。以下是解决方案和代码实现：

---

## **1. 问题复现**
假设用户快速点击分页按钮：
1. 点击第2页 → 发起请求A。
2. 立即点击第3页 → 发起请求B。
3. 如果请求B先返回，请求A后返回，最终显示的是第2页的数据（错误状态）。

---

## **2. 解决方案**
### **方案 1：取消旧请求**
使用 **AbortController** 取消未完成的请求。
```typescript
let controller: AbortController | null = null;

async function fetchPage(page: number) {
  // 取消上一个未完成的请求
  if (controller) controller.abort();

  controller = new AbortController();
  try {
    const response = await fetch(`/api/data?page=${page}`, {
      signal: controller.signal,
    });
    const data = await response.json();
    updateUI(data); // 更新页面数据
  } catch (error) {
    if (error.name !== 'AbortError') {
      console.error('请求失败:', error);
    }
  }
}
```

### **方案 2：请求标记（Request ID）**
为每个请求分配唯一ID，只处理最新请求的响应。
```typescript
let currentRequestId = 0;

async function fetchPage(page: number) {
  const requestId = ++currentRequestId;
  const response = await fetch(`/api/data?page=${page}`);
  const data = await response.json();

  // 只处理最新的请求
  if (requestId === currentRequestId) {
    updateUI(data);
  }
}
```

### **方案 3：防抖（Debounce）**
限制请求频率，确保只有最后一次操作生效。
```typescript
import { debounce } from 'lodash-es';

const debouncedFetch = debounce(async (page: number) => {
  const response = await fetch(`/api/data?page=${page}`);
  const data = await response.json();
  updateUI(data);
}, 300); // 300ms 内只执行最后一次

function handlePageChange(page: number) {
  debouncedFetch(page);
}
```

### **方案 4：禁用分页按钮**
在请求完成前禁用按钮，防止重复操作。
```typescript
let isFetching = false;

async function fetchPage(page: number) {
  if (isFetching) return;
  isFetching = true;

  try {
    const response = await fetch(`/api/data?page=${page}`);
    const data = await response.json();
    updateUI(data);
  } finally {
    isFetching = false;
  }
}
```

---

## **3. 完整实现（React 示例）**
结合 **AbortController** 和 **请求标记**：
```tsx
import { useState, useEffect } from 'react';

function PaginatedList() {
  const [data, setData] = useState([]);
  const [page, setPage] = useState(1);
  const [controller, setController] = useState<AbortController | null>(null);
  const [requestId, setRequestId] = useState(0);

  useEffect(() => {
    const fetchData = async () => {
      // 取消旧请求
      if (controller) controller.abort();
      const newController = new AbortController();
      setController(newController);

      const currentRequestId = requestId + 1;
      setRequestId(currentRequestId);

      try {
        const response = await fetch(`/api/data?page=${page}`, {
          signal: newController.signal,
        });
        const result = await response.json();

        // 只处理最新请求
        if (currentRequestId === requestId + 1) {
          setData(result);
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Error:', error);
        }
      }
    };

    fetchData();
  }, [page]);

  return (
    <div>
      <ul>
        {data.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
      <button onClick={() => setPage(page - 1)} disabled={page === 1}>
        上一页
      </button>
      <span>当前页: {page}</span>
      <button onClick={() => setPage(page + 1)}>下一页</button>
    </div>
  );
}
```

---

## **4. 方案对比**
| **方案**              | **适用场景**               | **优点**                      | **缺点**                     |
|-----------------------|--------------------------|------------------------------|-----------------------------|
| **取消旧请求**        | 需要即时响应的场景         | 精准控制请求生命周期          | 需要处理取消错误（`AbortError`） |
| **请求标记**          | 简单分页逻辑               | 实现简单                      | 不适用于并发请求              |
| **防抖**              | 用户频繁操作（如搜索框）   | 减少请求压力                  | 延迟响应，体验可能受影响       |
| **禁用按钮**          | 防止重复提交               | 用户体验直观                  | 不能解决所有竞态问题           |

---

## **5. 额外优化**
- **数据预加载**：在用户悬停分页按钮时预加载下一页数据。
- **本地缓存**：缓存已请求的分页数据（如使用 `SWR` 或 `React Query`）。

---

## **总结**
通过 **取消请求**、**请求标记** 或 **防抖**，可以有效解决快速翻页的竞态问题。根据项目需求选择合适方案，确保数据一致性！ 🚀