## 69. 虚拟滚动动态高度

在虚拟滚动中，如果 **`itemHeight` 不确定**（即每个列表项的高度动态变化），传统的固定高度计算方式会失效。以下是解决方案和实现思路：

---

## **1. 核心问题**
- **传统虚拟滚动**：依赖固定的 `itemHeight` 计算可视区域和滚动位置。
- **动态高度**：每个项的高度可能不同（如文本换行、图片加载等），导致无法预先计算滚动偏移量。

---

## **2. 解决方案**
### **(1) 动态测量 + 位置缓存**
- **步骤**：
    1. **首次渲染时测量**：渲染每一项并记录实际高度。
    2. **缓存位置**：根据测量结果计算每个项的起始位置（`startOffset`）和结束位置（`endOffset`）。
    3. **滚动时查询缓存**：通过二分查找快速定位可视区域的项。

- **优点**：精确控制滚动行为。
- **缺点**：首次渲染需测量所有项（性能开销大）。

### **(2) 预估高度 + 动态调整**
- **步骤**：
    1. **初始使用预估高度**：假设所有项高度为 `estimatedHeight`。
    2. **滚动时动态调整**：当项进入可视区域时，测量实际高度并更新缓存。
    3. **修正滚动位置**：根据实际高度调整后续项的偏移量。

- **优点**：避免首次全量测量。
- **缺点**：快速滚动时可能出现短暂跳动。

### **(3) 使用现有库**
- **推荐库**：
    - `react-window`（`VariableSizeList` 组件）。
    - `react-virtualized`（`CellMeasurer` 组件）。
    - `@tanstack/react-virtual`（动态高度支持）。

---

## **3. 代码实现（动态测量 + 缓存）**
以下是一个简化版的动态高度虚拟滚动实现（React + TypeScript）：

```tsx
import React, { useState, useRef, useEffect } from 'react';

interface DynamicVirtualScrollProps {
  data: any[]; // 数据源
  estimatedItemHeight: number; // 预估高度
  renderItem: (item: any, index: number) => React.ReactNode; // 渲染函数
  containerHeight: number; // 容器高度
}

const DynamicVirtualScroll: React.FC<DynamicVirtualScrollProps> = ({
  data,
  estimatedItemHeight,
  renderItem,
  containerHeight,
}) => {
  const [positions, setPositions] = useState<{ offset: number; height: number }[]>([]);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 0 });
  const containerRef = useRef<HTMLDivElement>(null);

  // 初始化位置缓存（基于预估高度）
  useEffect(() => {
    const initialPositions = data.map((_, index) => ({
      offset: index * estimatedItemHeight,
      height: estimatedItemHeight,
    }));
    setPositions(initialPositions);
  }, [data, estimatedItemHeight]);

  // 动态测量实际高度并更新缓存
  const updateItemHeight = (index: number, height: number) => {
    if (positions[index].height === height) return;

    setPositions(prev => {
      const newPositions = [...prev];
      newPositions[index] = { ...newPositions[index], height };

      // 修正后续项的偏移量
      for (let i = index + 1; i < newPositions.length; i++) {
        newPositions[i].offset = newPositions[i - 1].offset + newPositions[i - 1].height;
      }

      return newPositions;
    });
  };

  // 计算可视区域
  const calculateVisibleRange = () => {
    if (!containerRef.current) return;

    const { scrollTop } = containerRef.current;
    const startIndex = findNearestIndex(scrollTop);
    const endIndex = findNearestIndex(scrollTop + containerHeight);

    setVisibleRange({ start: startIndex, end: endIndex });
  };

  // 二分查找最近的项
  const findNearestIndex = (offset: number) => {
    let low = 0;
    let high = positions.length - 1;

    while (low <= high) {
      const mid = Math.floor((low + high) / 2);
      const midOffset = positions[mid].offset;

      if (midOffset === offset) return mid;
      else if (midOffset < offset) low = mid + 1;
      else high = mid - 1;
    }

    return low;
  };

  // 处理滚动事件
  const handleScroll = () => {
    calculateVisibleRange();
  };

  // 初始化容器高度和可视区域
  useEffect(() => {
    if (containerRef.current) {
      containerRef.current.style.height = `${containerHeight}px`;
      calculateVisibleRange();
    }
  }, [containerHeight]);

  return (
    <div
      ref={containerRef}
      style={{ overflowY: 'auto', border: '1px solid #ccc', position: 'relative' }}
      onScroll={handleScroll}
    >
      {/* 上方占位区域 */}
      <div style={{ height: `${positions[visibleRange.start]?.offset || 0}px` }}></div>

      {/* 渲染可视区域内的项 */}
      {data.slice(visibleRange.start, visibleRange.end + 1).map((item, index) => {
        const realIndex = visibleRange.start + index;
        return (
          <div
            key={realIndex}
            ref={node => {
              if (node) {
                const height = node.getBoundingClientRect().height;
                updateItemHeight(realIndex, height);
              }
            }}
          >
            {renderItem(item, realIndex)}
          </div>
        );
      })}

      {/* 下方占位区域 */}
      <div
        style={{
          height: `${
            positions[positions.length - 1]?.offset +
            positions[positions.length - 1]?.height -
            positions[visibleRange.end]?.offset
          }px`
        }}
      ></div>
    </div>
  );
};

// 使用示例
const App: React.FC = () => {
  const data = Array.from({ length: 1000 }, (_, i) => ({
    id: i,
    content: `Item ${i} - ${'Lorem ipsum '.repeat(Math.random() * 10)}`, // 动态内容
  }));

  return (
    <DynamicVirtualScroll
      data={data}
      estimatedItemHeight={50}
      containerHeight={500}
      renderItem={(item) => <div style={{ padding: '10px' }}>{item.content}</div>}
    />
  );
};

export default App;
```

---

## **4. 关键优化点**
1. **惰性测量**：仅在项进入可视区域时测量实际高度。
2. **二分查找**：快速定位滚动位置对应的项。
3. **偏移量修正**：动态更新缓存后，立即修正后续项的位置。

---

## **5. 现有库的解决方案**
### **(1) react-window (VariableSizeList)**
```tsx
import { VariableSizeList } from 'react-window';

const rowHeights = new Array(1000).fill(true).map(() => 50 + Math.random() * 100);

const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
  <div style={style}>Row {index}</div>
);

const App = () => (
  <VariableSizeList
    height={500}
    itemCount={1000}
    itemSize={index => rowHeights[index]} // 动态高度函数
    width="100%"
  >
    {Row}
  </VariableSizeList>
);
```

### **(2) @tanstack/react-virtual**
```tsx
import { useVirtualizer } from '@tanstack/react-virtual';

const parentRef = useRef<HTMLDivElement>(null);
const virtualizer = useVirtualizer({
  count: 1000,
  getScrollElement: () => parentRef.current,
  estimateSize: () => 50, // 预估高度
});

// 渲染逻辑类似 react-window
```

---

## **6. 总结**
- **动态高度虚拟滚动的核心**：
    - 测量实际高度 + 维护位置缓存。
    - 快速查找 + 动态调整偏移量。
- **推荐使用成熟库**：如 `react-window` 或 `@tanstack/react-virtual`，避免重复造轮子。

通过合理的设计，即使是不定高的虚拟滚动也能实现流畅体验！ 🚀