## 63. [代码实现] JS 中如何实现大对象深度对比

在 JavaScript 中实现大对象的深度对比（Deep Comparison）是一个常见的需求，尤其是在需要比较两个复杂对象是否完全相等时（例如在状态管理、测试断言等场景）。以下是几种实现方式及其优缺点分析：

---

## **1. 递归深度对比**
通过递归遍历对象的每一个属性，逐一比较。

### **代码实现**
```typescript
function deepEqual(obj1: any, obj2: any): boolean {
  // 1. 基本类型直接比较
  if (obj1 === obj2) return true;

  // 2. 检查是否为 null 或 undefined
  if (obj1 == null || obj2 == null || typeof obj1 !== 'object' || typeof obj2 !== 'object') {
    return false;
  }

  // 3. 比较对象的键数量
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) return false;

  // 4. 递归比较每个属性
  for (const key of keys1) {
    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
      return false;
    }
  }

  return true;
}
```

### **测试用例**
```typescript
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { a: 1, b: { c: 2 } };
const obj3 = { a: 1, b: { c: 3 } };

console.log(deepEqual(obj1, obj2)); // true
console.log(deepEqual(obj1, obj3)); // false
```

✅ **优点**：
- 完全自定义，适用于任何对象结构。
- 不依赖第三方库。

❌ **缺点**：
- 递归可能导致栈溢出（Stack Overflow）如果对象层级过深。
- 性能较差（时间复杂度为 `O(n)`，`n` 为对象属性总数）。

---

## **2. JSON.stringify 对比**
将对象转换为 JSON 字符串后比较。

### **代码实现**
```typescript
function deepEqualJSON(obj1: any, obj2: any): boolean {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}
```

✅ **优点**：
- 实现简单，代码量少。
- 适用于简单对象。

❌ **缺点**：
- **不可靠**：属性顺序不同会导致误判（`{a:1, b:2}` 和 `{b:2, a:1}` 会被认为不相等）。
- 无法处理 `undefined`、`函数`、`Symbol` 等特殊类型。
- 性能问题：大对象转换字符串耗时较长。

---

## **3. 使用 Lodash 的 `_.isEqual`**
Lodash 提供了成熟的深度对比方法。

### **安装**
```bash
npm install lodash
```

### **代码实现**
```typescript
import _ from 'lodash';

const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { a: 1, b: { c: 2 } };

console.log(_.isEqual(obj1, obj2)); // true
```

✅ **优点**：
- 支持各种复杂对象（包括 `Map`、`Set`、`Buffer` 等）。
- 性能优化较好（Lodash 内部做了大量优化）。

❌ **缺点**：
- 需要引入第三方库。

---

## **4. 使用 `structuredClone` 对比**
通过浏览器原生 API 深度克隆后比较（仅适用于部分场景）。

### **代码实现**
```typescript
function deepEqualStructuredClone(obj1: any, obj2: any): boolean {
  try {
    const clone1 = structuredClone(obj1);
    const clone2 = structuredClone(obj2);
    return JSON.stringify(clone1) === JSON.stringify(clone2);
  } catch (e) {
    return false; // 不支持克隆的类型（如函数）
  }
}
```

✅ **优点**：
- 浏览器原生支持，无需额外依赖。

❌ **缺点**：
- 兼容性问题（旧浏览器不支持）。
- 无法克隆某些特殊类型（如函数、DOM 节点）。

---

## **5. 性能优化版深度对比**
针对大对象的优化方案：
1. **缓存已比较的对象**，避免循环引用导致的无限递归。
2. **非递归遍历**（使用栈或队列替代递归）。

### **代码实现（非递归 + 缓存）**
```typescript
function deepEqualOptimized(obj1: any, obj2: any): boolean {
  const stack = [{ a: obj1, b: obj2 }];
  const cache = new Set();

  while (stack.length) {
    const { a, b } = stack.pop()!;

    if (a === b) continue;
    if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
      return false;
    }

    // 检查缓存，避免循环引用
    const cacheKey = `${a}-${b}`;
    if (cache.has(cacheKey)) continue;
    cache.add(cacheKey);

    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;

    for (const key of keysA) {
      if (!keysB.includes(key)) return false;
      stack.push({ a: a[key], b: b[key] });
    }
  }

  return true;
}
```

✅ **优点**：
- 避免递归栈溢出。
- 处理循环引用。

❌ **缺点**：
- 实现复杂。

---

## **6. 对比不同方法的适用场景**
| 方法                  | 适用场景                          | 是否推荐 |
|-----------------------|----------------------------------|----------|
| **递归深度对比**       | 简单对象，无循环引用              | ✅        |
| **JSON.stringify**    | 简单对象，属性顺序固定            | ❌        |
| **Lodash `_.isEqual`**| 任何复杂对象，需要高可靠性        | ✅        |
| **structuredClone**   | 浏览器环境，无需支持特殊类型      | ❌        |
| **非递归优化版**      | 超大对象或需要处理循环引用        | ✅        |

---

## **7. 最终推荐方案**
1. **一般场景**：直接使用 **Lodash 的 `_.isEqual`**（最省心）。
2. **无第三方库**：用 **递归深度对比** 或 **非递归优化版**。
3. **极简需求**：`JSON.stringify`（但需注意局限性）。

---

## **8. 测试用例**
```typescript
const obj1 = { a: 1, b: { c: 2 }, d: [1, 2, 3] };
const obj2 = { a: 1, b: { c: 2 }, d: [1, 2, 3] };
const obj3 = { a: 1, b: { c: 2 }, d: [1, 2, 4] };

console.log(deepEqual(obj1, obj2)); // true
console.log(deepEqual(obj1, obj3)); // false
console.log(_.isEqual(obj1, obj2)); // true (Lodash)
```

通过以上方法，可以高效、可靠地实现大对象的深度对比！ 🚀