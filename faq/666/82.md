## 82. 在 JS 中，如何解决递归导致栈溢出问题？

在 JavaScript 中，递归导致的栈溢出（Stack Overflow）是由于函数调用层级过深，超出调用栈（Call Stack）的最大限制（如 Chrome 的约 1 万层）。以下是解决方案及其实现原理：

---

## **1. 尾调用优化（Tail Call Optimization, TCO）**
### **原理**
- 如果递归调用是函数的最后一步操作（尾递归），且返回值直接传递（无后续计算），引擎可以复用当前栈帧，避免栈增长。
- **要求**：需在严格模式（`'use strict'`）下运行，且部分引擎（如 Safari）支持，V8 未完全支持。

### **示例**
```javascript
'use strict';
function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc); // 尾递归
}
console.log(factorial(10000)); // 在支持 TCO 的引擎中不会溢出
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 无栈溢出风险           | 仅部分引擎支持               |
| 代码简洁               | 需严格模式                   |

---

## **2. 循环替代递归（手动优化）**
### **原理**
- 用 `while` 或 `for` 循环模拟递归逻辑，避免函数调用栈积累。

### **示例**
```javascript
function factorial(n) {
  let result = 1;
  while (n > 1) {
    result *= n;
    n--;
  }
  return result;
}
console.log(factorial(10000)); // 无栈溢出
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 所有引擎兼容           | 代码可能比递归复杂           |
| 性能高                 | 需手动转换逻辑               |

---

## **3. 蹦床函数（Trampoline）**
### **原理**
- 将递归调用拆解为一系列惰性计算的 `thunk` 函数，通过循环依次执行，避免栈增长。

### **示例**
```javascript
function trampoline(fn) {
  while (typeof fn === 'function') {
    fn = fn();
  }
  return fn;
}

function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return () => factorial(n - 1, n * acc); // 返回函数
}

console.log(trampoline(factorial(10000))); // 无栈溢出
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 兼容所有引擎           | 代码结构复杂                 |
| 不依赖 TCO             | 性能稍低                     |

---

## **4. 异步递归（setTimeout/微任务）**
### **原理**
- 利用事件循环机制，将递归调用拆分为异步任务，清空调用栈。

### **示例**
```javascript
function asyncFactorial(n, acc = 1) {
  if (n <= 1) return Promise.resolve(acc);
  return Promise.resolve().then(() => asyncFactorial(n - 1, n * acc));
}

asyncFactorial(10000).then(console.log); // 无栈溢出
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 兼容性好               | 性能低（任务队列延迟）       |
| 适合简单场景           | 代码异步化                   |

---

## **5. 堆栈模拟（显式管理调用栈）**
### **原理**
- 用数组模拟调用栈，手动管理“调用帧”。

### **示例**
```javascript
function factorial(n) {
  const stack = [{ n, acc: 1 }];
  let result;
  while (stack.length) {
    const { n, acc } = stack.pop();
    if (n <= 1) {
      result = acc;
    } else {
      stack.push({ n: n - 1, acc: n * acc });
    }
  }
  return result;
}

console.log(factorial(10000)); // 无栈溢出
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 完全控制调用过程       | 实现复杂                     |
| 适合复杂递归逻辑       | 代码冗长                     |

---

## **6. 使用生成器（Generator）**
### **原理**
- 通过生成器暂停和恢复执行的能力，分步处理递归。

### **示例**
```javascript
function* factorialGenerator(n, acc = 1) {
  if (n <= 1) yield acc;
  else yield* factorialGenerator(n - 1, n * acc);
}

function run(generator) {
  let result = generator.next();
  while (!result.done) {
    result = generator.next();
  }
  return result.value;
}

console.log(run(factorialGenerator(10000))); // 无栈溢出
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 代码可读性较好         | 实现稍复杂                   |
| 适合分步处理           | 性能中等                     |

---

## **总结与选型建议**
| **方案**          | **适用场景**                  | **兼容性** | **性能** |
|-------------------|-----------------------------|------------|----------|
| 尾调用优化        | 支持 TCO 的引擎（如 Safari） | ❌          | ⭐⭐⭐⭐    |
| 循环替代          | 简单递归逻辑                | ✅          | ⭐⭐⭐⭐⭐   |
| 蹦床函数          | 通用解决方案                | ✅          | ⭐⭐       |
| 异步递归          | 低优先级任务                | ✅          | ⭐         |
| 堆栈模拟          | 复杂递归逻辑                | ✅          | ⭐⭐⭐      |
| 生成器            | 分步处理                    | ✅          | ⭐⭐⭐      |

### **推荐选择**
1. **优先尝试循环替代**：性能最佳，代码易维护。
2. **复杂逻辑用蹦床或堆栈模拟**：平衡可读性与兼容性。
3. **异步场景用微任务**：如 `Promise` 或 `queueMicrotask`。

通过合理选择方案，可以彻底解决递归导致的栈溢出问题！ 🚀