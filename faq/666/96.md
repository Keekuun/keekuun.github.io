## 96. HTTP 是一个无状态的协议，那么 Web 应用要怎么保持用户的登录态呢？

HTTP 是一个无状态协议，这意味着每次请求都是独立的，服务器默认不会记住之前的请求信息。为了在 Web 应用中保持用户的登录状态（即实现“有状态”的会话管理），通常需要借助以下技术手段：

---

## **1. 基于 Cookie 的会话管理**
### **原理**
- 服务器在用户登录成功后生成一个 **唯一会话标识符（Session ID）**，存储在服务器端（如内存、Redis）。
- 通过 `Set-Cookie` 响应头将会话 ID 发送给浏览器，浏览器后续请求自动携带该 Cookie。

### **实现步骤**
1. **用户登录**：
   ```typescript
   // 服务器生成 Session 并返回 Cookie
   app.post('/login', (req, res) => {
     const sessionId = generateSessionId();
     storeSession(sessionId, { userId: 123 }); // 存储到 Redis
     res.setHeader('Set-Cookie', `sessionId=${sessionId}; Path=/; HttpOnly; Secure`);
     res.send('登录成功');
   });
   ```

2. **浏览器自动携带 Cookie**：
   ```http
   GET /profile HTTP/1.1
   Cookie: sessionId=abc123
   ```

3. **服务器验证 Session**：
   ```typescript
   app.get('/profile', (req, res) => {
     const sessionId = req.cookies.sessionId;
     const session = getSession(sessionId); // 从 Redis 读取
     if (!session) return res.status(401).send('未登录');
     res.send(`用户ID: ${session.userId}`);
   });
   ```

### **优点**
- 简单易用，兼容性好。
- 可通过 `HttpOnly` 和 `Secure` 提升安全性。

### **缺点**
- 依赖浏览器 Cookie，可能受跨域限制。
- 服务器需维护 Session 存储。

---

## **2. 基于 Token 的认证（如 JWT）**
### **原理**
- 用户登录后，服务器生成一个 **签名 Token（如 JWT）** 并返回给客户端。
- 客户端后续请求在 `Authorization` 头中携带 Token，服务器直接验证 Token 有效性。

### **实现步骤**
1. **用户登录**：
   ```typescript
   // 服务器生成 JWT
   app.post('/login', (req, res) => {
     const token = jwt.sign({ userId: 123 }, 'secret-key', { expiresIn: '1h' });
     res.json({ token });
   });
   ```

2. **客户端存储 Token**（通常存于 `localStorage` 或 `Cookie`）：
   ```typescript
   // 前端保存 Token
   localStorage.setItem('token', response.data.token);
   ```

3. **请求时携带 Token**：
   ```typescript
   // 前端请求
   axios.get('/profile', {
     headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
   });
   ```

4. **服务器验证 Token**：
   ```typescript
   app.get('/profile', (req, res) => {
     const token = req.headers.authorization?.split(' ')[1];
     try {
       const decoded = jwt.verify(token, 'secret-key');
       res.send(`用户ID: ${decoded.userId}`);
     } catch (err) {
       res.status(401).send('Token 无效');
     }
   });
   ```

### **优点**
- 无状态，服务器无需存储会话。
- 适合分布式系统或跨域场景。

### **缺点**
- Token 一旦签发无法立即撤销（需结合黑名单或短有效期）。
- 需防范 XSS 攻击（避免 `localStorage` 被恶意脚本读取）。

---

## **3. 结合 Cookie 和 Token 的混合模式**
### **场景**
- 为了兼顾安全性和便利性，可将 JWT 存储到 `HttpOnly Cookie` 中。
- 服务器通过 Cookie 读取 Token 并验证。

### **示例**
```typescript
// 服务器设置 HttpOnly Cookie
res.setHeader('Set-Cookie', `token=${token}; Path=/; HttpOnly; Secure`);

// 前端无需手动处理 Token，浏览器自动携带
```

---

## **4. 其他安全措施**
| **措施**               | **作用**                                                                 |
|------------------------|-------------------------------------------------------------------------|
| **CSRF Token**         | 防止跨站请求伪造（配合 Cookie 使用）。                                    |
| **SameSite Cookie**    | 限制 Cookie 的跨站发送（`SameSite=Lax/Strict`）。                        |
| **短 Token 有效期**    | 减少 Token 泄露后的风险。                                                |
| **定期刷新 Token**     | 通过 Refresh Token 机制更新 Access Token。                               |

---

## **5. 常见问题与解决方案**
### **问题 1：如何实现“记住我”功能？**
- 延长 Session 或 Token 有效期（如设置 `expiresIn: '7d'`）。
- 使用 Refresh Token 机制。

### **问题 2：如何强制用户退出？**
- **Session 方案**：删除服务器端 Session。
- **JWT 方案**：维护 Token 黑名单或缩短有效期。

### **问题 3：跨域如何传递认证信息？**
- 配置 CORS 允许 `credentials`：
  ```typescript
  // 服务器
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', 'https://your-frontend.com');
  ```
- 前端启用 `withCredentials`：
  ```typescript
  axios.get('https://api.com/data', { withCredentials: true });
  ```

---

## **总结**
| **方案**          | **适用场景**                     | **关键技术**                          |
|-------------------|--------------------------------|--------------------------------------|
| **Cookie + Session** | 传统 Web 应用                  | `Set-Cookie`, Redis 存储              |
| **JWT**           | 前后端分离、跨域、分布式系统     | `Authorization: Bearer <token>`       |
| **混合模式**       | 高安全性需求                   | HttpOnly Cookie + JWT                 |

根据项目需求选择合适方案，并始终关注安全性！ 🔒
**提示**：对于敏感操作（如支付），建议结合多因素认证（MFA）。