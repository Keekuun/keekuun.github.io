## 40. 扫码登录实现方式 - nestjs 服务端实现

# 使用NestJS实现扫码登录服务端

下面我将使用NestJS框架完整实现扫码登录的服务端逻辑，包括二维码生成、状态轮询、登录确认等核心功能。

## 一、项目结构

```
src/
├── auth/
│   ├── dto/
│   │   ├── qr-login.dto.ts
│   │   └── confirm-login.dto.ts
│   ├── entities/
│   │   └── qr-login.entity.ts
│   ├── guards/
│   │   └── qr-auth.guard.ts
│   ├── strategies/
│   │   └── qr.strategy.ts
│   ├── auth.module.ts
│   ├── auth.controller.ts
│   ├── auth.service.ts
│   └── qr-login.service.ts
├── common/
│   ├── utils/
│   │   └── qrcode.util.ts
│   └── redis/
│       └── redis.service.ts
└── main.ts
```

## 二、核心模块实现

### 1. 安装必要依赖

```bash
npm install qrcode @nestjs/passport passport jwt passport-jwt redis ioredis
npm install @types/passport-jwt @types/qrcode --save-dev
```

### 2. Redis服务封装 (redis.service.ts)

```typescript
import { Injectable, OnModuleDestroy } from '@nestjs/common';
import Redis from 'ioredis';

@Injectable()
export class RedisService implements OnModuleDestroy {
  private client: Redis;

  constructor() {
    this.client = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
    });
  }

  async set(key: string, value: any, ttl?: number): Promise<void> {
    const serialized = JSON.stringify(value);
    if (ttl) {
      await this.client.setex(key, ttl, serialized);
    } else {
      await this.client.set(key, serialized);
    }
  }

  async get<T = any>(key: string): Promise<T | null> {
    const data = await this.client.get(key);
    return data ? JSON.parse(data) : null;
  }

  async del(key: string): Promise<void> {
    await this.client.del(key);
  }

  onModuleDestroy() {
    this.client.disconnect();
  }
}
```

### 3. 二维码工具类 (qrcode.util.ts)

```typescript
import { Injectable } from '@nestjs/common';
import * as QRCode from 'qrcode';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class QRCodeUtil {
  async generateQRCodeDataURL(content: string): Promise<string> {
    return QRCode.toDataURL(content, {
      errorCorrectionLevel: 'H',
      margin: 1,
      width: 300,
    });
  }

  generateToken(): string {
    return uuidv4();
  }
}
```

### 4. QR Login实体 (qr-login.entity.ts)

```typescript
export interface QRLoginSession {
  token: string;
  status: 'pending' | 'scanned' | 'confirmed' | 'expired' | 'cancelled';
  userId?: string;
  deviceInfo?: any;
  createdAt: number;
  expiresAt: number;
  redirectUri?: string;
}
```

### 5. QR Login服务 (qr-login.service.ts)

```typescript
import { Injectable } from '@nestjs/common';
import { RedisService } from '../../common/redis/redis.service';
import { QRCodeUtil } from '../../common/utils/qrcode.util';
import { QRLoginSession } from '../entities/qr-login.entity';

@Injectable()
export class QrLoginService {
  private readonly TTL = 5 * 60 * 1000; // 5分钟

  constructor(
    private readonly redis: RedisService,
    private readonly qrCodeUtil: QRCodeUtil,
  ) {}

  async generateQRLogin(deviceInfo?: any): Promise<{
    token: string;
    qrCode: string;
    expiresAt: number;
  }> {
    const token = this.qrCodeUtil.generateToken();
    const expiresAt = Date.now() + this.TTL;
    const qrContent = `your-app://qr-login?token=${token}`;
    const qrCode = await this.qrCodeUtil.generateQRCodeDataURL(qrContent);

    const session: QRLoginSession = {
      token,
      status: 'pending',
      deviceInfo,
      createdAt: Date.now(),
      expiresAt,
    };

    await this.redis.set(`qr:${token}`, session, this.TTL);

    return { token, qrCode, expiresAt };
  }

  async getQRLoginStatus(token: string): Promise<QRLoginSession | null> {
    return this.redis.get<QRLoginSession>(`qr:${token}`);
  }

  async updateQRLoginStatus(
    token: string,
    status: QRLoginSession['status'],
    userId?: string,
  ): Promise<boolean> {
    const session = await this.getQRLoginStatus(token);
    if (!session) return false;

    session.status = status;
    if (userId) session.userId = userId;

    await this.redis.set(`qr:${token}`, session, this.TTL);
    return true;
  }

  async confirmQRLogin(token: string, userId: string): Promise<boolean> {
    return this.updateQRLoginStatus(token, 'confirmed', userId);
  }

  async cancelQRLogin(token: string): Promise<boolean> {
    return this.updateQRLoginStatus(token, 'cancelled');
  }
}
```

### 6. Auth服务 (auth.service.ts)

```typescript
import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { QrLoginService } from './qr-login.service';

@Injectable()
export class AuthService {
  constructor(
    private readonly jwtService: JwtService,
    private readonly qrLoginService: QrLoginService,
  ) {}

  async generateJWT(user: any): Promise<string> {
    const payload = { sub: user.id, username: user.username };
    return this.jwtService.sign(payload);
  }

  async validateUser(username: string, pass: string): Promise<any> {
    // 这里实现你的用户验证逻辑
    // 通常是查询数据库验证用户
    return null;
  }

  async confirmQRLogin(token: string, user: any): Promise<boolean> {
    const jwt = await this.generateJWT(user);
    return this.qrLoginService.confirmQRLogin(token, user.id);
  }
}
```

### 7. Auth控制器 (auth.controller.ts)

```typescript
import {
  Controller,
  Get,
  Post,
  Query,
  Body,
  UseGuards,
  Req,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { QrLoginService } from './qr-login.service';
import { AuthGuard } from '@nestjs/passport';
import { Request } from 'express';
import { QrLoginStatusDto } from './dto/qr-login.dto';
import { ConfirmLoginDto } from './dto/confirm-login.dto';

@Controller('auth')
export class AuthController {
  constructor(
    private readonly authService: AuthService,
    private readonly qrLoginService: QrLoginService,
  ) {}

  @Get('qr-code')
  async generateQRCode() {
    const { token, qrCode, expiresAt } =
      await this.qrLoginService.generateQRLogin();
    return { token, qrCode, expiresAt };
  }

  @Get('qr-status')
  async getQRStatus(@Query() query: QrLoginStatusDto) {
    const session = await this.qrLoginService.getQRLoginStatus(query.token);
    if (!session) {
      return { status: 'expired' };
    }
    return session;
  }

  @Post('confirm-login')
  @UseGuards(AuthGuard('jwt'))
  async confirmLogin(
    @Body() body: ConfirmLoginDto,
    @Req() req: Request,
  ) {
    const user = req.user;
    const success = await this.authService.confirmQRLogin(
      body.token,
      user,
    );
    return { success };
  }

  @Post('cancel-login')
  async cancelLogin(@Body('token') token: string) {
    const success = await this.qrLoginService.cancelQRLogin(token);
    return { success };
  }
}
```

### 8. DTO定义

#### qr-login.dto.ts
```typescript
import { IsString } from 'class-validator';

export class QrLoginStatusDto {
  @IsString()
  token: string;
}
```

#### confirm-login.dto.ts
```typescript
import { IsString } from 'class-validator';

export class ConfirmLoginDto {
  @IsString()
  token: string;
}
```

### 9. JWT策略 (qr.strategy.ts)

```typescript
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}
```

### 10. Auth模块 (auth.module.ts)

```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { RedisService } from '../common/redis/redis.service';
import { QRCodeUtil } from '../common/utils/qrcode.util';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { QrLoginService } from './qr-login.service';
import { JwtStrategy } from './strategies/qr.strategy';

@Module({
  imports: [
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get('JWT_SECRET'),
        signOptions: { expiresIn: '1h' },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    QrLoginService,
    RedisService,
    QRCodeUtil,
    JwtStrategy,
  ],
  exports: [AuthService],
})
export class AuthModule {}
```

## 三、完整工作流程

1. **客户端获取二维码**
    - 调用 `GET /auth/qr-code`
    - 服务端生成token和二维码
    - 返回给客户端显示

2. **移动端扫码**
    - 解析二维码内容获取token
    - 移动端携带用户凭证调用 `POST /auth/confirm-login`

3. **Web端轮询状态**
    - 调用 `GET /auth/qr-status?token=xxx`
    - 服务端返回当前状态(pending/scanned/confirmed)

4. **登录完成**
    - 当状态变为confirmed后，Web端获取JWT
    - 完成登录流程

## 四、安全增强实现

### 1. 防重放攻击中间件

```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { RedisService } from '../common/redis/redis.service';

@Injectable()
export class QRLoginMiddleware implements NestMiddleware {
  constructor(private readonly redis: RedisService) {}

  async use(req: Request, res: Response, next: NextFunction) {
    if (req.path === '/auth/confirm-login') {
      const token = req.body.token;
      const session = await this.redis.get(`qr:${token}`);
    
      if (!session || session.status !== 'pending') {
        return res.status(400).json({
          error: 'Invalid or expired QR token',
        });
      }
    }
    next();
  }
}
```

### 2. 设备指纹验证

```typescript
// 在QrLoginService中添加
async verifyDevice(token: string, deviceInfo: any): Promise<boolean> {
  const session = await this.getQRLoginStatus(token);
  if (!session) return false;

  // 简单比较设备信息
  return (
    session.deviceInfo?.platform === deviceInfo.platform &&
    session.deviceInfo?.browser === deviceInfo.browser
  );
}
```

## 五、WebSocket实时通知实现

### 1. 安装WebSocket模块

```bash
npm install @nestjs/websockets @nestjs/platform-socket.io
```

### 2. 实现WebSocket网关

```typescript
import {
  WebSocketGateway,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
  WebSocketServer,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { QrLoginService } from '../auth/qr-login.service';

@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class QRLoginGateway {
  @WebSocketServer()
  server: Server;

  constructor(private readonly qrLoginService: QrLoginService) {}

  @SubscribeMessage('subscribe')
  async handleSubscribe(
    @MessageBody() token: string,
    @ConnectedSocket() client: Socket,
  ) {
    // 验证token有效性
    const session = await this.qrLoginService.getQRLoginStatus(token);
    if (!session) {
      client.emit('error', 'Invalid token');
      client.disconnect();
      return;
    }

    // 加入以token为标识的房间
    client.join(token);

    // 发送当前状态
    client.emit('status', { status: session.status });
  }

  async notifyStatusChange(token: string, status: string) {
    this.server.to(token).emit('status', { status });
  }
}
```

### 3. 修改QrLoginService

```typescript
// 在QrLoginService中注入网关
constructor(
  private readonly redis: RedisService,
  private readonly qrCodeUtil: QRCodeUtil,
  private readonly qrLoginGateway: QRLoginGateway,
) {}

// 修改状态更新方法
async updateQRLoginStatus(
  token: string,
  status: QRLoginSession['status'],
  userId?: string,
): Promise<boolean> {
  const session = await this.getQRLoginStatus(token);
  if (!session) return false;

  session.status = status;
  if (userId) session.userId = userId;

  await this.redis.set(`qr:${token}`, session, this.TTL);

  // 通知WebSocket客户端
  await this.qrLoginGateway.notifyStatusChange(token, status);

  return true;
}
```

## 六、测试用例

### 1. 单元测试示例

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { QrLoginService } from './qr-login.service';
import { RedisService } from '../common/redis/redis.service';
import { QRCodeUtil } from '../common/utils/qrcode.util';

describe('QrLoginService', () => {
  let service: QrLoginService;
  let redisService: RedisService;
  let qrCodeUtil: QRCodeUtil;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        QrLoginService,
        {
          provide: RedisService,
          useValue: {
            set: jest.fn(),
            get: jest.fn(),
            del: jest.fn(),
          },
        },
        {
          provide: QRCodeUtil,
          useValue: {
            generateQRCodeDataURL: jest.fn().mockResolvedValue('data:image/png;base64,...'),
            generateToken: jest.fn().mockReturnValue('mock-token'),
          },
        },
      ],
    }).compile();

    service = module.get<QrLoginService>(QrLoginService);
    redisService = module.get<RedisService>(RedisService);
    qrCodeUtil = module.get<QRCodeUtil>(QRCodeUtil);
  });

  it('should generate QR code', async () => {
    const result = await service.generateQRLogin();
    expect(result.token).toBe('mock-token');
    expect(result.qrCode).toContain('data:image');
    expect(redisService.set).toHaveBeenCalled();
  });

  it('should confirm login', async () => {
    jest.spyOn(redisService, 'get').mockResolvedValue({
      token: 'mock-token',
      status: 'pending',
      createdAt: Date.now(),
      expiresAt: Date.now() + 300000,
    });
  
    const result = await service.confirmQRLogin('mock-token', 'user-123');
    expect(result).toBe(true);
  });
});
```

## 七、部署配置

### .env 配置示例

```
REDIS_HOST=localhost
REDIS_PORT=6379
JWT_SECRET=your-secret-key
QR_LOGIN_TTL=300000 # 5分钟
```

### Docker Compose 配置

```yaml
version: '3.8'

services:
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - redis

volumes:
  redis_data:
```

这个NestJS实现提供了完整的扫码登录功能，包括：
1. 二维码生成与状态管理
2. Redis存储会话状态
3. JWT认证集成
4. WebSocket实时通知
5. 完善的错误处理和安全性

可以根据实际需求进一步扩展，如添加日志记录、监控、限流等功能。
