## 101. JS 执行 100 万个任务，如何保证浏览器不卡顿？

在 JavaScript 中执行 **100 万个任务** 时，如果不加以优化，很容易导致浏览器卡顿甚至崩溃。以下是几种高效的方法，确保任务执行时浏览器依然流畅响应：

---

### **1. 分片执行（Chunking）**
将任务拆分成小块，分批执行，避免一次性占用主线程。
```typescript
function executeTasks(tasks: Function[], chunkSize = 1000) {
  let index = 0;

  function processChunk() {
    const chunk = tasks.slice(index, index + chunkSize);
    chunk.forEach(task => task());
    index += chunkSize;

    if (index < tasks.length) {
      setTimeout(processChunk, 0); // 让出主线程
    }
  }

  processChunk();
}

// 示例：生成 100 万个任务
const tasks = Array.from({ length: 1e6 }, (_, i) => () => {
  console.log(`执行任务 ${i}`);
});
executeTasks(tasks);
```
- **优点**：简单易实现，避免主线程阻塞。
- **缺点**：需要手动控制分片大小。

---

### **2. 使用 Web Workers**
将任务放到后台线程执行，完全不影响主线程。
```typescript
// 主线程代码
const worker = new Worker('task-worker.js');
worker.postMessage({ tasks: Array.from({ length: 1e6 }, (_, i) => i) });

worker.onmessage = (e) => {
  console.log('任务完成:', e.data);
};

// task-worker.js
self.onmessage = (e) => {
  const tasks = e.data.tasks;
  tasks.forEach(task => {
    console.log(`Worker 执行任务: ${task}`);
  });
  self.postMessage('所有任务完成');
};
```
- **优点**：彻底解决主线程卡顿问题。
- **缺点**：需要额外文件，通信开销较大。

---

### **3. 异步调度（requestIdleCallback）**
利用浏览器的空闲时间执行任务。
```typescript
function executeIdleTasks(tasks: Function[]) {
  let index = 0;

  function processTask(deadline: IdleDeadline) {
    while (deadline.timeRemaining() > 0 && index < tasks.length) {
      tasks[index++]();
    }

    if (index < tasks.length) {
      requestIdleCallback(processTask);
    }
  }

  requestIdleCallback(processTask);
}
```
- **优点**：充分利用浏览器空闲资源。
- **缺点**：任务执行时间不可控，可能延迟。

---

### **4. 使用 Generator 函数**
通过生成器逐步执行任务，灵活控制执行流程。
```typescript
function* taskGenerator(tasks: Function[]) {
  for (const task of tasks) {
    yield task();
  }
}

const tasks = Array.from({ length: 1e6 }, (_, i) => () => {
  console.log(`执行任务 ${i}`);
});

const generator = taskGenerator(tasks);

function runNextTask() {
  const { done } = generator.next();
  if (!done) {
    setTimeout(runNextTask, 0);
  }
}

runNextTask();
```
- **优点**：代码可读性强，适合复杂任务流。
- **缺点**：需要手动控制执行节奏。

---

### **5. 优化任务逻辑**
- **减少 DOM 操作**：批量更新 DOM 或使用虚拟 DOM（如 React）。
- **避免同步循环**：用 `Promise` 或 `async/await` 替代。
- **内存管理**：及时清理无用变量，避免内存泄漏。

---

### **方案对比**
| 方法               | 适用场景                     | 性能影响 |
|--------------------|----------------------------|---------|
| 分片执行           | 简单任务，快速实现           | ⭐⭐⭐⭐  |
| Web Workers        | CPU 密集型任务              | ⭐⭐⭐⭐⭐ |
| requestIdleCallback| 低优先级任务                | ⭐⭐⭐   |
| Generator          | 需要精细控制的任务流         | ⭐⭐     |

---

### **终极方案**
1. **CPU 密集型任务** → 用 Web Workers。
2. **UI 相关任务** → 分片执行 + `requestIdleCallback`。
3. **复杂流程** → Generator + 异步调度。

---

### **示例：综合方案**
```typescript
// 分片 + 异步 + 空闲调度
function optimizedExecute(tasks: Function[], chunkSize = 1000) {
  let index = 0;

  function processChunk(deadline?: IdleDeadline) {
    const startTime = performance.now();
    while (
      (deadline ? deadline.timeRemaining() > 0 : true) &&
      index < tasks.length &&
      performance.now() - startTime < 50 // 每块最多执行 50ms
    ) {
      tasks[index++]();
    }

    if (index < tasks.length) {
      requestIdleCallback(processChunk, { timeout: 100 });
    }
  }

  processChunk();
}
```

---

### **总结**
- **核心思想**：避免阻塞主线程！
- **推荐组合**：Web Workers（后台计算） + 分片执行（UI 任务）。
- **监控性能**：用 `console.time` 或 `performance` API 分析耗时。