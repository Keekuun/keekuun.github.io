## 50. 移动端如何实现上拉加载，下拉刷新？ —— 动态高度虚拟滚动

# 动态高度虚拟滚动实现方案（瀑布流场景）

对于瀑布流这种动态高度元素的虚拟滚动实现，确实比固定高度复杂得多。以下是完整的解决方案：

## 一、核心实现思路

1. **位置预测与修正机制**：
    - 初始渲染时根据预估高度计算布局
    - 实际渲染后获取真实高度并修正位置
    - 维护一个高度缓存表（PositionCache）

2. **双缓冲渲染**：
    - 可视区域上下各预留一定缓冲区域
    - 避免快速滚动时出现空白

3. **异步高度收集**：
    - 图片加载完成后更新高度信息
    - 文本渲染后获取最终高度

## 二、完整TypeScript实现

### 1. 位置缓存类实现

```typescript
interface PositionCacheItem {
  top: number;
  height: number;
  column: number; // 0或1表示左列或右列
}

class PositionCache {
  private cache: PositionCacheItem[] = [];
  private columnHeights = [0, 0]; // 两列当前高度

  // 预估高度（可根据历史数据动态调整）
  private estimatedHeight = 200;

  // 添加新项（初始化时使用预估高度）
  addItem(column?: number): PositionCacheItem {
    // 自动选择当前高度较小的列
    const targetColumn = column ?? (this.columnHeights[0] <= this.columnHeights[1] ? 0 : 1);
    const top = this.columnHeights[targetColumn];
  
    const item = {
      top,
      height: this.estimatedHeight,
      column: targetColumn
    };
  
    this.cache.push(item);
    this.columnHeights[targetColumn] += this.estimatedHeight;
  
    return item;
  }

  // 更新实际高度
  updateHeight(index: number, height: number) {
    const item = this.cache[index];
    const delta = height - item.height;
  
    item.height = height;
    this.columnHeights[item.column] += delta;
  
    // 修正后续所有项的位置
    for (let i = index + 1; i < this.cache.length; i++) {
      if (this.cache[i].column === item.column) {
        this.cache[i].top += delta;
      }
    }
  }

  // 获取滚动容器总高度
  getTotalHeight(): number {
    return Math.max(...this.columnHeights);
  }

  // 获取可见范围项
  getVisibleRange(containerHeight: number, scrollTop: number): { start: number; end: number } {
    const buffer = containerHeight * 0.5; // 缓冲区域
    const startPos = scrollTop - buffer;
    const endPos = scrollTop + containerHeight + buffer;
  
    let start = 0;
    let end = this.cache.length - 1;
  
    // 二分查找优化
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const item = this.cache[mid];
      const itemBottom = item.top + item.height;
    
      if (itemBottom < startPos) {
        start = mid + 1;
      } else if (item.top > endPos) {
        end = mid - 1;
      } else {
        break;
      }
    }
  
    return {
      start: Math.max(0, start - 5), // 额外缓冲
      end: Math.min(this.cache.length - 1, end + 5)
    };
  }
}
```

### 2. 虚拟滚动组件实现（React示例）

```tsx
import React, { useState, useEffect, useRef, useCallback } from 'react';

interface WaterfallItem {
  id: string;
  imageUrl: string;
  title: string;
  // 其他属性...
}

interface WaterfallProps {
  items: WaterfallItem[];
  renderItem: (item: WaterfallItem, measureRef: React.Ref<HTMLDivElement>) => React.ReactNode;
  estimatedHeight?: number;
  bufferSize?: number;
}

const WaterfallVirtualScroll: React.FC<WaterfallProps> = ({
  items,
  renderItem,
  estimatedHeight = 200,
  bufferSize = 300
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const positionCache = useRef(new PositionCache());
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 20 });
  const [totalHeight, setTotalHeight] = useState(0);
  const itemRefs = useRef<Map<string, HTMLDivElement>>(new Map());

  // 初始化位置缓存
  useEffect(() => {
    positionCache.current = new PositionCache();
    positionCache.current.estimatedHeight = estimatedHeight;
  
    items.forEach(() => {
      positionCache.current.addItem();
    });
  
    setTotalHeight(positionCache.current.getTotalHeight());
    updateVisibleRange();
  }, [items, estimatedHeight]);

  // 更新可见范围
  const updateVisibleRange = useCallback(() => {
    if (!containerRef.current) return;
  
    const containerHeight = containerRef.current.clientHeight;
    const scrollTop = containerRef.current.scrollTop;
  
    const range = positionCache.current.getVisibleRange(containerHeight, scrollTop);
    setVisibleRange(range);
  }, []);

  // 处理滚动
  const handleScroll = useCallback(() => {
    updateVisibleRange();
  
    // 检查是否需要加载更多
    const { scrollTop, scrollHeight, clientHeight } = containerRef.current!;
    if (scrollHeight - (scrollTop + clientHeight) < 300) {
      // 触发加载更多逻辑...
    }
  }, [updateVisibleRange]);

  // 测量并更新实际高度
  const measureItems = useCallback(() => {
    let hasUpdate = false;
  
    itemRefs.current.forEach((element, id) => {
      const index = items.findIndex(item => item.id === id);
      if (index === -1) return;
    
      const height = element.getBoundingClientRect().height;
      const cachedItem = positionCache.current.cache[index];
    
      if (Math.abs(height - cachedItem.height) > 5) { // 阈值避免频繁更新
        positionCache.current.updateHeight(index, height);
        hasUpdate = true;
      }
    });
  
    if (hasUpdate) {
      setTotalHeight(positionCache.current.getTotalHeight());
      updateVisibleRange();
    }
  }, [items, updateVisibleRange]);

  // 使用ResizeObserver监听高度变化
  useEffect(() => {
    const observer = new ResizeObserver((entries) => {
      measureItems();
    });
  
    itemRefs.current.forEach(element => {
      observer.observe(element);
    });
  
    return () => observer.disconnect();
  }, [measureItems]);

  // 渲染可见项
  const renderItems = () => {
    const visibleItems = [];
  
    for (let i = visibleRange.start; i <= visibleRange.end && i < items.length; i++) {
      const item = items[i];
      const position = positionCache.current.cache[i];
    
      visibleItems.push(
        <div
          key={item.id}
          ref={(el) => {
            if (el) itemRefs.current.set(item.id, el);
            else itemRefs.current.delete(item.id);
          }}
          style={{
            position: 'absolute',
            top: `${position.top}px`,
            left: position.column === 0 ? '0' : '50%',
            width: '50%',
            padding: '8px',
            boxSizing: 'border-box'
          }}
        >
          {renderItem(item, null)}
        </div>
      );
    }
  
    return visibleItems;
  };

  return (
    <div
      ref={containerRef}
      style={{
        height: '100vh',
        overflowY: 'auto',
        position: 'relative',
        willChange: 'transform'
      }}
      onScroll={handleScroll}
    >
      <div style={{ height: `${totalHeight}px`, position: 'relative' }}>
        {renderItems()}
      </div>
    </div>
  );
};

// 使用示例
const App = () => {
  const [items, setItems] = useState<WaterfallItem[]>(/* 初始数据 */);

  return (
    <WaterfallVirtualScroll
      items={items}
      estimatedHeight={250}
      renderItem={(item, measureRef) => (
        <div ref={measureRef} className="waterfall-card">
          <img 
            src={item.imageUrl} 
            alt="" 
            style={{ width: '100%', height: 'auto' }}
            onLoad={(e) => {
              // 图片加载完成后触发重新测量
              const img = e.target as HTMLImageElement;
              if (img.complete) {
                // 这里可以添加额外的测量逻辑
              }
            }}
          />
          <h3>{item.title}</h3>
          <p>动态内容...</p>
        </div>
      )}
    />
  );
};
```

## 三、关键优化技术

### 1. 图片加载优化

```tsx
// 在renderItem中处理图片加载
renderItem={(item, measureRef) => {
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const img = imgRef.current;
    if (!img) return;
  
    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        img.src = img.dataset.src || '';
        observer.unobserve(img);
      }
    }, { root: containerRef.current });
  
    observer.observe(img);
    return () => observer.unobserve(img);
  }, []);

  return (
    <div ref={measureRef}>
      <img 
        ref={imgRef}
        data-src={item.imageUrl}
        style={{ width: '100%', height: 'auto' }}
        onLoad={() => measureItems()}
      />
      {/* 其他内容 */}
    </div>
  );
}}
```

### 2. 滚动性能优化

```typescript
// 使用requestAnimationFrame优化滚动处理
const [scrollTop, setScrollTop] = useState(0);
const rafId = useRef<number>();

const handleScroll = () => {
  if (rafId.current) {
    cancelAnimationFrame(rafId.current);
  }

  rafId.current = requestAnimationFrame(() => {
    setScrollTop(containerRef.current?.scrollTop || 0);
    updateVisibleRange();
  });
};

// 在useEffect中清理
useEffect(() => {
  return () => {
    if (rafId.current) {
      cancelAnimationFrame(rafId.current);
    }
  };
}, []);
```

### 3. 动态高度预测算法

```typescript
// 基于历史数据的动态预测
class SmartHeightPredictor {
  private heightMap = new Map<string, number>(); // 按类型缓存高度
  private defaultHeight: number;

  constructor(defaultHeight = 200) {
    this.defaultHeight = defaultHeight;
  }

  predictHeight(item: WaterfallItem): number {
    // 根据内容特征生成类型键
    const typeKey = `${item.imageUrl ? 'with-image' : 'no-image'}-${item.title.length > 20 ? 'long-title' : 'short-title'}`;
  
    // 返回缓存高度或默认值
    return this.heightMap.get(typeKey) || this.defaultHeight;
  }

  recordHeight(item: WaterfallItem, actualHeight: number) {
    const typeKey = `${item.imageUrl ? 'with-image' : 'no-image'}-${item.title.length > 20 ? 'long-title' : 'short-title'}`;
  
    // 平滑更新（加权平均）
    const oldHeight = this.heightMap.get(typeKey) || this.defaultHeight;
    const newHeight = oldHeight * 0.7 + actualHeight * 0.3;
  
    this.heightMap.set(typeKey, newHeight);
  }
}

// 在PositionCache中使用
class PositionCache {
  private predictor = new SmartHeightPredictor();

  addItem(item: WaterfallItem, column?: number): PositionCacheItem {
    const predictedHeight = this.predictor.predictHeight(item);
    // ...其余逻辑相同
  }

  updateHeight(index: number, item: WaterfallItem, height: number) {
    this.predictor.recordHeight(item, height);
    // ...其余逻辑相同
  }
}
```

## 四、实际应用中的注意事项

1. **图片加载抖动问题**：
    - 使用CSS `aspect-ratio` 保持占位
    - 或使用固定比例的占位容器

2. **快速滚动时的空白处理**：
    - 增加缓冲区域大小
    - 显示加载中的占位符

3. **内存管理**：
   ```typescript
   // 清理不再可见的项引用
   useEffect(() => {
     return () => {
       itemRefs.current.forEach((_, id) => {
         if (!visibleItems.some(item => item.id === id)) {
           itemRefs.current.delete(id);
         }
       });
     };
   }, [visibleItems]);
   ```

4. **服务端渲染兼容**：
   ```typescript
   const useIsomorphicLayoutEffect = 
     typeof window !== 'undefined' ? useEffect : () => {};
   ```

## 五、完整CSS方案

```css
.waterfall-container {
  position: relative;
  height: 100vh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior-y: contain;
}

.waterfall-scroll-content {
  position: relative;
  will-change: transform;
}

.waterfall-card {
  background: white;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  margin-bottom: 16px;
}

.waterfall-card img {
  width: 100%;
  height: auto;
  display: block;
  background: #f5f5f5;
}

.waterfall-card h3 {
  margin: 12px;
  font-size: 16px;
  line-height: 1.4;
}

.waterfall-card p {
  margin: 0 12px 12px;
  color: #666;
  font-size: 14px;
}

/* 图片加载占位 */
.img-placeholder {
  aspect-ratio: 4/3;
  background: linear-gradient(110deg, #ececec 8%, #f5f5f5 18%, #ececec 33%);
  background-size: 200% 100%;
  animation: 1.5s shine linear infinite;
}

@keyframes shine {
  to {
    background-position-x: -200%;
  }
}
```

## 六、备选方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| 完整虚拟滚动 | 极致性能，大数据量 | 实现复杂 | 超长列表/严格性能要求 |
| 分页加载 | 实现简单 | 体验不连贯 | 中等数据量 |
| 仅虚拟列 | 折中方案 | 仍有性能瓶颈 | 列数固定场景 |
| 现成库(react-window等) | 快速集成 | 定制性差 | 标准瀑布流 |

对于大多数瀑布流场景，我推荐使用完整虚拟滚动方案，虽然实现复杂但能提供最佳用户体验。如果项目时间紧张，可以考虑基于`react-window`或`vue-virtual-scroller`等库进行二次开发。
