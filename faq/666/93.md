## 93. Webpack 项目中通过 script 标签引入资源，在项目中如何处理？

在 Webpack 项目中，通过 `<script>` 标签引入的资源（如第三方库、CDN 资源）通常需要特殊处理，以确保它们能正确集成到模块化系统中，并避免重复打包或全局污染。以下是完整的解决方案：

---

### **1. 直接引入资源的常见场景**
- 通过 CDN 加载的库（如 jQuery、Lodash）。
- 非模块化的遗留脚本。
- 需要全局可用的工具库（如 Google Analytics）。

---

### **2. 处理方式**

#### **(1) 在 HTML 中直接引入**
在 `public/index.html` 或模板文件中通过 `<script>` 标签引入资源：
```html
<!-- 通过 CDN 引入 jQuery -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
```

**问题**：Webpack 不知道这些资源的存在，可能导致：
- 重复打包（如果项目中同时 `npm install` 了该库）。
- 类型丢失（TypeScript 项目）。

---

#### **(2) 配置 `externals`（推荐）**
在 `webpack.config.js` 中声明外部依赖，告诉 Webpack 这些资源由外部提供，无需打包：
```javascript
module.exports = {
  externals: {
    jquery: 'jQuery', // key 是包名，value 是全局变量名
    lodash: '_',
  },
};
```

**作用**：
- 避免重复打包。
- 代码中仍可通过 `import $ from 'jquery'` 使用，实际运行时从全局变量 `window.jQuery` 获取。

---

#### **(3) 类型声明（TypeScript 项目）**
为通过 `<script>` 引入的库添加类型声明文件（`.d.ts`）：
```typescript
// src/global.d.ts
declare module 'jquery' {
  const $: typeof import('jquery');
  export = $;
}
```

**作用**：解决 TypeScript 的 `Cannot find module 'jquery'` 报错。

---

#### **(4) 动态加载非模块化脚本**
通过 JavaScript 动态插入 `<script>` 标签，并监听加载完成事件：
```javascript
function loadScript(url: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = url;
    script.onload = () => resolve();
    script.onerror = reject;
    document.body.appendChild(script);
  });
}

// 使用示例
loadScript('https://example.com/non-module.js')
  .then(() => {
    console.log('脚本加载完成！');
  });
```

**适用场景**：非关键脚本或按需加载的第三方资源。

---

#### **(5) 使用 `html-webpack-plugin` 自动注入**
通过 `html-webpack-plugin` 的 `script` 配置自动插入 `<script>` 标签：
```javascript
// webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      scriptLoading: 'defer',
      scripts: [
        {
          src: 'https://cdn.example.com/library.js',
          attributes: { async: true },
        },
      ],
    }),
  ],
};
```

**作用**：结合 Webpack 构建流程，灵活控制脚本加载行为。

---

#### **(6) 通过 `imports-loader` 适配非模块化库**
如果库依赖全局变量（如 `this` 指向 `window`），使用 `imports-loader` 强制适配：
```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: require.resolve('legacy-library'),
        use: 'imports-loader?wrapper=window',
      },
    ],
  },
};
```

**适用场景**：老式库（如直接修改 `window` 的脚本）。

---

### **3. 避免的问题**
1. **重复打包**：确保 `externals` 和 CDN 引入的库版本一致。
2. **全局污染**：避免滥用 `window.xxx`，尽量封装为模块。
3. **加载顺序**：依赖其他脚本的库需按顺序加载（如先 jQuery 再插件）。

---

### **4. 完整示例**
#### **步骤 1：HTML 引入 CDN 资源**
```html
<!-- public/index.html -->
<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
```

#### **步骤 2：配置 Webpack**
```javascript
// webpack.config.js
module.exports = {
  externals: {
    lodash: '_', // 映射到全局变量 _
  },
};
```

#### **步骤 3：代码中使用**
```typescript
// src/app.ts
import _ from 'lodash'; // 实际从 window._ 获取

console.log(_.VERSION); // 输出 Lodash 版本
```

#### **步骤 4：类型声明（可选）**
```typescript
// src/global.d.ts
declare module 'lodash' {
  const _: typeof import('lodash');
  export = _;
}
```

---

### **5. 工具推荐**
- **`webpack-bundle-analyzer`**：分析打包内容，检查是否意外打包了外部资源。
- **`script-ext-html-webpack-plugin`**：更精细地控制 `<script>` 标签属性。

---

### **总结**
| **场景**               | **解决方案**                  | **优点**                     |
|------------------------|-----------------------------|-----------------------------|
| CDN 引入库            | `externals` + HTML `<script>` | 避免重复打包                |
| 非模块化脚本          | 动态加载或 `imports-loader`   | 兼容老旧代码                |
| TypeScript 支持       | 声明全局类型（`.d.ts`）       | 类型安全                    |
| 按需加载              | `loadScript` + Promise       | 减少首屏负载                |

通过合理组合这些方法，可以高效管理通过 `<script>` 引入的资源，兼顾性能和可维护性！ 🛠️