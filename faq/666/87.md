## 87. 如何一次性渲染十万条数据还能保证页面不卡顿

渲染大量数据（如十万条）时，直接操作 DOM 会导致页面卡顿甚至崩溃。以下是几种优化方案，确保高性能渲染：

---

## **1. 虚拟滚动（Virtual Scrolling）**
### **原理**
只渲染当前视口可见的数据，动态替换不可见区域的内容，减少 DOM 节点数量。

### **实现方式**
- 使用现成库（推荐）：
    - [React](https://reactjs.org/): `react-window` 或 `react-virtualized`
    - [Vue](https://vuejs.org/): `vue-virtual-scroller`
    - 原生 JS: `IntersectionObserver` + 动态渲染

### **代码示例（React + react-window）**
```typescript
import { FixedSizeList as List } from 'react-window';

const BigList = () => {
  const data = Array(100000).fill().map((_, i) => `Item ${i + 1}`);

  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>{data[index]}</div>
  );

  return (
    <List
      height={600}    // 列表可视高度
      itemCount={data.length}
      itemSize={50}   // 每项高度
      width="100%"
    >
      {Row}
    </List>
  );
};
```

### **优点**
- 内存占用极低（仅渲染几十个 DOM 节点）。
- 滚动流畅，无卡顿。

---

## **2. 分页加载（Pagination）**
### **原理**
将数据分页，用户滚动或点击时加载下一页。

### **实现方式**
- 前端分页：一次性加载数据，但按页显示。
- 后端分页：每次请求一页数据（推荐大数据量场景）。

### **代码示例（前端分页）**
```typescript
const PaginatedList = () => {
  const [page, setPage] = useState(1);
  const itemsPerPage = 50;
  const data = Array(100000).fill().map((_, i) => `Item ${i + 1}`);

  const paginatedData = data.slice(
    (page - 1) * itemsPerPage,
    page * itemsPerPage
  );

  return (
    <div>
      {paginatedData.map((item) => (
        <div key={item}>{item}</div>
      ))}
      <button onClick={() => setPage(page + 1)}>Load More</button>
    </div>
  );
};
```

### **优点**
- 实现简单。
- 适合用户主动触发的场景。

---

## **3. 时间切片（Time Slicing）**
### **原理**
将渲染任务拆分为多个小任务，通过 `requestIdleCallback` 或 `setTimeout` 分批执行，避免阻塞主线程。

### **代码示例**
```typescript
const renderChunk = (data: string[], start: number, end: number) => {
  const fragment = document.createDocumentFragment();
  for (let i = start; i < end; i++) {
    const div = document.createElement('div');
    div.textContent = data[i];
    fragment.appendChild(div);
  }
  document.body.appendChild(fragment);

  if (end < data.length) {
    requestIdleCallback(() => renderChunk(data, end, Math.min(end + 100, data.length)));
  }
};

// 初始化渲染
const data = Array(100000).fill().map((_, i) => `Item ${i + 1}`);
renderChunk(data, 0, 100);
```

### **优点**
- 避免长时间占用主线程。
- 兼容性较好。

---

## **4. Web Worker 后台处理**
### **原理**
将数据处理逻辑（如排序、过滤）放到 Web Worker 中执行，不阻塞 UI 线程。

### **代码示例**
#### **Worker 脚本（worker.js）**
```javascript
self.onmessage = (e) => {
  const data = e.data;
  // 模拟耗时操作
  const processedData = data.map((item, i) => `Processed ${i}`);
  postMessage(processedData);
};
```

#### **主线程**
```typescript
const worker = new Worker('worker.js');
worker.postMessage(Array(100000).fill());

worker.onmessage = (e) => {
  const processedData = e.data;
  // 渲染处理后的数据（结合虚拟滚动或分页）
};
```

### **优点**
- 彻底解放主线程。
- 适合复杂数据处理。

---

## **5. 优化 DOM 操作**
### **关键技巧**
- **文档片段（DocumentFragment）**：减少多次 DOM 操作。
  ```typescript
  const fragment = document.createDocumentFragment();
  data.forEach(item => {
    const div = document.createElement('div');
    div.textContent = item;
    fragment.appendChild(div);
  });
  document.body.appendChild(fragment);
  ```
- **避免内联样式**：使用 CSS 类替代。
- **减少布局抖动**：批量读取/修改 DOM 属性。

---

## **6. 性能对比**
| **方案**          | **适用场景**               | **内存占用** | **实现复杂度** |
|-------------------|--------------------------|-------------|--------------|
| 虚拟滚动          | 长列表实时滚动            | 极低        | 中           |
| 分页加载          | 用户主动触发加载          | 低          | 低           |
| 时间切片          | 兼容性要求高              | 中          | 中           |
| Web Worker        | 复杂数据处理              | 高          | 高           |

---

## **总结**
1. **首选虚拟滚动**：适用于需要流畅滚动的长列表（如聊天记录、表格）。
2. **分页加载**：适合用户主动操作的场景（如商品列表）。
3. **时间切片/Worker**：作为补充方案，处理特殊需求。

通过合理选择方案，即使渲染十万条数据也能保证页面流畅！ 🚀