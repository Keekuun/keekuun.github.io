## 32. 如何解决页面请求接口大规模并发问题 - 前端批量请求接口

> 将多个小请求合并为批量请求 - 后端批量处理接口

以下是结合NestJS实现完整批量请求处理的解决方案，包含前端TypeScript调用和后端NestJS实现：

### 一、前端增强版批量请求（TypeScript）

```typescript
// src/utils/batch-request.ts
import axios, { AxiosRequestConfig } from 'axios';

interface BatchRequestItem extends AxiosRequestConfig {
  requestId?: string; // 唯一标识每个子请求
}

interface BatchResponse<T = any> {
  [requestId: string]: {
    status: number;
    data?: T;
    error?: {
      message: string;
      code?: number;
    };
  };
}

export async function batchRequests(
  requests: BatchRequestItem[],
  options?: {
    timeout?: number;
    batchEndpoint?: string;
  }
): Promise<BatchResponse> {
  const { timeout = 8000, batchEndpoint = '/api/batch' } = options || {};

  try {
    // 为每个请求生成唯一ID（如果未提供）
    const normalizedRequests = requests.map(req => ({
      requestId: req.requestId || `req_${Math.random().toString(36).substr(2, 9)}`,
      ...req
    }));

    const source = axios.CancelToken.source();
    const timer = setTimeout(() => {
      source.cancel('Batch request timeout');
    }, timeout);

    const response = await axios.post(batchEndpoint, {
      requests: normalizedRequests
    }, {
      cancelToken: source.token,
      headers: {
        'Content-Type': 'application/json',
        'X-Batch-Request': 'true'
      }
    });

    clearTimeout(timer);
    return response.data.results;
  } catch (error) {
    if (axios.isCancel(error)) {
      console.error('Batch request canceled:', error.message);
      throw new Error(`Request timeout after ${timeout}ms`);
    }
    throw error;
  }
}
```

### 二、NestJS后端实现

#### 1. 创建批量请求DTO

```typescript
// src/batch/dto/batch-request.dto.ts
import { IsArray, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';

class SingleRequestDto {
  requestId: string;

  url: string;

  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

  params?: Record<string, any>;

  data?: any;

  headers?: Record<string, string>;
}

export class BatchRequestDto {
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => SingleRequestDto)
  requests: SingleRequestDto[];
}
```

#### 2. 实现批量处理服务

```typescript
// src/batch/batch.service.ts
import { Injectable } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';
import { AxiosResponse } from 'axios';

@Injectable()
export class BatchService {
  constructor(private readonly httpService: HttpService) {}

  async processBatch(batchDto: BatchRequestDto) {
    const results = {};
    const promises = batchDto.requests.map(async (req) => {
      try {
        const response = await firstValueFrom(
          this.httpService.request({
            url: req.url,
            method: req.method,
            data: req.data,
            params: req.params,
            headers: req.headers
          })
        );
      
        results[req.requestId] = {
          status: response.status,
          data: response.data
        };
      } catch (error) {
        results[req.requestId] = {
          status: error.response?.status || 500,
          error: {
            message: error.message,
            code: error.code
          }
        };
      }
    });

    await Promise.all(promises);
    return { results };
  }
}
```

#### 3. 创建批量请求控制器

```typescript
// src/batch/batch.controller.ts
import { Controller, Post, Body } from '@nestjs/common';
import { BatchService } from './batch.service';
import { BatchRequestDto } from './dto/batch-request.dto';

@Controller('api/batch')
export class BatchController {
  constructor(private readonly batchService: BatchService) {}

  @Post()
  async handleBatchRequest(@Body() batchDto: BatchRequestDto) {
    return this.batchService.processBatch(batchDto);
  }
}
```

#### 4. 添加速率限制（可选）

```typescript
// src/batch/batch.controller.ts
import { Throttle } from '@nestjs/throttler';

@Controller('api/batch')
@Throttle(100, 60) // 每分钟最多100次批量请求
export class BatchController {
  // ...原有代码
}
```

### 三、前后端协作流程

1. **请求流程**：
   ```mermaid
   sequenceDiagram
   前端->>+NestJS: POST /api/batch
   NestJS->>+内部路由: 并行发起子请求
   内部路由-->>-NestJS: 返回子响应
   NestJS-->>-前端: 聚合后响应
   ```

2. **错误处理机制**：
   - 单个子请求失败不影响其他请求
   - 每个响应包含原始requestId便于前端匹配

3. **性能优化建议**：
   ```typescript
   // 在BatchService中增加并发控制
   async processBatch(batchDto: BatchRequestDto) {
     const CONCURRENCY_LIMIT = 10;
     const results = {};
   
     // 使用p-limit库控制并发
     const limit = require('p-limit')(CONCURRENCY_LIMIT);
   
     const promises = batchDto.requests.map(req => 
       limit(() => this.processSingleRequest(req, results))
     );
   
     await Promise.all(promises);
     return { results };
   }
   ```

### 四、安全增强措施

1. **白名单验证**：
```typescript
// src/batch/batch.service.ts
private readonly ALLOWED_ENDPOINTS = [
  '/api/users',
  '/api/products'
];

private validateRequestUrl(url: string) {
  if (!this.ALLOWED_ENDPOINTS.some(allowed => url.startsWith(allowed))) {
    throw new Error(`Disallowed endpoint: ${url}`);
  }
}
```

2. **深度限制**：
```typescript
// src/main.ts
app.use(express.json({ limit: '10kb' })); // 防止超大JSON攻击
```

### 五、测试用例示例

```typescript
// test/batch.e2e-spec.ts
describe('Batch API', () => {
  it('should process batch requests', async () => {
    const testRequests = [
      {
        requestId: 'get_user',
        url: '/api/users/1',
        method: 'GET'
      },
      {
        requestId: 'create_product',
        url: '/api/products',
        method: 'POST',
        data: { name: 'Test Product' }
      }
    ];

    const response = await request(app.getHttpServer())
      .post('/api/batch')
      .send({ requests: testRequests })
      .expect(200);

    expect(response.body.results.get_user.status).toEqual(200);
    expect(response.body.results.create_product.status).toEqual(201);
  });
});
```

### 六、部署建议

1. **负载均衡配置**：
   ```nginx
   location /api/batch {
     client_max_body_size 10k;
     proxy_pass http://nestjs_backend;
     proxy_read_timeout 15s;
   }
   ```

2. **监控指标**：
   ```typescript
   // 在BatchService中添加监控
   import { Counter } from 'prom-client';

   const batchCounter = new Counter({
     name: 'batch_requests_total',
     help: 'Total batch API requests',
     labelNames: ['status']
   });

   // 在处理完成后记录
   batchCounter.inc({ status: 'success' });
   ```

这套实现方案提供了：
- 完整的前后端TypeScript类型安全
- 可扩展的批量处理架构
- 完善的错误隔离机制
- 生产环境级别的安全防护
- 性能优化建议

根据实际业务需求，可以调整并发控制策略、白名单规则和监控指标。
