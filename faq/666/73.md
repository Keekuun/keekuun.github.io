## 73. documentFragment api 是什么，有哪些使用场景？

`DocumentFragment` 是 DOM 中的一个轻量级容器，用于 **批量操作 DOM 节点** 而不直接触发重排（Reflow）或重绘（Repaint）。它可以显著提升性能，尤其是在需要频繁操作 DOM 的场景中。

---

## **1. 核心概念**
- **本质**：是一个虚拟的文档片段，不属于主 DOM 树。
- **特点**：
    - 在内存中操作节点，不会触发页面渲染。
    - 批量插入时只需一次重排（相比逐个插入节点）。
- **生命周期**：节点插入主 DOM 后，`DocumentFragment` 会自动清空。

---

## **2. 基本用法**
```typescript
// 创建 DocumentFragment
const fragment = document.createDocumentFragment();

// 添加多个节点到 Fragment
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div); // 不会触发重排
}

// 一次性插入主 DOM
document.getElementById('container')!.appendChild(fragment); // 仅一次重排
```

---

## **3. 使用场景**
### **(1) 批量插入大量 DOM 节点**
```typescript
// 低效写法：每次插入都触发重排
for (let i = 0; i < 1000; i++) {
  document.body.appendChild(createElement()); // 1000 次重排！
}

// 高效写法：通过 DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  fragment.appendChild(createElement());
}
document.body.appendChild(fragment); // 仅 1 次重排
```

### **(2) 动态渲染列表**
```typescript
function renderList(items: string[]) {
  const fragment = document.createDocumentFragment();
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
  });
  document.getElementById('list')!.appendChild(fragment);
}
```

### **(3) 克隆或移动 DOM 子树**
```typescript
const sourceElement = document.getElementById('source')!;
const fragment = document.createDocumentFragment();

// 移动子树到 Fragment
while (sourceElement.firstChild) {
  fragment.appendChild(sourceElement.firstChild);
}

// 插入到新位置
document.getElementById('target')!.appendChild(fragment);
```

### **(4) 模板渲染（配合 `<template>` 标签）**
```html
<template id="tpl">
  <div class="item">Template Content</div>
</template>

<script>
  const template = document.getElementById('tpl')!;
  const fragment = template.content.cloneNode(true); // 克隆模板内容
  document.body.appendChild(fragment);
</script>
```

---

## **4. 性能对比**
| **操作方式**          | **重排次数** | **适用场景**               |
|-----------------------|-------------|---------------------------|
| 直接插入 DOM          | N 次        | 少量节点操作               |
| `DocumentFragment`    | 1 次        | 批量节点操作（推荐）        |

---

## **5. 注意事项**
1. **内存管理**：`DocumentFragment` 在插入主 DOM 后会清空，无需手动释放内存。
2. **事件委托**：由于 Fragment 不在 DOM 树中，需在主 DOM 上监听事件（或插入后再绑定）。
3. **兼容性**：所有现代浏览器均支持，包括 IE 9+。

---

## **6. 与其他技术的结合**
### **(1) 配合 `requestAnimationFrame`**
```typescript
const fragment = document.createDocumentFragment();
// 在动画帧中批量操作
requestAnimationFrame(() => {
  document.body.appendChild(fragment);
});
```

### **(2) 虚拟 DOM 的底层实现**
- 类似 React/Vue 的虚拟 DOM 机制，先在内存中构建节点树，再一次性更新到真实 DOM。

---

## **7. 总结**
- **优势**：减少重排次数，提升性能，尤其适合动态渲染、列表更新等场景。
- **原则**：**“先组装，再插入”**，避免频繁操作主 DOM 树。
- **类比**：可以将其视为 DOM 操作的“缓冲区”。

合理使用 `DocumentFragment`，能让你的应用更流畅！ 🚀