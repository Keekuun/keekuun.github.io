## 38. 常见图片懒加载方式有哪些？

# 图片懒加载实现方案大全

图片懒加载是优化网页性能的重要技术，以下是各种实现方式的详细解析和代码示例：

## 一、原生JavaScript实现方案

### 1. Intersection Observer API（现代浏览器推荐）
```javascript
document.addEventListener('DOMContentLoaded', () => {
  const lazyImages = document.querySelectorAll('img[data-src]');

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.removeAttribute('data-src');
        observer.unobserve(img);
      }
    });
  }, {
    rootMargin: '100px 0px', // 提前100px加载
    threshold: 0.01
  });

  lazyImages.forEach(img => observer.observe(img));
});
```

### 2. 滚动事件监听（兼容旧浏览器）
```javascript
function lazyLoad() {
  const lazyImages = document.querySelectorAll('img[data-src]');

  lazyImages.forEach(img => {
    if (isInViewport(img)) {
      img.src = img.dataset.src;
      img.removeAttribute('data-src');
    }
  });

  if (!lazyImages.length) {
    window.removeEventListener('scroll', lazyLoad);
    window.removeEventListener('resize', lazyLoad);
  }
}

function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  return (
    rect.bottom >= 0 &&
    rect.right >= 0 &&
    rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.left <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

window.addEventListener('scroll', lazyLoad);
window.addEventListener('resize', lazyLoad);
document.addEventListener('DOMContentLoaded', lazyLoad);
```

## 二、HTML原生属性方案

### 1. loading="lazy"（浏览器原生支持）
```html
<img src="image.jpg" loading="lazy" alt="示例图片">
```

### 2. 结合srcset和sizes
```html
<img
  data-srcset="small.jpg 480w, medium.jpg 1024w, large.jpg 1920w"
  data-sizes="(max-width: 600px) 480px, 1024px"
  alt="响应式图片"
  class="lazyload">
```

## 三、CSS背景图懒加载

### 1. 使用Intersection Observer
```javascript
const lazyBackgrounds = document.querySelectorAll('.lazy-bg');

const bgObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.style.backgroundImage = `url(${entry.target.dataset.bg})`;
      bgObserver.unobserve(entry.target);
    }
  });
}, {threshold: 0.1});

lazyBackgrounds.forEach(bg => bgObserver.observe(bg));
```

```html
<div class="lazy-bg" data-bg="background.jpg"></div>
```

### 2. CSS类切换方案
```css
.lazy-bg {
  background-color: #f5f5f5;
  transition: background-image 0.3s ease;
}

.lazy-bg.loaded {
  background-image: url('background.jpg');
}
```

```javascript
document.querySelectorAll('.lazy-bg').forEach(el => {
  if (isInViewport(el)) {
    el.classList.add('loaded');
  }
});
```

## 四、React实现方案

### 1. 自定义Hook实现
```jsx
import { useEffect, useRef, useState } from 'react';

function useLazyLoad() {
  const [isVisible, setIsVisible] = useState(false);
  const ref = useRef();

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.unobserve(ref.current);
        }
      },
      { rootMargin: '100px' }
    );

    if (ref.current) {
      observer.observe(ref.current);
    }

    return () => {
      if (ref.current) {
        observer.unobserve(ref.current);
      }
    };
  }, []);

  return [ref, isVisible];
}

function LazyImage({ src, alt, placeholder, ...props }) {
  const [ref, isVisible] = useLazyLoad();

  return (
    <img
      ref={ref}
      src={isVisible ? src : placeholder}
      alt={alt}
      {...props}
    />
  );
}
```

### 2. 第三方库react-lazyload
```jsx
import LazyLoad from 'react-lazyload';

function MyComponent() {
  return (
    <div>
      <LazyLoad height={200} offset={100}>
        <img src="real-image.jpg" alt="示例" />
      </LazyLoad>
    </div>
  );
}
```

## 五、Vue实现方案

### 1. 自定义指令
```javascript
// main.js
Vue.directive('lazy', {
  inserted: (el, binding) => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          el.src = binding.value;
          observer.unobserve(el);
        }
      });
    }, { threshold: 0.01 });
  
    observer.observe(el);
  }
});
```

```html
<!-- 使用方式 -->
<img v-lazy="'image.jpg'" alt="示例">
```

### 2. 使用vue-lazyload插件
```javascript
import VueLazyload from 'vue-lazyload';

Vue.use(VueLazyload, {
  preLoad: 1.3,
  error: 'error-image.png',
  loading: 'loading-spinner.gif',
  attempt: 1
});
```

```html
<img v-lazy="'image.jpg'" alt="示例">
```

## 六、高级优化技巧

### 1. 低质量图片占位符(LQIP)
```html
<img
  src="image-low-quality.jpg"
  data-src="image-high-quality.jpg"
  class="lazyload"
  alt="LQIP示例"
>
```

### 2. 模糊图片到清晰过渡
```css
.lazyload {
  filter: blur(5px);
  transition: filter 0.3s ease;
}

.lazyloaded {
  filter: blur(0);
}
```

### 3. 渐进式JPEG加载
```javascript
// 使用渐进式JPEG结合懒加载
function loadProgressiveImage(img) {
  const smallSrc = img.dataset.small;
  const largeSrc = img.dataset.large;

  // 先加载小图
  img.src = smallSrc;

  // 当大图加载完成后替换
  const largeImage = new Image();
  largeImage.src = largeSrc;
  largeImage.onload = () => {
    img.src = largeSrc;
  };
}
```

## 七、性能对比分析

| 实现方式 | 优点 | 缺点 | 适用场景 |
|----------|------|------|----------|
| Intersection Observer | 高性能，不阻塞主线程 | 兼容性需polyfill | 现代浏览器项目 |
| 滚动监听 | 兼容性好 | 性能较差 | 需要支持旧浏览器的项目 |
| loading="lazy" | 最简单 | 兼容性有限 | 现代浏览器简单项目 |
| React/Vue组件 | 框架集成度高 | 增加包体积 | 对应框架项目 |

## 八、完整最佳实践示例

```html
<!DOCTYPE html>
<html>
<head>
<style>
  .lazyload {
    opacity: 0;
    transition: opacity 0.3s;
    background: #f5f5f5;
  }

  .lazyloaded {
    opacity: 1;
  }

  .lazy-bg {
    height: 400px;
    background-size: cover;
    background-position: center;
  }
</style>
</head>
<body>
  <!-- 普通图片懒加载 -->
  <img 
    data-src="real-image.jpg" 
    src="placeholder.jpg" 
    class="lazyload" 
    alt="示例图片"
    width="800"
    height="600">

  <!-- 背景图懒加载 -->
  <div 
    class="lazy-bg lazyload" 
    data-bg="background-image.jpg">
  </div>

  <!-- 响应式图片懒加载 -->
  <img
    class="lazyload"
    data-srcset="small.jpg 480w, medium.jpg 1024w, large.jpg 1920w"
    data-sizes="(max-width: 600px) 480px, 1024px"
    alt="响应式图片"
    src="placeholder.jpg">

<script>
document.addEventListener('DOMContentLoaded', function() {
  // 图片懒加载
  const lazyImages = [].slice.call(document.querySelectorAll('img.lazyload'));
  const lazyBackgrounds = [].slice.call(document.querySelectorAll('.lazy-bg.lazyload'));

  if ('IntersectionObserver' in window) {
    // 现代浏览器实现
    const imageObserver = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          const img = entry.target;
          if (img.dataset.src) {
            img.src = img.dataset.src;
          }
          if (img.dataset.srcset) {
            img.srcset = img.dataset.srcset;
          }
          img.classList.add('lazyloaded');
          imageObserver.unobserve(img);
        }
      });
    }, {
      rootMargin: '200px 0px'
    });
  
    const bgObserver = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          const bg = entry.target;
          bg.style.backgroundImage = `url(${bg.dataset.bg})`;
          bg.classList.add('lazyloaded');
          bgObserver.unobserve(bg);
        }
      });
    });
  
    lazyImages.forEach(function(img) {
      imageObserver.observe(img);
    });
  
    lazyBackgrounds.forEach(function(bg) {
      bgObserver.observe(bg);
    });
  } else {
    // 旧浏览器回退方案
    let active = false;
  
    const lazyLoad = function() {
      if (active === false) {
        active = true;
      
        setTimeout(function() {
          lazyImages.forEach(function(img) {
            if (isInViewport(img)) {
              if (img.dataset.src) {
                img.src = img.dataset.src;
              }
              if (img.dataset.srcset) {
                img.srcset = img.dataset.srcset;
              }
              img.classList.add('lazyloaded');
            
              lazyImages = lazyImages.filter(function(i) {
                return i !== img;
              });
            }
          });
        
          lazyBackgrounds.forEach(function(bg) {
            if (isInViewport(bg)) {
              bg.style.backgroundImage = `url(${bg.dataset.bg})`;
              bg.classList.add('lazyloaded');
            
              lazyBackgrounds = lazyBackgrounds.filter(function(b) {
                return b !== bg;
              });
            }
          });
        
          active = false;
        }, 200);
      }
    };
  
    window.addEventListener('scroll', lazyLoad);
    window.addEventListener('resize', lazyLoad);
    window.addEventListener('orientationchange', lazyLoad);
  }

  function isInViewport(element) {
    const rect = element.getBoundingClientRect();
    return (
      rect.bottom >= 0 &&
      rect.right >= 0 &&
      rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
      rect.left <= (window.innerWidth || document.documentElement.clientWidth)
    );
  }
});
</script>
</body>
</html>
```

## 九、注意事项

1. **SEO优化**：确保懒加载图片有正确的alt属性
2. **占位策略**：使用适当尺寸的占位图避免布局偏移
3. **错误处理**：添加onerror回调处理图片加载失败
4. **打印支持**：确保打印时所有图片都能正常加载
5. **禁用情况**：对关键首屏图片禁用懒加载

选择适合您项目的懒加载方案，可以显著提高页面加载性能，特别是在包含大量图片的网页中。现代浏览器推荐使用Intersection Observer API实现，对于需要支持旧浏览器的项目，可以使用滚动事件监听的回退方案。
