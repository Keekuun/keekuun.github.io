## 50. 移动端如何实现上拉加载，下拉刷新？

# 移动端上拉加载与下拉刷新实现指南

## 一、基础实现原理

### 1. 核心手势识别
```typescript
// 触摸事件处理基础类
class TouchHandler {
  private startY = 0;
  private currentY = 0;

  constructor(private container: HTMLElement) {
    this.initEvents();
  }

  private initEvents() {
    this.container.addEventListener('touchstart', this.handleStart.bind(this), { passive: true });
    this.container.addEventListener('touchmove', this.handleMove.bind(this), { passive: false });
    this.container.addEventListener('touchend', this.handleEnd.bind(this));
  }

  private handleStart(e: TouchEvent) {
    this.startY = e.touches[0].clientY;
  }

  private handleMove(e: TouchEvent) {
    this.currentY = e.touches[0].clientY;
    const distance = this.currentY - this.startY;
  
    // 阻止原生滚动（下拉刷新时）
    if (distance > 0 && this.container.scrollTop === 0) {
      e.preventDefault();
    }
  }

  private handleEnd() {
    // 手势结束处理
  }
}
```

### 2. 滚动位置计算
```typescript
function checkScrollPosition(container: HTMLElement) {
  const { scrollTop, scrollHeight, clientHeight } = container;

  // 上拉加载阈值（距离底部50px）
  const isNearBottom = scrollHeight - (scrollTop + clientHeight) < 50;

  // 下拉刷新阈值（超过顶部80px）
  const isPastTop = scrollTop < -80;

  return { isNearBottom, isPastTop };
}
```

## 二、下拉刷新实现方案

### 1. 完整原生实现
```typescript
class PullToRefresh {
  private refreshElement: HTMLElement;
  private isLoading = false;
  private startY = 0;
  private currentY = 0;

  constructor(private container: HTMLElement) {
    this.refreshElement = this.createRefreshUI();
    container.insertBefore(this.refreshElement, container.firstChild);
    this.setupEvents();
  }

  private createRefreshUI(): HTMLElement {
    const el = document.createElement('div');
    el.className = 'refresh-indicator';
    el.innerHTML = `
      <div class="refresh-icon">↓</div>
      <div class="refresh-text">下拉刷新</div>
    `;
    return el;
  }

  private setupEvents() {
    this.container.addEventListener('touchstart', this.handleStart.bind(this));
    this.container.addEventListener('touchmove', this.handleMove.bind(this));
    this.container.addEventListener('touchend', this.handleEnd.bind(this));
  }

  private handleStart(e: TouchEvent) {
    if (this.container.scrollTop === 0) {
      this.startY = e.touches[0].clientY;
    }
  }

  private handleMove(e: TouchEvent) {
    if (!this.startY) return;
  
    this.currentY = e.touches[0].clientY;
    const distance = this.currentY - this.startY;
  
    if (distance > 0) {
      e.preventDefault();
      this.updateRefreshUI(distance);
    }
  }

  private updateRefreshUI(distance: number) {
    const maxDistance = 120;
    const progress = Math.min(distance / maxDistance, 1);
  
    // 更新UI状态
    const icon = this.refreshElement.querySelector('.refresh-icon')!;
    const text = this.refreshElement.querySelector('.refresh-text')!;
  
    if (progress >= 1) {
      icon.textContent = '↻';
      text.textContent = '释放刷新';
    } else {
      icon.textContent = '↓';
      text.textContent = '下拉刷新';
    }
  
    // 应用动画效果
    this.refreshElement.style.transform = `translateY(${distance}px)`;
  }

  private handleEnd() {
    if (!this.startY) return;
  
    const distance = this.currentY - this.startY;
    if (distance >= 120 && !this.isLoading) {
      this.triggerRefresh();
    } else {
      this.resetRefreshUI();
    }
  
    this.startY = 0;
    this.currentY = 0;
  }

  private async triggerRefresh() {
    this.isLoading = true;
    this.refreshElement.querySelector('.refresh-text')!.textContent = '刷新中...';
  
    try {
      await this.onRefresh(); // 实际刷新逻辑
    } finally {
      this.resetRefreshUI();
      this.isLoading = false;
    }
  }

  private resetRefreshUI() {
    this.refreshElement.style.transform = 'translateY(0)';
    this.refreshElement.style.transition = 'transform 0.3s ease';
  
    setTimeout(() => {
      this.refreshElement.style.transition = '';
    }, 300);
  }

  protected onRefresh(): Promise<void> {
    // 由子类实现具体刷新逻辑
    return Promise.resolve();
  }
}
```

## 三、上拉加载实现方案

### 1. IntersectionObserver实现
```typescript
class InfiniteLoader {
  private loading = false;
  private observer: IntersectionObserver;
  private sentinel: HTMLElement;

  constructor(private container: HTMLElement) {
    this.sentinel = this.createSentinel();
    container.appendChild(this.sentinel);
  
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      { root: container, threshold: 0.1 }
    );
    this.observer.observe(this.sentinel);
  }

  private createSentinel(): HTMLElement {
    const el = document.createElement('div');
    el.className = 'load-more-sentinel';
    el.style.height = '1px';
    return el;
  }

  private handleIntersection(entries: IntersectionObserverEntry[]) {
    if (entries[0].isIntersecting && !this.loading) {
      this.loadMore();
    }
  }

  private async loadMore() {
    this.loading = true;
    this.showLoadingIndicator();
  
    try {
      await this.onLoadMore();
    } finally {
      this.loading = false;
      this.hideLoadingIndicator();
    }
  }

  private showLoadingIndicator() {
    const loader = document.createElement('div');
    loader.className = 'loading-indicator';
    loader.textContent = '加载中...';
    this.container.insertBefore(loader, this.sentinel);
  }

  private hideLoadingIndicator() {
    const loader = this.container.querySelector('.loading-indicator');
    if (loader) {
      loader.remove();
    }
  }

  protected onLoadMore(): Promise<void> {
    // 由子类实现具体加载逻辑
    return Promise.resolve();
  }
}
```

## 四、React Hooks实现方案

### 1. 下拉刷新Hook
```typescript
import { useState, useRef, useEffect } from 'react';

export function usePullToRefresh(onRefresh: () => Promise<void>) {
  const [refreshing, setRefreshing] = useState(false);
  const [pullDistance, setPullDistance] = useState(0);
  const startY = useRef(0);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleTouchStart = (e: TouchEvent) => {
      if (container.scrollTop === 0) {
        startY.current = e.touches[0].clientY;
      }
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (!startY.current) return;
    
      const currentY = e.touches[0].clientY;
      const distance = currentY - startY.current;
    
      if (distance > 0) {
        e.preventDefault();
        setPullDistance(distance);
      }
    };

    const handleTouchEnd = async () => {
      if (pullDistance > 100 && !refreshing) {
        setRefreshing(true);
        await onRefresh();
        setRefreshing(false);
      }
      setPullDistance(0);
      startY.current = 0;
    };

    container.addEventListener('touchstart', handleTouchStart);
    container.addEventListener('touchmove', handleTouchMove, { passive: false });
    container.addEventListener('touchend', handleTouchEnd);

    return () => {
      container.removeEventListener('touchstart', handleTouchStart);
      container.removeEventListener('touchmove', handleTouchMove);
      container.removeEventListener('touchend', handleTouchEnd);
    };
  }, [onRefresh, pullDistance, refreshing]);

  return {
    containerRef,
    refreshing,
    pullDistance,
    shouldRefresh: pullDistance > 100
  };
}
```

### 2. 上拉加载Hook
```typescript
import { useState, useEffect, useRef } from 'react';

export function useInfiniteScroll(onLoadMore: () => Promise<void>) {
  const [loading, setLoading] = useState(false);
  const sentinelRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && !loading) {
          setLoading(true);
          onLoadMore().finally(() => setLoading(false));
        }
      },
      { threshold: 0.1 }
    );

    if (sentinelRef.current) {
      observer.observe(sentinelRef.current);
    }

    return () => observer.disconnect();
  }, [onLoadMore, loading]);

  return { sentinelRef, loading };
}
```

## 五、Vue组合式API实现

### 1. 下拉刷新Composable
```typescript
import { ref, onMounted, onUnmounted } from 'vue';

export function usePullRefresh(onRefresh: () => Promise<void>) {
  const containerRef = ref<HTMLElement | null>(null);
  const isRefreshing = ref(false);
  const pullDistance = ref(0);
  const startY = ref(0);

  const handleStart = (e: TouchEvent) => {
    if (containerRef.value?.scrollTop === 0) {
      startY.value = e.touches[0].clientY;
    }
  };

  const handleMove = (e: TouchEvent) => {
    if (!startY.value) return;
  
    const currentY = e.touches[0].clientY;
    const distance = currentY - startY.value;
  
    if (distance > 0) {
      e.preventDefault();
      pullDistance.value = distance;
    }
  };

  const handleEnd = async () => {
    if (pullDistance.value > 100 && !isRefreshing.value) {
      isRefreshing.value = true;
      await onRefresh();
      isRefreshing.value = false;
    }
    pullDistance.value = 0;
    startY.value = 0;
  };

  onMounted(() => {
    if (containerRef.value) {
      containerRef.value.addEventListener('touchstart', handleStart);
      containerRef.value.addEventListener('touchmove', handleMove, { passive: false });
      containerRef.value.addEventListener('touchend', handleEnd);
    }
  });

  onUnmounted(() => {
    if (containerRef.value) {
      containerRef.value.removeEventListener('touchstart', handleStart);
      containerRef.value.removeEventListener('touchmove', handleMove);
      containerRef.value.removeEventListener('touchend', handleEnd);
    }
  });

  return {
    containerRef,
    isRefreshing,
    pullDistance,
    shouldRefresh: pullDistance.value > 100
  };
}
```

### 2. 上拉加载Composable
```typescript
import { ref, onMounted, onUnmounted } from 'vue';

export function useInfiniteLoad(onLoadMore: () => Promise<void>) {
  const sentinelRef = ref<HTMLElement | null>(null);
  const isLoading = ref(false);
  let observer: IntersectionObserver;

  onMounted(() => {
    observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && !isLoading.value) {
          isLoading.value = true;
          onLoadMore().finally(() => {
            isLoading.value = false;
          });
        }
      },
      { threshold: 0.1 }
    );

    if (sentinelRef.value) {
      observer.observe(sentinelRef.value);
    }
  });

  onUnmounted(() => {
    observer?.disconnect();
  });

  return { sentinelRef, isLoading };
}
```

## 六、性能优化与兼容性

### 1. 关键优化策略
```typescript
// 1. 滚动节流
function throttle(fn: Function, delay: number) {
  let lastCall = 0;
  return function(...args: any[]) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      fn.apply(this, args);
    }
  };
}

// 2. 虚拟列表渲染
function renderVirtualList(container: HTMLElement, allItems: any[], itemHeight: number) {
  const { scrollTop, clientHeight } = container;
  const startIndex = Math.floor(scrollTop / itemHeight);
  const visibleCount = Math.ceil(clientHeight / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, allItems.length);

  return allItems.slice(startIndex, endIndex).map((item, i) => ({
    ...item,
    style: { transform: `translateY(${(startIndex + i) * itemHeight}px)` }
  }));
}

// 3. 数据分块加载
async function loadDataChunk(page: number, pageSize: number) {
  const response = await fetch(`/api/data?page=${page}&size=${pageSize}`);
  return response.json();
}
```

### 2. 兼容性处理
```typescript
// 1. 旧版浏览器回退方案
function setupFallback(container: HTMLElement, loadMore: () => void) {
  if (!('IntersectionObserver' in window)) {
    const handler = throttle(() => {
      if (container.scrollHeight - (container.scrollTop + container.clientHeight) < 100) {
        loadMore();
      }
    }, 200);
  
    container.addEventListener('scroll', handler);
    return () => container.removeEventListener('scroll', handler);
  }
}

// 2. iOS弹性滚动处理
function fixIOSBounce(container: HTMLElement) {
  if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
    container.style.overscrollBehavior = 'contain';
  }
}

// 3. 安卓WebView特殊处理
function fixAndroidWebView(container: HTMLElement) {
  if (navigator.userAgent.includes('Android') && navigator.userAgent.includes('WebView')) {
    container.style.touchAction = 'pan-y';
  }
}
```

## 七、完整示例整合

### React完整组件示例
```tsx
import { usePullToRefresh, useInfiniteScroll } from './hooks';

function InfiniteList({ items, loadMore, refresh }: {
  items: any[];
  loadMore: () => Promise<void>;
  refresh: () => Promise<void>;
}) {
  const { containerRef, refreshing, pullDistance } = usePullToRefresh(refresh);
  const { sentinelRef, loading } = useInfiniteScroll(loadMore);

  return (
    <div 
      ref={containerRef}
      className="list-container"
      style={{ overflow: 'auto', height: '100vh' }}
    >
      {/* 下拉刷新区域 */}
      <div 
        className="refresh-indicator"
        style={{
          transform: `translateY(${pullDistance}px)`,
          opacity: Math.min(pullDistance / 100, 1)
        }}
      >
        {refreshing ? '刷新中...' : pullDistance > 100 ? '释放刷新' : '下拉刷新'}
      </div>
    
      {/* 列表内容 */}
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    
      {/* 上拉加载哨兵 */}
      <div ref={sentinelRef} style={{ height: '1px' }} />
    
      {/* 加载指示器 */}
      {loading && <div className="loading-indicator">加载中...</div>}
    </div>
  );
}
```

### Vue完整组件示例
```vue
<template>
  <div 
    ref="container"
    class="list-container"
    @touchstart="handleTouchStart"
    @touchmove="handleTouchMove"
    @touchend="handleTouchEnd"
  >
    <!-- 下拉刷新区域 -->
    <div 
      class="refresh-indicator"
      :style="{
        transform: `translateY(${pullDistance}px)`,
        opacity: Math.min(pullDistance / 100, 1)
      }"
    >
      {{ isRefreshing ? '刷新中...' : pullDistance > 100 ? '释放刷新' : '下拉刷新' }}
    </div>
  
    <!-- 列表内容 -->
    <ul>
      <li v-for="item in visibleItems" :key="item.id">
        {{ item.name }}
      </li>
    </ul>
  
    <!-- 上拉加载哨兵 -->
    <div ref="sentinel" class="sentinel" />
  
    <!-- 加载指示器 -->
    <div v-if="isLoading" class="loading-indicator">
      加载中...
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, computed } from 'vue';

const props = defineProps({
  items: Array,
  loadMore: Function,
  refresh: Function
});

const container = ref(null);
const sentinel = ref(null);
const isRefreshing = ref(false);
const isLoading = ref(false);
const pullDistance = ref(0);
const startY = ref(0);

// 实现下拉刷新逻辑
const handleTouchStart = (e) => {
  if (container.value.scrollTop === 0) {
    startY.value = e.touches[0].clientY;
  }
};

const handleTouchMove = (e) => {
  if (!startY.value) return;

  const currentY = e.touches[0].clientY;
  const distance = currentY - startY.value;

  if (distance > 0) {
    e.preventDefault();
    pullDistance.value = distance;
  }
};

const handleTouchEnd = async () => {
  if (pullDistance.value > 100 && !isRefreshing.value) {
    isRefreshing.value = true;
    await props.refresh();
    isRefreshing.value = false;
  }
  pullDistance.value = 0;
  startY.value = 0;
};

// 实现上拉加载逻辑
let observer;
onMounted(() => {
  observer = new IntersectionObserver(
      async ([entry]) => {
        if (entry.isIntersecting && !isLoading.value) {
          isLoading.value = true;
          await props.loadMore();
          isLoading.value = false;
        }
      },
      { root: container.value, threshold: 0.1 }
  );

  if (sentinel.value) {
    observer.observe(sentinel.value);
  }
});

onUnmounted(() => {
  observer?.disconnect();
});

// 虚拟列表优化（可选）
const visibleItems = computed(() => {
  if (!container.value) return props.items;

  const { scrollTop, clientHeight } = container.value;
  const itemHeight = 50; // 假设每个项目高度为50px
  const startIndex = Math.floor(scrollTop / itemHeight);
  const visibleCount = Math.ceil(clientHeight / itemHeight);

  return props.items.slice(startIndex, startIndex + visibleCount + 2);
});
</script>

<style scoped>
  .list-container {
    position: relative;
    height: 100vh;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .refresh-indicator {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f5f5f5;
    transform: translateY(-100%);
    transition: opacity 0.2s;
  }

  .loading-indicator {
    padding: 16px;
    text-align: center;
    color: #888;
  }

  .sentinel {
    height: 1px;
  }

  /* 禁用iOS弹性滚动 */
  @supports (-webkit-touch-callout: none) {
    .list-container {
      overscroll-behavior-y: contain;
    }
  }
</style>
```

## 八、最佳实践总结

### 1. 实现方案选择指南

| 场景 | 推荐方案 | 关键优势 | 注意事项 |
|------|----------|----------|----------|
| 简单H5页面 | 原生JS实现 | 零依赖，体积小 | 需处理兼容性问题 |
| React项目 | 自定义Hooks | 逻辑复用性好 | 需要React 16.8+ |
| Vue项目 | 组合式API | Vue 3最佳实践 | 需要Vue 3支持 |
| 复杂交互 | better-scroll库 | 功能完善，平滑滚动 | 学习成本较高 |

### 2. 关键性能指标

1. **FPS保持≥50**：
   ```typescript
   // 使用requestAnimationFrame优化动画
   function smoothScrollTo(element: HTMLElement, targetY: number) {
     const startY = element.scrollTop;
     const distance = targetY - startY;
     const duration = 300;
     let startTime: number;
 
     function animate(currentTime: number) {
       if (!startTime) startTime = currentTime;
       const timeElapsed = currentTime - startTime;
       const progress = Math.min(timeElapsed / duration, 1);
   
       element.scrollTop = startY + distance * progress;
   
       if (timeElapsed < duration) {
         requestAnimationFrame(animate);
       }
     }
 
     requestAnimationFrame(animate);
   }
   ```

2. **内存管理**：
   ```typescript
   // 分页数据缓存策略
   class DataCache {
     private cache = new Map<number, any[]>();
     private maxSize = 5;
 
     async getPage(page: number) {
       if (this.cache.has(page)) {
         return this.cache.get(page);
       }
   
       const data = await fetchPage(page);
       this.cache.set(page, data);
   
       if (this.cache.size > this.maxSize) {
         const oldestKey = this.cache.keys().next().value;
         this.cache.delete(oldestKey);
       }
   
       return data;
     }
   }
   ```

3. **滚动性能优化**：
   ```typescript
   // 使用will-change提示浏览器优化
   function optimizeScrollPerformance(element: HTMLElement) {
     element.style.willChange = 'transform';
     setTimeout(() => {
       element.style.willChange = '';
     }, 1000);
   }
   ```

### 3. 常见问题解决方案

1. **iOS橡皮筋效果冲突**：
   ```css
   /* 全局样式 */
   html, body {
     overscroll-behavior-y: contain;
     height: 100%;
     overflow: hidden;
   }
 
   /* 滚动容器 */
   .scroll-container {
     -webkit-overflow-scrolling: touch;
     height: 100vh;
     overflow-y: auto;
   }
   ```

2. **安卓WebView触摸延迟**：
   ```typescript
   // 添加touch-action样式
   function fixAndroidTouchDelay(element: HTMLElement) {
     element.style.touchAction = 'pan-y';
   }
   ```

3. **快速滑动白屏问题**：
   ```typescript
   // 预加载下一页数据
   function preloadNextPage(currentPage: number) {
     const nextPage = currentPage + 1;
     if (!isPageLoaded(nextPage)) {
       fetchPage(nextPage);
     }
   }
   ```

4. **滚动抖动问题**：
   ```typescript
   // 使用防抖处理滚动事件
   const debounceScroll = debounce(() => {
     // 处理滚动逻辑
   }, 100);
 
   element.addEventListener('scroll', debounceScroll);
   ```

## 九、高级应用场景

### 1. 嵌套滚动容器
```typescript
// 处理父容器和子容器的滚动冲突
class NestedScrollHandler {
  private parent: HTMLElement;
  private child: HTMLElement;
  private isChildScrolling = false;

  constructor(parent: HTMLElement, child: HTMLElement) {
    this.parent = parent;
    this.child = child;
    this.setupEvents();
  }

  private setupEvents() {
    // 这里只是标记状态，不需要阻止默认行为
    this.child.addEventListener('touchstart', () => {
      this.isChildScrolling = true;
    }, { passive: true }); // 提升性能，因为我们不会调用 preventDefault

    this.child.addEventListener('touchend', () => {
      this.isChildScrolling = false;
    }, { passive: true }); // 同样提升性能

    // 这里可能需要阻止默认行为，所以不能用 passive
    this.parent.addEventListener('scroll', () => {
      if (this.isChildScrolling) {
        this.parent.scrollTop = 0; // 保持父容器不动
      }
    }); // 注意：scroll 事件默认就是 passive 的
  }
}

```

### 2. 横向滚动加载
```typescript
class HorizontalInfiniteLoader {
  private observer: IntersectionObserver;
  private sentinel: HTMLElement;

  constructor(private container: HTMLElement) {
    this.sentinel = this.createSentinel();
    container.appendChild(this.sentinel);

    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      { 
        root: container,
        rootMargin: '0px 100px', // 预加载区域
        threshold: 0.1
      }
    );
    this.observer.observe(this.sentinel);
  }

  private handleIntersection(entries: IntersectionObserverEntry[]) {
    if (entries[0].isIntersecting) {
      this.loadMore();
    }
  }

  private async loadMore() {
    // 加载更多水平内容
  }
}
```

### 3. 虚拟滚动优化
```typescript
class VirtualScroll {
  private visibleItems: any[] = [];
  private itemHeight: number;
  private renderWindowSize: number;

  constructor(
    private container: HTMLElement,
    private allItems: any[],
    itemHeight: number
  ) {
    this.itemHeight = itemHeight;
    this.renderWindowSize = Math.ceil(container.clientHeight / itemHeight) + 2;
    this.setupScrollListener();
    this.updateVisibleItems();
  }

  private setupScrollListener() {
    this.container.addEventListener('scroll', () => {
      this.updateVisibleItems();
    }, { passive: true });
  }

  private updateVisibleItems() {
    const scrollTop = this.container.scrollTop;
    const startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + this.renderWindowSize,
      this.allItems.length
    );

    this.visibleItems = this.allItems.slice(startIndex, endIndex);
    this.renderItems();
  }

  private renderItems() {
    // 实际渲染逻辑
  }
}
```

## 十、测试与调试技巧

### 1. 模拟慢速网络
```typescript
// 使用Service Worker模拟慢速网络
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/slow-network.js', {
    scope: '/'
  });
}

// slow-network.js内容
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      new Promise(resolve => {
        setTimeout(() => {
          fetch(event.request).then(resolve);
        }, 2000); // 2秒延迟
      })
    );
  }
});
```

### 2. 滚动性能分析
```typescript
// 使用PerformanceObserver监控滚动性能
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'render' || entry.entryType === 'paint') {
      console.log('渲染耗时:', entry);
    }
  }
});

observer.observe({ entryTypes: ['render', 'paint'] });
```

### 3. 内存泄漏检测
```typescript
// 使用WeakMap检测DOM引用
const domRefs = new WeakMap();

function trackElement(element: HTMLElement) {
  domRefs.set(element, {
    timestamp: Date.now(),
    stack: new Error().stack
  });
}

// 定期检查未释放的元素
setInterval(() => {
  console.log('当前跟踪的DOM元素:', domRefs);
}, 60000);
```

## 十一、最终完整实现示例

### React终极方案
```tsx
import React, { useState, useRef, useEffect, useCallback } from 'react';

interface InfiniteScrollProps {
  fetchData: (page: number) => Promise<any[]>;
  renderItem: (item: any) => React.ReactNode;
  itemHeight: number;
}

export function InfiniteScrollList({ fetchData, renderItem, itemHeight }: InfiniteScrollProps) {
  const [items, setItems] = useState<any[]>([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const startY = useRef(0);
  const pullDistance = useRef(0);

  // 加载更多数据
  const loadMore = useCallback(async () => {
    if (loading) return;

    setLoading(true);
    try {
      const newItems = await fetchData(page);
      setItems(prev => [...prev, ...newItems]);
      setPage(p => p + 1);
    } finally {
      setLoading(false);
    }
  }, [fetchData, page, loading]);

  // 刷新数据
  const refresh = useCallback(async () => {
    setRefreshing(true);
    try {
      const newItems = await fetchData(1);
      setItems(newItems);
      setPage(2);
    } finally {
      setRefreshing(false);
    }
  }, [fetchData]);

  // 初始化加载
  useEffect(() => {
    loadMore();
  }, []);

  // 下拉刷新逻辑
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleTouchStart = (e: TouchEvent) => {
      if (container.scrollTop === 0) {
        startY.current = e.touches[0].clientY;
      }
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (!startY.current) return;
  
      const currentY = e.touches[0].clientY;
      const distance = currentY - startY.current;
  
      if (distance > 0) {
        e.preventDefault();
        pullDistance.current = distance;
        container.style.transform = `translateY(${distance}px)`;
      }
    };

    const handleTouchEnd = async () => {
      if (pullDistance.current > 100 && !refreshing) {
        await refresh();
      }
      startY.current = 0;
      pullDistance.current = 0;
      container.style.transform = '';
    };

    container.addEventListener('touchstart', handleTouchStart);
    container.addEventListener('touchmove', handleTouchMove, { passive: false });
    container.addEventListener('touchend', handleTouchEnd);

    return () => {
      container.removeEventListener('touchstart', handleTouchStart);
      container.removeEventListener('touchmove', handleTouchMove);
      container.removeEventListener('touchend', handleTouchEnd);
    };
  }, [refresh, refreshing]);

  // 上拉加载逻辑
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = throttle(() => {
      const { scrollTop, scrollHeight, clientHeight } = container;
      if (scrollHeight - (scrollTop + clientHeight) < 50 && !loading) {
        loadMore();
      }
    }, 200);

    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, [loadMore, loading]);

  // 虚拟列表计算
  const visibleItems = useMemo(() => {
    if (!containerRef.current) return items;

    const scrollTop = containerRef.current.scrollTop;
    const startIndex = Math.floor(scrollTop / itemHeight);
    const visibleCount = Math.ceil(containerRef.current.clientHeight / itemHeight);

    return items.slice(startIndex, startIndex + visibleCount + 2);
  }, [items, containerRef.current?.scrollTop]);

  return (
    <div 
      ref={containerRef}
      className="infinite-scroll-container"
      style={{
        height: '100vh',
        overflow: 'auto',
        position: 'relative'
      }}
    >
      {/* 下拉刷新指示器 */}
      {pullDistance.current > 0 && (
        <div 
          className="refresh-indicator"
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            height: '60px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            background: '#f5f5f5',
            transform: `translateY(${-60 + pullDistance.current}px)`
          }}
        >
          {refreshing ? '刷新中...' : pullDistance.current > 100 ? '释放刷新' : '下拉刷新'}
        </div>
      )}
  
      {/* 内容占位，确保滚动条正确 */}
      <div style={{ height: `${items.length * itemHeight}px` }}>
        {/* 实际渲染的可见项目 */}
        <div 
          style={{
            position: 'absolute',
            top: `${Math.floor(containerRef.current?.scrollTop || 0 / itemHeight) * itemHeight}px`,
            width: '100%'
          }}
        >
          {visibleItems.map((item, index) => (
            <div 
              key={item.id}
              style={{ height: `${itemHeight}px` }}
            >
              {renderItem(item)}
            </div>
          ))}
        </div>
      </div>
  
      {/* 加载指示器 */}
      {loading && (
        <div 
          style={{
            padding: '16px',
            textAlign: 'center',
            color: '#888'
          }}
        >
          加载中...
        </div>
      )}
    </div>
  );
}

// 辅助函数
function throttle(fn: Function, delay: number) {
  let lastCall = 0;
  return function(...args: any[]) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      fn.apply(this, args);
    }
  };
}
```

### Vue终极方案
```vue
<template>
  <div 
    ref="container"
    class="infinite-scroll-container"
    @touchstart="handleTouchStart"
    @touchmove="handleTouchMove"
    @touchend="handleTouchEnd"
    @scroll="handleScroll"
  >
    <!-- 下拉刷新指示器 -->
    <div 
      v-show="pullDistance > 0"
      class="refresh-indicator"
      :style="{
        transform: `translateY(${-60 + pullDistance}px)`
      }"
    >
      {{ refreshing ? '刷新中...' : pullDistance > 100 ? '释放刷新' : '下拉刷新' }}
    </div>

    <!-- 虚拟列表内容 -->
    <div 
      class="content-placeholder"
      :style="{ height: `${totalHeight}px` }"
    >
      <div 
        class="visible-items"
        :style="{
          transform: `translateY(${offsetY}px)`
        }"
      >
        <div 
          v-for="item in visibleItems"
          :key="item.id"
          class="list-item"
          :style="{ height: `${itemHeight}px` }"
        >
          <slot :item="item" />
        </div>
      </div>
    </div>

    <!-- 加载指示器 -->
    <div v-if="loading" class="loading-indicator">
      加载中...
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue';

const props = defineProps({
  fetchData: {
    type: Function,
    required: true
  },
  itemHeight: {
    type: Number,
    required: true
  }
});

const container = ref<HTMLElement | null>(null);
const items = ref<any[]>([]);
const page = ref(1);
const loading = ref(false);
const refreshing = ref(false);
const startY = ref(0);
const pullDistance = ref(0);
const scrollTop = ref(0);

// 初始化加载
onMounted(async () => {
  await loadMore();
});

// 计算总高度
const totalHeight = computed(() => {
  return items.value.length * props.itemHeight;
});

// 计算可视区域偏移量
const offsetY = computed(() => {
  return Math.floor(scrollTop.value / props.itemHeight) * props.itemHeight;
});

// 计算可视项目
const visibleItems = computed(() => {
  const startIndex = Math.floor(scrollTop.value / props.itemHeight);
  const visibleCount = container.value 
    ? Math.ceil(container.value.clientHeight / props.itemHeight) + 2
    : 10;

  return items.value.slice(startIndex, startIndex + visibleCount);
});

// 加载更多数据
const loadMore = async () => {
  if (loading.value) return;

  loading.value = true;
  try {
    const newItems = await props.fetchData(page.value);
    items.value = [...items.value, ...newItems];
    page.value++;
  } finally {
    loading.value = false;
  }
};

// 刷新数据
const refresh = async () => {
  refreshing.value = true;
  try {
    const newItems = await props.fetchData(1);
    items.value = newItems;
    page.value = 2;
  } finally {
    refreshing.value = false;
  }
};

// 处理触摸事件
const handleTouchStart = (e: TouchEvent) => {
  if (container.value?.scrollTop === 0) {
    startY.value = e.touches[0].clientY;
  }
};

const handleTouchMove = (e: TouchEvent) => {
  if (!startY.value) return;

  const currentY = e.touches[0].clientY;
  const distance = currentY - startY.value;

  if (distance > 0 && container.value?.scrollTop === 0) {
    e.preventDefault();
    pullDistance.value = distance;
  }
};

const handleTouchEnd = async () => {
  if (pullDistance.value > 100 && !refreshing.value) {
    await refresh();
  }
  pullDistance.value = 0;
  startY.value = 0;
};

// 处理滚动事件
const handleScroll = () => {
  if (!container.value) return;

  scrollTop.value = container.value.scrollTop;

  // 检查是否接近底部
  const { scrollTop, scrollHeight, clientHeight } = container.value;
  if (scrollHeight - (scrollTop + clientHeight) < 50 && !loading.value) {
    loadMore();
  }
};

// 添加滚动节流
const throttledScroll = throttle(handleScroll, 100);
onMounted(() => {
  if (container.value) {
    container.value.addEventListener('scroll', throttledScroll);
  }
});

onUnmounted(() => {
  if (container.value) {
    container.value.removeEventListener('scroll', throttledScroll);
  }
});

// 节流函数
function throttle(fn: Function, delay: number) {
  let lastCall = 0;
  return function(this: any, ...args: any[]) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      fn.apply(this, args);
    }
  };
}
</script>

<style scoped>
.infinite-scroll-container {
  position: relative;
  height: 100vh;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.content-placeholder {
  position: relative;
}

.visible-items {
  position: absolute;
  width: 100%;
}

.list-item {
  box-sizing: border-box;
  border-bottom: 1px solid #eee;
}

.refresh-indicator {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f5f5f5;
  z-index: 10;
}

.loading-indicator {
  padding: 16px;
  text-align: center;
  color: #888;
}

/* 禁用iOS弹性滚动 */
@supports (-webkit-touch-callout: none) {
  .infinite-scroll-container {
    overscroll-behavior-y: contain;
  }
}
</style>
```

## 十二、总结与最佳实践

### 1. 实现选择建议

- **简单需求**：使用原生IntersectionObserver + 触摸事件实现
- **React项目**：采用自定义Hooks方案，逻辑复用性好
- **Vue项目**：使用组合式API，与Vue生态完美结合
- **复杂场景**：考虑使用better-scroll等成熟库

### 2. 性能优化要点

1. **虚拟列表**：只渲染可视区域内的元素
2. **节流处理**：避免频繁触发滚动事件
3. **内存管理**：合理缓存数据，避免内存泄漏
4. **硬件加速**：使用transform代替top/left定位

### 3. 兼容性处理

1. **iOS**：
   ```css
   -webkit-overflow-scrolling: touch;
   overscroll-behavior-y: contain;
   ```

2. **Android**：
   ```css
   touch-action: pan-y;
   ```

3. **旧版浏览器**：
   ```typescript
   // 提供IntersectionObserver的polyfill
   if (!('IntersectionObserver' in window)) {
     // 回退到滚动事件监听
   }
   ```

### 4. 调试技巧

1. **Chrome DevTools**：
    - 使用Performance面板分析滚动性能
    - 使用Lighthouse检测最佳实践

2. **真机调试**：
    - iOS使用Safari远程调试
    - Android使用Chrome远程调试

3. **网络模拟**：
   ```typescript
   // 模拟慢速网络
   navigator.connection.downlink = 1; // 1Mbps
   ```

通过以上完整的实现方案和最佳实践，您可以在移动端高效地实现上拉加载和下拉刷新功能，同时确保良好的用户体验和性能表现。根据项目需求选择适合的实现方式，并注意优化和兼容性处理，可以打造出流畅的列表交互体验。
