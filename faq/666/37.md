##　37. 如何实现网页加载进度条？

# 网页加载进度条实现方案

以下是多种实现网页加载进度条的完整方案，从简单到复杂，包含代码示例：

## 一、纯CSS实现方案

### 1. 基础进度条动画
```html
<div class="progress-bar"></div>
```

```css
.progress-bar {
    position: fixed;
    top: 0;
    left: 0;
    height: 3px;
    background: linear-gradient(to right, #ff4d4f, #1890ff);
    width: 0;
    animation: progress 2s ease-in-out forwards;
    z-index: 9999;
}

@keyframes progress {
    0% {
        width: 0;
    }
    100% {
        width: 100%;
    }
}
```

<iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/Jeek-Chou/embed/yyYXLvd?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/Jeek-Chou/pen/yyYXLvd">
  Untitled</a> by Jeek Chou (<a href="https://codepen.io/Jeek-Chou">@Jeek-Chou</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

### 2. 模拟真实加载效果

```css
.simulate-progress {
    position: fixed;
    top: 0;
    left: 0;
    height: 3px;
    background: #1890ff;
    z-index: 9999;
    transition: width 0.4s ease;
    width: 0;
}

.simulate-progress.loading {
    animation: simulate-load 3s cubic-bezier(0.1, 0.5, 0.1, 1) forwards;
}

@keyframes simulate-load {
    0% {
        width: 0;
    }
    20% {
        width: 25%;
    }
    40% {
        width: 45%;
    }
    60% {
        width: 65%;
    }
    80% {
        width: 85%;
    }
    100% {
        width: 100%;
    }
}
```

<iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/Jeek-Chou/embed/pvjwoLm?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/Jeek-Chou/pen/pvjwoLm">
  Untitled</a> by Jeek Chou (<a href="https://codepen.io/Jeek-Chou">@Jeek-Chou</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

## 二、JavaScript真实加载进度

### 1. 基于资源加载的进度条
```html
<div id="progress-bar" class="progress-bar"></div>
```

```javascript
document.addEventListener('DOMContentLoaded', () => {
  const progressBar = document.getElementById('progress-bar');
  const resources = document.querySelectorAll('img, script, link[rel="stylesheet"]');
  let loaded = 0;

  if (resources.length === 0) {
    progressBar.style.width = '100%';
    return;
  }

  resources.forEach(resource => {
    if (resource.complete || resource.readyState === 'complete') {
      loaded++;
      updateProgress();
    } else {
      resource.addEventListener('load', () => {
        loaded++;
        updateProgress();
      });
      resource.addEventListener('error', () => {
        loaded++;
        updateProgress();
      });
    }
  });

  function updateProgress() {
    const progress = (loaded / resources.length) * 100;
    progressBar.style.width = `${progress}%`;
  
    if (progress >= 100) {
      setTimeout(() => {
        progressBar.style.opacity = '0';
        setTimeout(() => {
          progressBar.style.display = 'none';
        }, 300);
      }, 300);
    }
  }
});
```

### 2. 结合Fetch API的进度监控
```javascript
// 拦截所有fetch请求
const originalFetch = window.fetch;
window.fetch = async function(...args) {
  const response = await originalFetch(...args);

  if (!response.body) return response;

  const contentLength = response.headers.get('content-length');
  if (!contentLength) return response;

  const total = parseInt(contentLength, 10);
  let loaded = 0;

  const progressReader = response.body.getReader();
  const newResponse = new Response(
    new ReadableStream({
      async start(controller) {
        while (true) {
          const { done, value } = await progressReader.read();
          if (done) {
            controller.close();
            break;
          }
          loaded += value.byteLength;
          updateProgress(loaded / total * 100);
          controller.enqueue(value);
        }
      }
    })
  );

  Object.defineProperty(newResponse, 'url', { value: response.url });
  return newResponse;
};

function updateProgress(percent) {
  const progressBar = document.getElementById('progress-bar');
  progressBar.style.width = `${percent}%`;
}
```

## 三、高级实现方案

### 1. NProgress.js风格进度条
```html
<div id="nprogress">
  <div class="bar"></div>
  <div class="peg"></div>
</div>
```

```css
#nprogress {
  pointer-events: none;
}

#nprogress .bar {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 9999;
  width: 100%;
  height: 2px;
  background: #1890ff;
  transform-origin: left;
  transform: scaleX(0);
  transition: transform 0.2s ease;
}

#nprogress .peg {
  position: absolute;
  right: 0;
  top: 0;
  width: 100px;
  height: 100%;
  box-shadow: 0 0 10px #1890ff, 0 0 5px #1890ff;
  opacity: 1;
  transform: rotate(3deg) translate(0px, -4px);
}
```

```javascript
class NProgress {
  constructor() {
    this.status = null;
    this.trickleSpeed = 200;
    this.minimum = 0.08;
    this.bar = document.querySelector('#nprogress .bar');
    this.peg = document.querySelector('#nprogress .peg');
    this.trickle = this.trickle.bind(this);
  }

  start() {
    if (this.status !== null) return;
    this.set(0);
    this.interval = setInterval(this.trickle, this.trickleSpeed);
  }

  set(n) {
    n = Math.min(1, Math.max(this.minimum, n));
    this.status = n === 1 ? null : n;
    this.bar.style.transform = `scaleX(${n})`;
  }

  trickle() {
    if (this.status >= 1) {
      clearInterval(this.interval);
      return;
    }
    this.set(this.status + 0.02 * Math.random());
  }

  done() {
    if (this.status === null) return;
    clearInterval(this.interval);
    this.set(1);
    setTimeout(() => {
      this.bar.style.transform = 'scaleX(0)';
    }, 300);
  }
}

const nprogress = new NProgress();
nprogress.start();

// 页面加载完成后调用
window.addEventListener('load', () => {
  nprogress.done();
});
```

### 2. 带缓冲效果的进度条
```javascript
class SmoothProgress {
  constructor() {
    this.target = 0;
    this.current = 0;
    this.bar = document.getElementById('progress-bar');
    this.rafId = null;
    this.speed = 0.1;
    this.animate = this.animate.bind(this);
  }

  set(percent) {
    this.target = percent;
    if (!this.rafId) {
      this.animate();
    }
  }

  animate() {
    const diff = this.target - this.current;
    this.current += diff * this.speed;
  
    if (Math.abs(diff) < 0.1) {
      this.current = this.target;
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    } else {
      this.rafId = requestAnimationFrame(this.animate);
    }
  
    this.bar.style.width = `${this.current * 100}%`;
  
    if (this.current >= 1) {
      setTimeout(() => {
        this.bar.style.opacity = '0';
        setTimeout(() => {
          this.bar.style.display = 'none';
        }, 300);
      }, 300);
    }
  }
}

const progress = new SmoothProgress();

// 模拟加载过程
let loaded = 0;
const total = 10;
const interval = setInterval(() => {
  loaded++;
  progress.set(loaded / total);
  if (loaded >= total) clearInterval(interval);
}, 500);
```

## 四、React组件实现

### 1. React进度条组件
```jsx
import { useEffect, useState } from 'react';

function ProgressBar() {
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    const handleLoad = () => {
      setProgress(100);
      setTimeout(() => setProgress(0), 300);
    };
  
    window.addEventListener('load', handleLoad);
  
    // 模拟加载进度
    const interval = setInterval(() => {
      setProgress(prev => {
        if (prev >= 95) {
          clearInterval(interval);
          return prev;
        }
        return prev + Math.random() * 10;
      });
    }, 300);
  
    return () => {
      window.removeEventListener('load', handleLoad);
      clearInterval(interval);
    };
  }, []);

  return (
    <div className="progress-container">
      <div 
        className="progress-bar"
        style={{
          width: `${progress}%`,
          transition: progress > 0 ? 'width 0.3s ease' : 'none'
        }}
      />
    </div>
  );
}

// CSS
.progress-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 3px;
  z-index: 9999;
  background: rgba(0,0,0,0.1);
}

.progress-bar {
  height: 100%;
  background: linear-gradient(to right, #ff4d4f, #1890ff);
  transition: width 0.3s ease;
}
```

## 五、Vue组件实现

### 1. Vue进度条组件
```vue
<template>
  <div class="progress-container">
    <div 
      class="progress-bar"
      :style="{
        width: `${progress}%`,
        transition: progress > 0 ? 'width 0.3s ease' : 'none'
      }"
    />
  </div>
</template>

<script>
export default {
  data() {
    return {
      progress: 0
    };
  },
  mounted() {
    window.addEventListener('load', this.handleLoad);
  
    // 模拟加载进度
    this.interval = setInterval(() => {
      this.progress = Math.min(
        this.progress + Math.random() * 10,
        95
      );
    }, 300);
  },
  methods: {
    handleLoad() {
      this.progress = 100;
      setTimeout(() => {
        this.progress = 0;
      }, 300);
    }
  },
  beforeDestroy() {
    window.removeEventListener('load', this.handleLoad);
    clearInterval(this.interval);
  }
};
</script>

<style scoped>
.progress-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 3px;
  z-index: 9999;
  background: rgba(0,0,0,0.1);
}

.progress-bar {
  height: 100%;
  background: linear-gradient(to right, #ff4d4f, #1890ff);
  transition: width 0.3s ease;
}
</style>
```

## 六、性能优化建议

1. **使用requestAnimationFrame**：确保动画流畅
2. **减少DOM操作**：避免频繁修改样式
3. **硬件加速**：对进度条添加 `transform: translateZ(0)`
4. **合理设置更新频率**：避免过于频繁的进度更新
5. **预加载关键资源**：提前加载主要资源，提高进度准确性

## 七、最佳实践选择指南

| 场景 | 推荐方案 | 优点 | 缺点 |
|------|----------|------|------|
| 简单页面 | CSS动画 | 实现简单 | 不反映真实进度 |
| 多资源页面 | JS资源监控 | 准确反映加载 | 实现较复杂 |
| SPA应用 | NProgress风格 | 美观流畅 | 需要集成 |
| 需要精细控制 | 缓冲效果类 | 平滑过渡 | 性能开销大 |

对于大多数现代Web应用，推荐使用类似NProgress的实现方案，它提供了良好的用户体验和视觉效果。对于需要精确反映资源加载进度的场景，可以使用基于资源监控的方案。
