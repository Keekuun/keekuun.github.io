## 112. nodejs 如何充分利用多核 CPU？

在 Node.js 中，由于其单线程的特性，默认情况下无法直接利用多核 CPU 的优势。但通过以下方法，可以充分利用多核 CPU 提升性能：

---

### 🚀 **核心方法**
#### 1. **使用 `cluster` 模块（内置）**
- **原理**：主进程（Master）创建多个子进程（Worker），每个子进程运行一个 Node.js 实例，共享同一个端口。
- **适用场景**：HTTP 服务器、高并发 I/O 密集型任务。
- **代码示例**：
  ```javascript
  const cluster = require('cluster');
  const os = require('os');
  const http = require('http');

  if (cluster.isMaster) {
      const numCPUs = os.cpus().length;
      console.log(`主进程 ${process.pid} 启动，创建 ${numCPUs} 个子进程`);

      for (let i = 0; i < numCPUs; i++) {
          cluster.fork(); // 创建子进程
      }

      cluster.on('exit', (worker) => {
          console.log(`子进程 ${worker.process.pid} 退出，重新启动...`);
          cluster.fork(); // 自动重启
      });
  } else {
      http.createServer((req, res) => {
          res.writeHead(200);
          res.end(`Worker ${process.pid} 处理请求`);
      }).listen(3000);

      console.log(`子进程 ${process.pid} 启动`);
  }
  ```

#### 2. **使用 `worker_threads` 模块（内置）**
- **原理**：通过多线程实现 CPU 密集型任务的并行处理（每个线程有自己的 V8 实例）。
- **适用场景**：计算密集型任务（如加密、大数据处理）。
- **代码示例**：
  ```javascript
  const { Worker, isMainThread, parentPort } = require('worker_threads');

  if (isMainThread) {
      const worker = new Worker(__filename);
      worker.on('message', (msg) => console.log(`主线程收到: ${msg}`));
      worker.postMessage('Hello Worker!');
  } else {
      parentPort.on('message', (msg) => {
          console.log(`子线程收到: ${msg}`);
          parentPort.postMessage('Hello Main!');
      });
  }
  ```

#### 3. **使用 `child_process` 模块（内置）**
- **原理**：通过创建子进程运行外部命令或其他脚本。
- **适用场景**：调用系统命令或独立脚本。
- **代码示例**：
  ```javascript
  const { exec } = require('child_process');

  exec('node heavy-task.js', (error, stdout, stderr) => {
      if (error) throw error;
      console.log(stdout);
  });
  ```

#### 4. **使用 PM2 进程管理器（第三方）**
- **原理**：PM2 自动管理多进程和负载均衡。
- **适用场景**：生产环境部署。
- **安装与使用**：
  ```bash
  npm install pm2 -g
  pm2 start app.js -i max # 根据 CPU 核心数启动多个实例
  ```

---

### 📊 **方法对比**
| **方法**          | **类型**       | **适用场景**               | **优点**                     | **缺点**                     |
|--------------------|----------------|---------------------------|-----------------------------|-----------------------------|
| `cluster`         | 多进程         | HTTP 服务、I/O 密集型     | 内置模块，简单易用          | 进程间通信较复杂            |
| `worker_threads`  | 多线程         | CPU 密集型任务            | 轻量级，共享内存            | 需要 Node.js 10+            |
| `child_process`   | 多进程         | 调用外部脚本/命令         | 灵活性高                    | 资源消耗较大                |
| PM2               | 进程管理工具   | 生产环境部署              | 自动重启、监控              | 需要额外安装                |

---

### 🌟 **优化建议**
1. **负载均衡**：
    - 使用 `cluster` 或 PM2 时，请求会自动分配到空闲的 Worker。
2. **进程通信**：
    - 通过 `IPC`（进程间通信）或消息队列（如 Redis）共享数据。
3. **错误处理**：
    - 监听 `exit` 事件，自动重启崩溃的进程或线程。
4. **资源限制**：
    - 避免创建过多进程/线程（通常不超过 CPU 核心数的 1.5 倍）。

---

### 🛠 **实战示例：CPU 密集型任务并行化**
```javascript
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

function fibonacci(n) {
    return n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);
}

if (isMainThread) {
    const numCPUs = require('os').cpus().length;
    const inputs = [40, 41, 42, 43]; // 计算斐波那契数列

    inputs.forEach((input) => {
        const worker = new Worker(__filename, { workerData: input });
        worker.on('message', (result) => {
            console.log(`Fibonacci(${input}) = ${result}`);
        });
    });
} else {
    const result = fibonacci(workerData);
    parentPort.postMessage(result);
}
```

---

### ⚠️ **注意事项**
1. **避免共享状态**：
    - 多进程/线程间避免直接共享内存，改用消息传递。
2. **调试难度**：
    - 多进程/线程的调试比单线程复杂，建议使用日志工具（如 `winston`）。
3. **版本兼容性**：
    - `worker_threads` 需要 Node.js 10+，且某些功能在 LTS 版本中可能受限。

---

通过以上方法，你可以充分发挥 Node.js 在多核 CPU 环境下的潜力，显著提升应用性能！ 🎉