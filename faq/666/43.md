## 43. 前端水印了解多少？

前端水印是在网页或图片上叠加半透明标识的技术，用于版权保护、防泄密和追踪来源。以下是前端水印的详细实现方案和技术要点：

## 一、水印基础类型

### 1. 静态水印
- 固定文字/logo
- 统一透明度
- 均匀平铺整个页面

### 2. 动态水印
- 包含用户ID/时间等变量信息
- 不同区域不同密度
- 可绑定交互行为

### 3. 隐形水印
- 人眼不可见的像素级修改
- 需要算法提取验证
- 抗截图/拍照

## 二、DOM水印实现方案

### 1. 背景图水印（CSS）
```css
.watermarked {
  background-image: url("data:image/svg+xml;utf8,<svg...>水印文本</svg>");
  background-repeat: repeat;
  background-size: 200px 100px;
  background-attachment: fixed;
  opacity: 0.1;
}
```

### 2. Canvas动态生成
```typescript
function createWatermark(text: string): HTMLCanvasElement {
  const canvas = document.createElement('canvas');
  canvas.width = 200;
  canvas.height = 100;

  const ctx = canvas.getContext('2d')!;
  ctx.font = '16px Arial';
  ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
  ctx.rotate(-20 * Math.PI / 180);
  ctx.fillText(text, 10, 70);

  return canvas;
}

// 应用水印
function applyWatermark() {
  const watermark = createWatermark('机密文档');
  const style = `position:fixed;top:0;left:0;width:100%;height:100%;
                pointer-events:none;z-index:9999;
                background-image:url(${watermark.toDataURL()});
                background-repeat:repeat;`;

  const div = document.createElement('div');
  div.setAttribute('style', style);
  document.body.appendChild(div);
}
```

### 3. SVG水印（高清方案）
```typescript
function generateSVGWatermark(text: string): string {
  return `
    <svg xmlns="http://www.w3.org/2000/svg" width="300px" height="150px">
      <text x="50" y="90" 
            fill-opacity="0.1" 
            fill="#000" 
            transform="rotate(-30)"
            font-family="Arial" 
            font-size="20">${text}</text>
    </svg>`;
}

// 使用Base64编码
const svg = `data:image/svg+xml;utf8,${encodeURIComponent(generateSVGWatermark('内部资料'))}`;
```

## 三、防删除保护技术

### 1. MutationObserver监听
```typescript
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (!document.getElementById('secure-watermark')) {
      applyWatermark(); // 重新应用
    }
  });
});

observer.observe(document.body, {
  childList: true,
  subtree: true,
  attributes: true
});
```

### 2. 定时检查+重新应用
```typescript
setInterval(() => {
  const watermark = document.querySelector('.watermark');
  if (!watermark || watermark.children.length === 0) {
    applyWatermark();
  }
}, 1000);
```

### 3. 样式保护（防CSS修改）
```javascript
const watermark = document.getElementById('watermark');
Object.defineProperty(watermark.style, 'opacity', {
  value: 0.3,
  writable: false
});
```

## 四、隐形水印实现

### 1. LSB隐写算法
```typescript
function embedWatermark(imageData: ImageData, text: string): ImageData {
  const data = imageData.data;
  const binaryText = text.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join('');

  for (let i = 0; i < binaryText.length; i++) {
    const pixelIndex = i * 4;
    // 只修改RGB通道的最低有效位
    data[pixelIndex] = (data[pixelIndex] & 0xFE) | parseInt(binaryText[i]);
  }

  return imageData;
}
```

### 2. 频域水印（DCT变换）
```typescript
// 使用第三方库实现DCT变换
import { dct, idct } from 'image-dct';

function embedFrequencyWatermark(imageData: ImageData) {
  const channels = extractColorChannels(imageData);
  const dctData = dct(channels.red);
  // 在中频系数嵌入水印
  modifyDCTCoefficients(dctData);
  channels.red = idct(dctData);
  return combineChannels(channels);
}
```

## 五、React/Vue组件封装

### 1. React水印组件
```tsx
import React, { useEffect, useRef } from 'react';

interface WatermarkProps {
  text: string;
  density?: number;
  opacity?: number;
}

const Watermark: React.FC<WatermarkProps> = ({ 
  text, 
  density = 200, 
  opacity = 0.1 
}) => {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!ref.current) return;
  
    const canvas = document.createElement('canvas');
    canvas.width = density;
    canvas.height = density / 2;
  
    const ctx = canvas.getContext('2d')!;
    ctx.font = '14px Arial';
    ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
    ctx.rotate(-20 * Math.PI / 180);
    ctx.fillText(text, 10, canvas.height / 2);
  
    ref.current.style.backgroundImage = `url(${canvas.toDataURL()})`;
    ref.current.style.backgroundRepeat = 'repeat';
  }, [text, density, opacity]);

  return (
    <div 
      ref={ref}
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: 9999
      }}
    />
  );
};
```

### 2. Vue指令实现
```typescript
import { Directive } from 'vue';

const watermarkDirective: Directive = {
  mounted(el, binding) {
    const { text, angle = -20, fontSize = 16, opacity = 0.1 } = binding.value;
  
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 100;
  
    const ctx = canvas.getContext('2d')!;
    ctx.font = `${fontSize}px Arial`;
    ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
    ctx.rotate(angle * Math.PI / 180);
    ctx.fillText(text, 20, 60);
  
    el.style.backgroundImage = `url(${canvas.toDataURL()})`;
    el.style.backgroundRepeat = 'repeat';
  
    // 防删除保护
    const observer = new MutationObserver(() => {
      if (!el.style.backgroundImage.includes('canvas')) {
        el.style.backgroundImage = `url(${canvas.toDataURL()})`;
      }
    });
  
    observer.observe(el, { 
      attributes: true,
      attributeFilter: ['style']
    });
  }
};

export default watermarkDirective;
```

## 六、安全增强方案

### 1. 动态位置偏移
```typescript
function getRandomOffset(base: number, range: number): number {
  return base + Math.floor(Math.random() * range);
}

function applyDynamicWatermark() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d')!;

  // 每块水印随机偏移
  for (let x = 0; x < 5; x++) {
    for (let y = 0; y < 5; y++) {
      ctx.save();
      ctx.translate(x * 150 + getRandomOffset(0, 30), 
                   y * 80 + getRandomOffset(0, 20));
      ctx.rotate(-15 + Math.random() * 10);
      ctx.fillText('Confidential', 0, 0);
      ctx.restore();
    }
  }
}
```

### 2. 多图层混合
```css
.watermark-layer1 {
  background-image: url("data:image/svg+xml,...");
  mix-blend-mode: multiply;
}

.watermark-layer2 {
  background-image: url("data:image/svg+xml,...");
  mix-blend-mode: overlay;
}
```

## 七、性能优化策略

### 1. 离屏Canvas缓存
```typescript
let cachedWatermark: HTMLCanvasElement;

function getWatermark() {
  if (!cachedWatermark) {
    cachedWatermark = createWatermark('DEMO');
  }
  return cachedWatermark;
}
```

### 2. 按需渲染
```typescript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      applyWatermarkToElement(entry.target);
    }
  });
});

document.querySelectorAll('.watermarked').forEach(el => {
  observer.observe(el);
});
```

## 八、实际应用场景

### 1. 企业文档系统
```typescript
function applyUserWatermark(content: HTMLElement, user: User) {
  const watermarkText = `${user.name} ${user.department} ${new Date().toLocaleDateString()}`;
  const watermark = createDynamicWatermark(watermarkText);

  content.style.position = 'relative';
  content.appendChild(watermark);
}
```

### 2. 图片预览保护
```typescript
function protectImage(image: HTMLImageElement) {
  const canvas = document.createElement('canvas');
  canvas.width = image.naturalWidth;
  canvas.height = image.naturalHeight;

  const ctx = canvas.getContext('2d')!;
  ctx.drawImage(image, 0, 0);
  embedWatermark(ctx.getImageData(0, 0, canvas.width, canvas.height), 'COPYRIGHT');

  image.src = canvas.toDataURL('image/jpeg');
}
```

## 九、破解防护对策

### 1. 对抗控制台修改
```javascript
(function() {
  const originalCreateElement = document.createElement;
  document.createElement = function(tagName) {
    if (tagName.toLowerCase() === 'div') {
      console.warn('Watermark protection: Div creation monitored');
    }
    return originalCreateElement.apply(this, arguments);
  };
})();
```

### 2. 防截图插件检测
```typescript
function checkForScreenshotTools(): boolean {
  const plugins = Array.from(navigator.plugins);
  const blacklist = ['Snagit', 'Greenshot', 'ShareX'];

  return plugins.some(plugin => 
    blacklist.some(name => plugin.name.includes(name))
  );
}

if (checkForScreenshotTools()) {
  applyEnhancedWatermark();
}
```

前端水印技术需要平衡可见性、安全性和性能。在实际项目中，建议采用多层防御策略：
1. 基础DOM水印 + 2. 隐形像素水印 + 3. 动态用户信息绑定
   同时配合后端验证逻辑，形成完整的内容保护体系。
2. 定期更新水印算法和样式，以应对新的破解手段。
3. 结合用户行为分析，动态调整水印密度和样式，提高破解难度。
4. 使用WebAssembly等新技术提升水印处理性能，减少对页面渲染的影响。
5. 在敏感内容上使用多种水印技术组合，增加破解成本。
6. 结合区块链等技术实现水印存证，确保水印信息的不可篡改性。
7. 在移动端应用中，使用Canvas或SVG实现高清水印，避免图片质量损失。


## 十、现代水印进阶技术

### 1. WebGL 3D水印渲染
```typescript
class WebGLWatermark {
  private canvas: HTMLCanvasElement;
  private gl: WebGLRenderingContext;

  constructor(container: HTMLElement) {
    this.canvas = document.createElement('canvas');
    this.canvas.style.position = 'fixed';
    this.canvas.style.top = '0';
    this.canvas.style.pointerEvents = 'none';
    container.appendChild(this.canvas);
  
    this.gl = this.canvas.getContext('webgl')!;
    this.initWebGL();
  }

  private initWebGL() {
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
  
    const vsSource = `
      attribute vec2 coordinates;
      void main(void) {
        gl_Position = vec4(coordinates, 0.0, 1.0);
      }`;
  
    const fsSource = `
      precision highp float;
      uniform vec2 resolution;
      uniform float time;
      void main(void) {
        vec2 uv = gl_FragCoord.xy / resolution;
        uv = fract(uv * 10.0);
        float opacity = 0.3 * (0.5 + 0.5 * sin(time));
        gl_FragColor = vec4(0.5, 0.8, 1.0, opacity * step(0.9, uv.x));
      }`;
  
    // 编译着色器程序...
  }

  render() {
    this.gl.uniform1f(this.timeUniform, performance.now() / 1000);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(() => this.render());
  }
}
```

### 2. WASM高性能水印处理
```rust
// watermark.rs
#[wasm_bindgen]
pub fn embed_watermark(image_data: &mut [u8], text: &str) {
    let binary: Vec<u8> = text.bytes().collect();
    for (i, &byte) in binary.iter().enumerate() {
        let pixel_index = i * 4;
        if pixel_index + 3 < image_data.len() {
            image_data[pixel_index] = (image_data[pixel_index] & 0xFE) | ((byte >> 7) & 1);
            image_data[pixel_index+1] = (image_data[pixel_index+1] & 0xFE) | ((byte >> 6) & 1);
            // 继续处理其他位...
        }
    }
}
```

## 十一、全屏水印防护系统

### 1. 多图层防御架构
```typescript
class WatermarkDefender {
  private layers: WatermarkLayer[] = [];

  constructor(private options: WatermarkOptions) {
    this.initLayers();
  }

  private initLayers() {
    // 1. 基础CSS背景层
    this.layers.push(new BackgroundLayer(this.options));
  
    // 2. Canvas动态渲染层
    this.layers.push(new CanvasLayer(this.options));
  
    // 3. SVG高清层
    if (this.options.highQuality) {
      this.layers.push(new SVGLayer(this.options));
    }
  
    // 4. WebGL干扰层
    if (this.options.advancedMode) {
      this.layers.push(new WebGLLayer(this.options));
    }
  }

  activate() {
    this.layers.forEach(layer => layer.apply());
    this.setupProtection();
  }

  private setupProtection() {
    // 防DOM删除
    new MutationObserver(() => this.checkLayers())
      .observe(document, { subtree: true, childList: true });
  
    // 防样式修改
    setInterval(() => this.validateStyles(), 1000);
  }
}
```

### 2. 行为追踪水印
```typescript
class BehaviorTrackingWatermark {
  private mousePositions: [number, number][] = [];

  constructor(private canvas: HTMLCanvasElement) {
    document.addEventListener('mousemove', this.trackMouse.bind(this));
    setInterval(this.render.bind(this), 100);
  }

  private trackMouse(e: MouseEvent) {
    this.mousePositions.push([e.clientX, e.clientY]);
    if (this.mousePositions.length > 50) {
      this.mousePositions.shift();
    }
  }

  private render() {
    const ctx = this.canvas.getContext('2d')!;
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  
    // 绘制鼠标轨迹水印
    this.mousePositions.forEach(([x, y], i) => {
      ctx.fillStyle = `rgba(200, 100, 100, ${i/50})`;
      ctx.fillText(`USER_${x}${y}`, x + 10, y + 10);
    });
  }
}
```

## 十二、水印与DRM集成

### 1. 加密内容+水印方案
```typescript
async function loadProtectedContent(contentId: string) {
  // 1. 获取加密密钥
  const key = await fetchDRMKey(contentId);

  // 2. 解密内容
  const decrypted = await decryptContent(contentId, key);

  // 3. 应用动态水印
  const watermarked = applyDynamicWatermark(decrypted, {
    userId: getCurrentUser().id,
    timestamp: Date.now()
  });

  // 4. 渲染到安全容器
  renderToSecureContainer(watermarked);
}

function renderToSecureContainer(content: HTMLElement) {
  const container = document.getElementById('secure-viewer')!;
  container.innerHTML = '';
  container.appendChild(content);

  // 启用防护
  disableRightClick(container);
  disablePrintScreen();
  addContentProtectionObserver(container);
}
```

### 2. 视频内容水印
```typescript
class VideoWatermarker {
  private video: HTMLVideoElement;
  private canvas: HTMLCanvasElement;

  constructor(videoElement: HTMLVideoElement) {
    this.video = videoElement;
    this.canvas = document.createElement('canvas');
    this.setup();
  }

  private setup() {
    const context = this.canvas.getContext('2d')!;
  
    const renderFrame = () => {
      if (this.video.paused || this.video.ended) return;
    
      // 绘制当前视频帧
      context.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
    
      // 添加动态水印
      this.addWatermark(context);
    
      // 显示处理后的帧
      this.video.srcObject = this.canvas.captureStream();
    
      requestAnimationFrame(renderFrame);
    };
  
    this.video.addEventListener('play', () => {
      this.canvas.width = this.video.videoWidth;
      this.canvas.height = this.video.videoHeight;
      renderFrame();
    });
  }

  private addWatermark(ctx: CanvasRenderingContext2D) {
    const timestamp = new Date().toISOString();
    const userId = getCurrentUser().id;
  
    ctx.font = '20px Arial';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.fillText(`${userId} ${timestamp}`, 30, 50);
  
    // 添加隐形水印
    this.addInvisibleWatermark(ctx);
  }
}
```

## 十三、水印分析工具

### 1. 水印检测器
```typescript
class WatermarkDetector {
  static detectVisibleWatermark(element: HTMLElement): boolean {
    // 1. 检查背景图
    const bg = window.getComputedStyle(element).backgroundImage;
    if (/watermark|机密|copyright/i.test(bg)) return true;
  
    // 2. 检查覆盖元素
    const overlays = element.querySelectorAll('div, canvas, svg');
    for (const el of Array.from(overlays)) {
      const opacity = parseFloat(window.getComputedStyle(el).opacity);
      if (opacity > 0 && opacity < 0.5) return true;
    }
  
    // 3. 检查文字内容
    return this.analyzeTextContent(element);
  }

  private static analyzeTextContent(element: HTMLElement): boolean {
    const text = element.innerText;
    const patterns = [
      /机密/g, /内部/g, /copyright/gi, 
      /\d{4}-\d{2}-\d{2}/, // 日期
      /[A-Z]{2,}\d+/ // 用户ID模式
    ];
    return patterns.some(p => p.test(text));
  }
}
```

### 2. 隐形水印提取器
```typescript
function extractInvisibleWatermark(imageData: ImageData): string {
  let binary = '';
  const data = imageData.data;

  for (let i = 0; i < data.length; i += 4) {
    // 从RGB通道的LSB提取数据
    const r = data[i] & 1;
    const g = data[i+1] & 1;
    const b = data[i+2] & 1;
    binary += `${r}${g}${b}`;
  
    // 每8位组成一个字节
    if (binary.length >= 8) {
      const byte = binary.substring(0, 8);
      binary = binary.substring(8);
    
      const charCode = parseInt(byte, 2);
      if (charCode === 0) break; // 结束符
    
      result += String.fromCharCode(charCode);
    }
  }

  return result;
}
```

## 十四、跨平台水印方案

### 1. Electron应用水印
```typescript
// 主进程
import { app, BrowserWindow, ipcMain } from 'electron';

function createWindow() {
  const win = new BrowserWindow({
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false
    }
  });

  // 注入水印
  win.webContents.on('dom-ready', () => {
    win.webContents.executeJavaScript(`
      const watermark = document.createElement('div');
      watermark.style.cssText = \`
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background-image: url('data:image/svg...');
        z-index: 99999;
      \`;
      document.body.appendChild(watermark);
    `);
  });
}
```

### 2. React Native水印
```tsx
import { View, ImageBackground, Text } from 'react-native';

const WatermarkedView = ({ children }) => {
  const watermarkPattern = {
    uri: `data:image/svg+xml;utf8,${encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="300" height="200">
        <text x="50" y="100" fill-opacity="0.1" transform="rotate(-30)">机密</text>
      </svg>
    `)}`
  };

  return (
    <ImageBackground 
      source={watermarkPattern} 
      style={{ flex: 1 }}
      resizeMode="repeat"
    >
      {children}
    </ImageBackground>
  );
};
```

## 十五、水印性能优化

### 1. Web Worker处理
```typescript
// watermark.worker.ts
self.onmessage = function(e) {
  const { imageData, watermarkText } = e.data;

  // 在Worker中进行CPU密集型计算
  const processed = applyWatermarkToImageData(imageData, watermarkText);

  self.postMessage(processed, [processed.data.buffer]);
};

function applyWatermarkToImageData(imageData: ImageData, text: string): ImageData {
  // 实现水印算法...
}

// 主线程使用
const worker = new Worker('watermark.worker.ts');
worker.postMessage({ imageData, watermarkText }, [imageData.data.buffer]);
worker.onmessage = (e) => updateCanvas(e.data);
```

### 2. 分层渲染策略
```typescript
class WatermarkScheduler {
  private urgentLayer: WatermarkLayer;
  private normalLayers: WatermarkLayer[];

  constructor(layers: WatermarkLayer[]) {
    this.urgentLayer = layers.find(l => l.priority === 'high')!;
    this.normalLayers = layers.filter(l => l.priority !== 'high');
  
    this.scheduleRender();
  }

  private scheduleRender() {
    // 立即渲染高优先级层
    this.urgentLayer.render();
  
    // 空闲时渲染其他层
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() => this.renderNormalLayers());
    } else {
      setTimeout(() => this.renderNormalLayers(), 1000);
    }
  }

  private renderNormalLayers() {
    this.normalLayers.forEach(layer => {
      if (layer.shouldRender()) {
        layer.render();
      }
    });
  }
}
```

## 十六、水印的未来发展

### 1. AI生成自适应水印
```typescript
class AIWatermarkGenerator {
  async generate(context: HTMLElement): Promise<WatermarkStyle> {
    // 1. 分析内容特征
    const contentAnalysis = await analyzeContent(context);
  
    // 2. 生成最佳水印参数
    return {
      text: this.generateDynamicText(contentAnalysis),
      opacity: this.calculateOptimalOpacity(contentAnalysis),
      density: this.calculateDensity(contentAnalysis),
      colorScheme: this.getColorScheme(contentAnalysis)
    };
  }

  private async analyzeContent(element: HTMLElement) {
    // 使用计算机视觉分析内容区域
    const screenshot = await html2canvas(element);
    const analysis = await fetchAIAPI(screenshot);
    return {
      textAreas: analysis.text_regions,
      importantRegions: analysis.salient_regions,
      colorHistogram: analysis.colors
    };
  }
}
```

### 2. 区块链水印存证
```typescript
async function registerWatermark(contentHash: string, watermark: string) {
  // 生成水印元数据
  const metadata = {
    contentHash,
    watermark,
    timestamp: new Date().toISOString(),
    owner: getCurrentUser().address
  };

  // 存储到IPFS
  const cid = await ipfs.add(JSON.stringify(metadata));

  // 上链存证
  const contract = new ethers.Contract(...);
  await contract.registerWatermark(contentHash, cid, {
    from: getCurrentUser().address
  });

  return cid;
}
```

前端水印技术正在从简单的视觉标记发展为包含多重防护、行为追踪和智能适应的综合内容保护系统。随着WebAssembly、WebGPU等新技术的发展，未来水印技术将实现更高的安全性和更低的性能开销。在实际应用中，建议根据业务需求选择适当的水印策略组合，并定期更新防护机制以应对新的破解手段。
