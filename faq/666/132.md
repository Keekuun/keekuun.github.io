## 132. SPA 首屏加载速度慢怎么解决

SPA（单页应用）的首屏加载速度慢是一个常见问题，主要原因包括 **资源体积过大**、**网络请求过多**、**渲染阻塞** 等。以下是系统化的解决方案，涵盖 **代码优化**、**网络优化** 和 **渲染优化** 等多个维度：

---

## 🌟 **核心优化方向**
| **问题类型**       | **优化手段**                          | **效果预估**               |
|--------------------|-------------------------------------|---------------------------|
| **资源体积过大**   | 代码分割 + 压缩                      | 减少 30%~50% 体积         |
| **网络请求过多**   | HTTP/2 + 资源预加载                  | 减少 40%+ 请求时间         |
| **渲染阻塞**       | 骨架屏 + 服务端渲染 (SSR)            | 提升用户感知速度 50%+      |
| **第三方库臃肿**   | 按需引入 + 替换轻量库                | 减少 20%~30% 代码          |

---

## 🛠 **具体优化方案**

### 📌 **1. 代码体积优化**
#### ✅ **代码分割（Code Splitting）**
通过动态导入（Dynamic Import）拆分代码，按需加载路由组件：
```typescript
// React 示例（使用 React.lazy）
const Home = React.lazy(() => import('./Home'));
const About = React.lazy(() => import('./About'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  );
}
```
**工具支持**：
- Webpack 的 `SplitChunksPlugin` 自动拆分公共依赖。
- 使用 `@loadable/component` 更精细控制加载（支持 SSR）。

---

#### ✅ **Tree Shaking**
移除未使用的代码（对 ESM 模块有效）：
```javascript
// webpack.config.js
module.exports = {
  optimization: {
    usedExports: true, // 标记未使用代码
    minimize: true,   // 启用 TerserPlugin 删除死代码
  }
};
```
**注意**：确保 `package.json` 中设置 `"sideEffects": false`。

---

#### ✅ **压缩资源**
- **JavaScript**：`TerserPlugin`
- **CSS**：`CssMinimizerPlugin`
- **HTML**：`HtmlWebpackPlugin` 的 `minify` 选项
- **图片**：`image-webpack-loader`（自动压缩 PNG/JPEG）

```javascript
// 图片压缩示例
rules: [
  {
    test: /\.(png|jpe?g)$/,
    use: [
      'file-loader',
      {
        loader: 'image-webpack-loader',
        options: {
          mozjpeg: { quality: 60 }, // JPEG 质量 60%
        },
      },
    ],
  },
]
```

---

### 📌 **2. 网络优化**
#### ✅ **启用 HTTP/2**
- 服务器配置 HTTP/2（如 Nginx 的 `listen 443 http2`）。
- 利用多路复用减少请求延迟。

---

#### ✅ **资源预加载**
使用 `<link rel="preload">` 提前加载关键资源：
```html
<!-- 预加载关键 CSS/JS -->
<link rel="preload" href="critical.css" as="style" />
<link rel="preload" href="main.js" as="script" />
```
**自动化工具**：
- `preload-webpack-plugin` 自动生成预加载标签。

---

#### ✅ **CDN 加速**
- 将静态资源（如 JS/CSS/图片）托管到 CDN。
- 第三方库通过 CDN 引入（如 `unpkg.com`）。

---

### 📌 **3. 渲染优化**
#### ✅ **骨架屏（Skeleton Screen）**
在内容加载前展示占位图，提升用户体验：
```tsx
// 骨架屏组件示例
const Skeleton = () => (
  <div className="skeleton">
    <div className="skeleton-header" />
    <div className="skeleton-body" />
  </div>
);

// 使用
<Suspense fallback={<Skeleton />}>
  <LazyComponent />
</Suspense>
```
**工具推荐**：`react-loading-skeleton`。

---

#### ✅ **服务端渲染（SSR）**
通过 Next.js 或自定义 SSR 方案直出 HTML：
```javascript
// Next.js 示例（默认支持 SSR）
export async function getServerSideProps() {
  const data = await fetchAPI();
  return { props: { data } };
}

function Page({ data }) {
  return <div>{data}</div>;
}
```
**优势**：首屏直接渲染，无需等待客户端 JS 执行。

---

### 📌 **4. 第三方库优化**
#### ✅ **按需引入**
- **Ant Design**：`babel-plugin-import`
  ```javascript
  // .babelrc
  plugins: [
    ['import', { libraryName: 'antd', style: 'css' }]
  ]
  ```
- **Lodash**：直接引入单函数
  ```javascript
  import debounce from 'lodash/debounce'; // 而非整个 lodash
  ```

---

#### ✅ **替换轻量库**
| **原库**       | **替代方案**       | **体积减少** |
|----------------|-------------------|-------------|
| `Moment.js`    | `date-fns`        | 80%+        |
| `Lodash`       | `lodash-es`       | 50%+        |
| `Axios`        | `Fetch API`       | 100%        |

---

### 📌 **5. 监控与分析**
#### ✅ **性能分析工具**
- **Lighthouse**：综合评分与优化建议。
- **Webpack Bundle Analyzer**：可视化分析包体积。
  ```bash
  npx webpack --profile --json > stats.json
  npx webpack-bundle-analyzer stats.json
  ```

---

#### ✅ **性能监控**
- **CLS（布局偏移）**：使用 `web-vitals` 库监控。
- **FP/FCP（首次渲染）**：通过 `PerformanceObserver` 上报。

```typescript
import { getCLS, getFID, getFCP } from 'web-vitals';

getCLS(console.log); // 监控布局偏移
```

---

## 🎯 **优化效果对比**
| **优化前**       | **优化后**         | **提升幅度** |
|------------------|-------------------|-------------|
| 4MB JS 文件      | 1.5MB（Gzip 后）  | 60%+        |
| 10+ 网络请求     | 4~5 个（HTTP/2）  | 50%+        |
| 3s 首屏渲染      | 1s 内（SSR）      | 70%+        |

---

## 📦 **实战配置示例**
### **Webpack 生产配置**
```javascript
// webpack.prod.js
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin(),
      new CssMinimizerPlugin(),
    ],
    splitChunks: {
      chunks: 'all', // 自动拆分 node_modules
    },
  },
  plugins: [
    new PreloadWebpackPlugin({
      rel: 'preload',
      include: 'initial',
    }),
  ],
};
```

### **Nginx 配置（Gzip + HTTP/2）**
```nginx
server {
  listen 443 ssl http2;
  gzip on;
  gzip_types text/css application/javascript;
}
```

---

## 🚀 **总结**
通过 **代码分割**、**资源压缩**、**预加载** 和 **渲染优化** 等组合策略，SPA 首屏加载速度可显著提升。关键步骤：
1. **分析瓶颈**：用 Lighthouse 定位问题。
2. **渐进优化**：从代码体积到网络层逐级优化。
3. **持续监控**：上线后跟踪核心指标（如 FCP）。

> 💡 **终极方案**：对于极致性能要求，考虑 SSR 或静态生成（如 Next.js）。