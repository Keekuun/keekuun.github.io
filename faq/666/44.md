## 44. 什么是领域模型

# 领域模型（Domain Model）详解

领域模型是软件开发中用于表示业务领域核心概念及其关系的抽象模型，是领域驱动设计（DDD）的核心组成部分。

## 一、领域模型的核心概念

1. **定义**：领域模型是对业务领域的抽象表示，捕获业务中的：
    - 关键实体（Entities）
    - 值对象（Value Objects）
    - 业务规则（Business Rules）
    - 交互流程（Workflows）

2. **与数据模型的区别**：
   ```typescript
   // 数据模型（关注存储）
   interface UserTable {
     id: number;
     name: string;
     email: string;
     created_at: Date;
   }

   // 领域模型（关注业务）
   class User {
     constructor(
       private id: UserId,
       private name: UserName,
       private email: Email,
       private registrationDate: DateTime
     ) {}

     changeEmail(newEmail: Email) {
       this.email = newEmail;
       DomainEvents.publish(new UserEmailChanged(this.id, newEmail));
     }
   }
   ```

## 二、领域模型的组成要素

### 1. 实体（Entities）
```typescript
class Order implements Entity<OrderId> {
  constructor(
    public readonly id: OrderId,
    private items: OrderItem[],
    private status: OrderStatus
  ) {}

  addItem(product: Product, quantity: number) {
    // 业务规则验证
    if (this.status !== OrderStatus.DRAFT) {
      throw new Error("Cannot modify submitted order");
    }
  
    this.items.push(new OrderItem(product, quantity));
  }
}
```

### 2. 值对象（Value Objects）
```typescript
class Address implements ValueObject {
  constructor(
    public readonly street: string,
    public readonly city: string,
    public readonly postalCode: string
  ) {}

  equals(other: Address): boolean {
    return this.street === other.street &&
           this.city === other.city &&
           this.postalCode === other.postalCode;
  }
}
```

### 3. 聚合根（Aggregate Roots）
```typescript
class ShoppingCart implements AggregateRoot {
  private constructor(
    public readonly id: CartId,
    private items: CartItem[],
    private userId: UserId
  ) {}

  static create(userId: UserId): ShoppingCart {
    return new ShoppingCart(CartId.generate(), [], userId);
  }

  addItem(product: Product): void {
    // 保持聚合内部一致性
    const existingItem = this.items.find(i => i.productId.equals(product.id));
  
    if (existingItem) {
      existingItem.increaseQuantity();
    } else {
      this.items.push(CartItem.create(product));
    }
  }
}
```

## 三、构建领域模型的实践方法

### 1. 统一语言（Ubiquitous Language）
```typescript
// 使用业务术语定义模型
class FundTransfer {
  constructor(
    private source: AccountNumber,
    private target: AccountNumber,
    private amount: Money,
    private transactionTime: DateTime
  ) {}

  execute(): TransactionResult {
    // 使用业务语言的方法命名
    if (this.source.hasSufficientBalance(this.amount)) {
      return this.processTransfer();
    }
    return TransactionResult.failed("Insufficient balance");
  }
}
```

### 2. 领域服务（Domain Services）
```typescript
class OrderProcessingService {
  constructor(
    private orderRepository: OrderRepository,
    private inventoryService: InventoryService
  ) {}

  async fulfillOrder(orderId: OrderId): Promise<void> {
    const order = await this.orderRepository.findById(orderId);
  
    // 领域逻辑
    if (order.canBeFulfilled()) {
      await this.inventoryService.reserveItems(order.items);
      order.markAsFulfilled();
      await this.orderRepository.save(order);
    }
  }
}
```

## 四、领域模型的实现模式

### 1. 贫血模型 vs 充血模型
```typescript
// 贫血模型（不推荐）
class Order {
  public items: OrderItem[];
  public status: string;
}

class OrderService {
  calculateTotal(order: Order): number {
    return order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }
}

// 充血模型（推荐）
class RichOrder {
  constructor(private items: OrderItem[], private status: OrderStatus) {}

  calculateTotal(): number {
    return this.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }
}
```

### 2. 领域事件（Domain Events）
```typescript
class OrderCancelled implements DomainEvent {
  constructor(
    public readonly orderId: OrderId,
    public readonly reason: string,
    public readonly occurredOn: Date = new Date()
  ) {}
}

class Order {
  // ...

  cancel(reason: string) {
    this.status = OrderStatus.CANCELLED;
    DomainEvents.publish(new OrderCancelled(this.id, reason));
  }
}
```

## 五、领域模型的应用场景

### 1. 复杂业务系统
```typescript
// 电商领域模型示例
class ECommerceDomain {
  // 核心聚合
  private products: Product[];
  private customers: Customer[];
  private orders: Order[];

  // 领域服务
  private pricingService: PricingService;
  private inventoryService: InventoryService;

  placeOrder(customerId: CustomerId, items: OrderItem[]): Order {
    // 复杂的业务逻辑处理
    const customer = this.customers.find(c => c.id.equals(customerId));
    const order = new Order(OrderId.generate(), customerId, items);
  
    // 应用业务规则
    this.pricingService.applyDiscounts(order, customer);
    this.inventoryService.checkAvailability(order);
  
    return order;
  }
}
```

### 2. 微服务架构中的领域模型
```typescript
// 支付微服务领域模型
class PaymentDomain {
  private payments: Payment[];
  private accounts: Account[];

  processPayment(
    paymentId: PaymentId,
    amount: Money,
    source: AccountNumber,
    target: AccountNumber
  ): PaymentResult {
    // 支付领域专有逻辑
    const payment = new Payment(paymentId, amount, source, target);
  
    if (this.fraudDetectionService.check(payment)) {
      return PaymentResult.failed("Fraud detected");
    }
  
    this.transferService.executeTransfer(payment);
    return PaymentResult.success(payment);
  }
}
```

## 六、领域模型的演进策略

### 1. 模型上下文划分（Bounded Context）
```typescript
// 用户在不同上下文中的模型
class IdentityUser {  // 认证上下文
  constructor(
    public username: string,
    public passwordHash: string,
    public roles: string[]
  ) {}
}

class SalesCustomer {  // 销售上下文
  constructor(
    public customerId: string,
    public contactInfo: ContactDetails,
    public purchaseHistory: Order[]
  ) {}
}
```

### 2. 模型版本管理
```typescript
// 使用适配器处理模型演进
class LegacyOrderAdapter {
  adaptToNewModel(legacyOrder: LegacyOrder): Order {
    return new Order(
      OrderId.fromString(legacyOrder.id),
      legacyOrder.items.map(item => 
        new OrderItem(
          ProductId.fromString(item.productId),
          item.quantity,
          new Money(item.price, 'USD')
        )
      ),
      new CustomerId(legacyOrder.customerId)
    );
  }
}
```

领域模型是连接业务需求与技术实现的关键桥梁，好的领域模型应该：
1. 准确反映业务概念和流程
2. 封装核心业务规则
3. 保持清晰的边界和职责
4. 提供明确的业务接口
5. 能够随着业务需求演进

在实际项目中，建议通过事件风暴（Event Storming）等方法与业务专家共同构建领域模型，并持续通过测试驱动开发（TDD）来验证模型的正确性。
