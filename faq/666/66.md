## 66. JS 执行 100 万个任务，如何保证浏览器不卡顿？

在 JavaScript 中执行 100 万个任务时，如果不加以优化，可能会导致主线程阻塞、浏览器卡顿（甚至页面崩溃）。以下是几种核心解决方案和优化策略：

---

## **1. 任务分片（Chunking）**
将大任务拆分为多个小任务，分批次执行，避免长时间阻塞主线程。

### **实现方式**
#### **(1) 使用 `setTimeout` 或 `setInterval`**
```typescript
function processChunk(tasks: any[], index: number = 0, chunkSize: number = 1000) {
  const end = Math.min(index + chunkSize, tasks.length);
  for (let i = index; i < end; i++) {
    processTask(tasks[i]); // 执行单个任务
  }
  if (end < tasks.length) {
    setTimeout(() => processChunk(tasks, end, chunkSize), 0); // 下一批次
  }
}

processChunk(Array(1e6).fill(null)); // 启动任务
```

#### **(2) 使用 `requestIdleCallback`（更适合低优先级任务）**
```typescript
function processIdleChunk(tasks: any[], index: number = 0) {
  if (index >= tasks.length) return;
  requestIdleCallback((deadline) => {
    while (deadline.timeRemaining() > 0 && index < tasks.length) {
      processTask(tasks[index++]);
    }
    processIdleChunk(tasks, index); // 继续处理剩余任务
  });
}
```

✅ **优点**：
- 主线程可处理用户交互，避免卡顿。
- 兼容性好（`setTimeout` 所有浏览器支持）。

❌ **缺点**：
- `setTimeout` 的延迟不精确，可能仍有轻微卡顿。

---

## **2. Web Workers（多线程）**
将计算密集型任务放到后台线程，不阻塞主线程。

### **实现步骤**
#### **(1) 创建 Worker 脚本（`worker.js`）**
```javascript
// worker.js
self.onmessage = function (e) {
  const tasks = e.data;
  const results = tasks.map(processTask); // 处理任务
  self.postMessage(results); // 返回结果
};
```

#### **(2) 主线程调用**
```typescript
const worker = new Worker('worker.js');
worker.postMessage(Array(1e6).fill(null)); // 发送任务

worker.onmessage = function (e) {
  console.log('Results:', e.data); // 接收结果
};
```

✅ **优点**：
- 彻底避免主线程卡顿。
- 适合 CPU 密集型任务（如加密、大数据处理）。

❌ **缺点**：
- 无法直接操作 DOM。
- 通信开销较大（需序列化数据）。

---

## **3. 异步迭代（Generator + Promise）**
结合生成器和异步函数，分批次处理任务。

### **实现代码**
```typescript
async function processTasksAsync(tasks: any[], chunkSize: number = 1000) {
  for (let i = 0; i < tasks.length; i += chunkSize) {
    const chunk = tasks.slice(i, i + chunkSize);
    await Promise.all(chunk.map(processTask)); // 并行处理
    await new Promise(resolve => setTimeout(resolve, 0)); // 释放主线程
  }
}

processTasksAsync(Array(1e6).fill(null));
```

✅ **优点**：
- 支持并行处理（`Promise.all`）。
- 代码可读性高。

❌ **缺点**：
- 并行任务过多仍可能卡顿。

---

## **4. 时间切片（Time Slicing）**
利用 `requestAnimationFrame` 或 `requestIdleCallback` 在浏览器空闲时执行任务。

### **示例代码**
```typescript
function processTimeSlice(tasks: any[], index: number = 0) {
  if (index >= tasks.length) return;
  requestAnimationFrame(() => {
    const start = performance.now();
    while (performance.now() - start < 10 && index < tasks.length) { // 每帧最多执行 10ms
      processTask(tasks[index++]);
    }
    processTimeSlice(tasks, index);
  });
}
```

✅ **优点**：
- 与浏览器渲染帧率同步，用户体验流畅。

❌ **缺点**：
- 实现较复杂。

---

## **5. 性能优化技巧**
### **(1) 减少重复计算**
- 使用缓存（如 Memoization）避免重复处理相同数据。
- 预处理数据（如排序、哈希）。

### **(2) 避免频繁 DOM 操作**
- 批量更新 DOM（如文档片段 `DocumentFragment`）。
- 使用虚拟 DOM 库（如 React、Vue）。

### **(3) 使用高效数据结构**
- 换用 `Map`/`Set` 替代普通对象，提升查找速度。
- 对大数据使用 `TypedArray`（如 `Uint32Array`）。

### **(4) 垃圾回收优化**
- 及时释放不再使用的变量（设为 `null`）。
- 避免内存泄漏（如未清除的定时器、闭包）。

---

## **6. 方案对比**
| **方法**            | **适用场景**                | **是否阻塞主线程** | **实现难度** |
|---------------------|----------------------------|--------------------|--------------|
| **任务分片**        | 通用场景                   | 否                 | 低           |
| **Web Workers**     | CPU 密集型任务             | 否                 | 中           |
| **异步迭代**        | 需要并行处理               | 部分阻塞           | 中           |
| **时间切片**        | 动画/高优先级任务          | 否                 | 高           |

---

## **7. 实战建议**
1. **简单任务**：用 `setTimeout` 分片。
2. **复杂计算**：优先选 **Web Workers**。
3. **动画相关**：用 `requestAnimationFrame` 时间切片。
4. **兼容性要求高**：分片 + 降级策略。

---

## **8. 完整示例（分片 + Worker 结合）**
```typescript
// 主线程
const worker = new Worker('worker.js');
const tasks = Array(1e6).fill(null);
let index = 0;

function scheduleChunk() {
  const chunk = tasks.slice(index, index + 1000);
  if (chunk.length === 0) return;
  worker.postMessage(chunk);
  index += 1000;
  setTimeout(scheduleChunk, 0); // 继续调度
}

scheduleChunk();
```

通过以上方法，可以高效执行海量任务而不卡顿浏览器！ 🚀