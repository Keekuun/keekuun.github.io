## 122. IndexedDB 存储空间大小是如何约束的？

IndexedDB 的存储空间大小约束涉及 **浏览器策略**、**用户授权** 和 **存储机制** 等多个维度。以下是详细解析和技术实践建议（基于最新浏览器规范和实际测试数据）：

---

## 🌟 **核心约束因素**
| **因素**               | **典型值/规则**                          | **备注**                          |
|------------------------|----------------------------------------|-----------------------------------|
| **浏览器默认限制**     | 50% 磁盘剩余空间（Chrome）             | 动态调整，无固定上限              |
| **单域名限制**         | 60% 浏览器全局配额（约 80% 磁盘剩余空间）| 不同浏览器实现不同                |
| **用户授权机制**       | 超过阈值需用户确认                     | 类似 Notification 权限弹窗       |
| **临时存储 vs 持久存储**| 临时存储可被自动清理，持久存储需显式申请 | 通过 `storage.persist()` 申请     |

---

## 🛠 **详细约束规则**
### 📌 **1. 浏览器全局配额**
- **Chrome/Edge**
    - 总配额 = 磁盘剩余空间的 50%
    - 单域名默认上限 = 总配额的 60%（例如磁盘剩余 100GB → 单域名最多 30GB）
    - **实际测试**：在 256GB SSD 设备上，单域名可用约 20GB（动态调整）

- **Firefox**
    - 固定单域名限制为 **2GB**（需用户授权突破）

- **Safari**
    - 默认 **1GB**，超过后弹窗申请

---

### 📌 **2. 用户授权流程**
#### ✅ **临时存储（无需授权）**
- 初始使用时自动分配空间（通常为几 MB 到几百 MB）
- 可能被浏览器自动清理（如磁盘空间不足时）

#### ✅ **持久存储（需显式授权）**
```typescript
// 申请持久化存储（返回 Promise<boolean>）
async function requestPersistence() {
  if (navigator.storage && navigator.storage.persist) {
    const isPersisted = await navigator.storage.persist();
    console.log(`持久化存储授权: ${isPersisted ? '成功' : '失败'}`);
    return isPersisted;
  }
  return false;
}
```
**用户触发条件**：
- 存储超过初始阈值（Chrome 约为 50MB）
- 调用 `persist()` 时可能直接弹窗

---

### 📌 **3. 查询配额和使用量**
```typescript
// 获取当前域名可用配额和已用量
async function checkStorageQuota() {
  if (navigator.storage && navigator.storage.estimate) {
    const { quota, usage } = await navigator.storage.estimate();
    console.log(`配额: ${(quota / 1024 / 1024).toFixed(2)}MB`);
    console.log(`已用: ${(usage / 1024 / 1024).toFixed(2)}MB`);
    return { quota, usage };
  }
  return { quota: 0, usage: 0 };
}
```
**输出示例**：
```bash
配额: 5120.00MB  # 5GB
已用: 243.76MB   # 243MB
```

---

## 🚀 **优化与最佳实践**
### ✅ **1. 监控存储状态**
```typescript
// 监听存储压力事件（浏览器可能清理数据时触发）
navigator.storage.addEventListener('quotachange', () => {
  console.warn('存储配额即将耗尽，建议清理数据');
});
```

### ✅ **2. 清理策略**
```typescript
// 根据 LRU（最近最少使用）清理旧数据
function cleanupOldData(dbName: string, maxAge: number) {
  const request = indexedDB.open(dbName);
  request.onsuccess = (event) => {
    const db = event.target.result;
    const tx = db.transaction('yourStore', 'readwrite');
    const store = tx.objectStore('yourStore');
    const cutoff = Date.now() - maxAge;

    store.openCursor().onsuccess = (e) => {
      const cursor = e.target.result;
      if (cursor && cursor.value.timestamp < cutoff) {
        store.delete(cursor.primaryKey);
      }
      cursor?.continue();
    };
  };
}
```

### ✅ **3. 错误处理**
```typescript
// 捕获空间不足错误
const request = indexedDB.open('largeDB', { version: 1 });
request.onerror = (event) => {
  if (event.target.error.name === 'QuotaExceededError') {
    alert('存储空间不足，请清理数据或申请更多空间');
  }
};
```

---

## 🛡️ **兼容性注意事项**
| **浏览器**       | **关键差异**                              |
|------------------|-----------------------------------------|
| Chrome/Edge      | 动态配额，支持 `storage.estimate()`      |
| Firefox          | 固定 2GB 限制，需早期版本 polyfill       |
| Safari           | 严格限制，私有模式禁用 IndexedDB          |

---

## 📦 **完整示例：存储管理工具类**
```typescript
class StorageManager {
  private dbName: string;

  constructor(dbName: string) {
    this.dbName = dbName;
  }

  async ensurePersistent(): Promise<boolean> {
    if (!navigator.storage?.persist) return false;
    return await navigator.storage.persist();
  }

  async getQuota(): Promise<{ quota: number; usage: number }> {
    if (!navigator.storage?.estimate) return { quota: 0, usage: 0 };
    return await navigator.storage.estimate();
  }

  async cleanupOldData(maxAgeMs: number): Promise<void> {
    // 实现参考上文 LRU 清理逻辑
  }
}

// 使用
const manager = new StorageManager('myDB');
await manager.ensurePersistent();
const { quota } = await manager.getQuota();
```

---

## 🎯 **关键决策点**
1. **是否需要持久化？**
    - 是 → 调用 `storage.persist()` 并引导用户授权
    - 否 → 接受临时存储可能被清理

2. **数据敏感性**
    - 重要数据 → 实现定期备份到服务器
    - 缓存数据 → 设置自动清理策略

3. **目标用户设备**
    - 移动端 → 谨慎使用（Safari/低端机限制严格）
    - 桌面端 → 可申请更大空间

---

通过合理设计，IndexedDB 可支持 **GB 级** 结构化数据存储，适用于离线应用、大型数据集缓存等场景！ 🚀