## 77. 如何统计长任务时间、长任务执行次数

在前端性能监控中，**长任务（Long Task）** 是指执行时间超过 **50ms** 的任务（如 JavaScript 执行、DOM 渲染等），它们可能导致主线程阻塞，影响用户体验。以下是统计长任务时间和执行次数的完整方案：

---

## **1. 使用 PerformanceObserver API**
现代浏览器提供了 [`PerformanceObserver`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver) API，可以监听长任务。

### **✅ 监听长任务**
```typescript
const observer = new PerformanceObserver((list) => {
  const entries = list.getEntries();
  entries.forEach((entry) => {
    console.log(
      `长任务执行时间: ${entry.duration.toFixed(2)}ms`,
      `触发来源: ${entry.attribution[0]?.name || 'unknown'}`,
    );
  });
});

observer.observe({ type: 'longtask', buffered: true });
```

### **✅ 统计长任务次数**
```typescript
let longTaskCount = 0;

const observer = new PerformanceObserver(() => {
  longTaskCount++;
  console.log(`当前长任务次数: ${longTaskCount}`);
});

observer.observe({ type: 'longtask', buffered: true });
```

---

## **2. 手动计算任务时间**
如果浏览器不支持 `PerformanceObserver`，可以通过 `setTimeout` 或 `requestAnimationFrame` 近似统计。

### **✅ 使用 setTimeout 检测阻塞**
```typescript
let lastTime = performance.now();

function checkLongTask() {
  const now = performance.now();
  const duration = now - lastTime;

  if (duration > 50) {
    console.log(`疑似长任务: ${duration.toFixed(2)}ms`);
  }

  lastTime = now;
  setTimeout(checkLongTask, 0);
}

checkLongTask();
```

### **✅ 使用 requestAnimationFrame**
```typescript
let lastFrameTime = performance.now();

function detectLongFrame() {
  const now = performance.now();
  const frameDuration = now - lastFrameTime;

  if (frameDuration > 50) {
    console.log(`长帧耗时: ${frameDuration.toFixed(2)}ms`);
  }

  lastFrameTime = now;
  requestAnimationFrame(detectLongFrame);
}

detectLongFrame();
```

---

## **3. 结合 Performance API 分析**
通过 `performance.getEntriesByType('longtask')` 获取已发生的长任务数据：
```typescript
const longTasks = performance.getEntriesByType('longtask');
console.log(`总长任务次数: ${longTasks.length}`);
longTasks.forEach((task) => {
  console.log(`任务耗时: ${task.duration.toFixed(2)}ms`);
});
```

---

## **4. 上报数据到监控系统**
将长任务数据上报到监控平台（如 Sentry、自建服务）：
```typescript
const observer = new PerformanceObserver((list) => {
  const entries = list.getEntries();
  entries.forEach((entry) => {
    fetch('/api/monitor', {
      method: 'POST',
      body: JSON.stringify({
        type: 'longtask',
        duration: entry.duration,
        timestamp: Date.now(),
      }),
    });
  });
});

observer.observe({ type: 'longtask', buffered: true });
```

---

## **5. 可视化长任务分布**
使用柱状图或火焰图展示长任务分布（借助库如 `Chart.js` 或 `Perfume.js`）：
```typescript
import Perfume from 'perfume.js';

const perfume = new Perfume({
  analyticsTracker: ({ metricName, duration }) => {
    if (metricName === 'longtask') {
      console.log(`长任务耗时: ${duration}ms`);
    }
  },
});
```

---

## **6. 优化长任务的常见方法**
| **问题类型**       | **优化方案**                              |
|--------------------|------------------------------------------|
| JavaScript 执行过长 | 代码拆分、Web Workers、任务分片          |
| DOM 操作过多       | 批量更新（虚拟 DOM）、减少布局抖动       |
| 第三方脚本阻塞     | 异步加载、延迟执行（`defer`/`async`）    |

---

## **7. 兼容性注意事项**
- `PerformanceObserver` 兼容性：Chrome 58+、Firefox 55+、Edge 79+。
- 降级方案：在不支持的浏览器中使用 `setTimeout` 近似检测。

---

## **8. 完整代码示例**
```typescript
class LongTaskMonitor {
  private count = 0;

  start() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        this.count += entries.length;
        this.report(entries);
      });
      observer.observe({ type: 'longtask', buffered: true });
    } else {
      this.fallbackDetection();
    }
  }

  private report(entries: PerformanceEntryList) {
    entries.forEach((entry) => {
      console.log('[LongTask]', `Duration: ${entry.duration}ms`);
    });
    console.log(`[LongTask] Total count: ${this.count}`);
  }

  private fallbackDetection() {
    let lastTime = performance.now();
    const check = () => {
      const now = performance.now();
      if (now - lastTime > 50) {
        this.count++;
        console.log('[Fallback LongTask]', `Duration: ${now - lastTime}ms`);
      }
      lastTime = now;
      setTimeout(check, 0);
    };
    check();
  }
}

const monitor = new LongTaskMonitor();
monitor.start();
```

---

## **总结**
- **核心工具**：`PerformanceObserver`（首选）或 `setTimeout`（降级）。
- **监控指标**：单次长任务时间、累计次数、来源标签。
- **优化方向**：拆分任务、减少主线程阻塞。

通过以上方法，可以全面统计和分析长任务，为性能优化提供数据支撑！ 📊