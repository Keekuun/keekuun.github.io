## 59. [React] 如何进行路由变化监听

在 React 应用中监听路由变化是常见的需求（如埋点统计、权限控制、动态标题等）。以下是针对不同路由方案的完整解决方案（以 React Router v6 为例）：

---

### 🌟 **核心监听方案**
#### 1. **使用 `useLocation` + `useEffect`（函数组件推荐）**
```tsx
import { useEffect } from 'react'
import { useLocation } from 'react-router-dom'

function RouteListener() {
  const location = useLocation()

  useEffect(() => {
    // 路由变化时触发
    console.log('路由变化:', location.pathname, location.search)
  
    // 执行埋点上报
    trackPageView(location.pathname)
  
    // 动态修改标题
    document.title = getTitleByPath(location.pathname)
  }, [location]) // 依赖 location 对象

  return null
}

// 在根组件中使用
<Router>
  <RouteListener />
  <App />
</Router>
```

#### 2. **类组件中通过 HOC 包装**
```tsx
import { withRouter } from './withRouter' // 自定义 HOC

class RouteTracker extends React.Component {
  componentDidUpdate(prevProps) {
    if (this.props.location !== prevProps.location) {
      console.log('路由变化:', this.props.location)
    }
  }

  render() {
    return null
  }
}

// 使用自定义 withRouter（React Router v6 不再提供官方 HOC）
export function withRouter(Component) {
  return (props) => {
    const location = useLocation()
    return <Component {...props} location={location} />
  }
}

// 使用
const EnhancedTracker = withRouter(RouteTracker)
```

---

### 🔍 **监听特定路由变化**
#### 场景：当进入 `/admin` 时检查权限
```tsx
useEffect(() => {
  if (location.pathname.startsWith('/admin')) {
    checkAdminPermission().catch(() => navigate('/login'))
  }
}, [location.pathname])
```

---

### 📜 **History 对象直接监听（通用方案）**
适用于非 React Router 场景或需要更底层控制的情况：
```tsx
import { useEffect } from 'react'
import { useNavigate } from 'react-router-dom'

function HistoryListener() {
  const navigate = useNavigate()

  useEffect(() => {
    // 保存原始 pushState 方法
    const originalPushState = window.history.pushState

    // 重写 pushState
    window.history.pushState = function (...args) {
      originalPushState.apply(window.history, args)
      console.log('路由变化（pushState）:', window.location.href)
    }

    // 监听 popstate（浏览器前进/后退）
    const handlePopState = () => {
      console.log('路由变化（popstate）:', window.location.href)
    }

    window.addEventListener('popstate', handlePopState)

    return () => {
      window.history.pushState = originalPushState // 恢复原方法
      window.removeEventListener('popstate', handlePopState)
    }
  }, [])

  return null
}
```

---

### 🛡️ **路由守卫实现**
封装高阶组件实现全局路由拦截：
```tsx
function AuthRoute({ children }) {
  const location = useLocation()
  const [isAllowed, setIsAllowed] = useState(false)

  useEffect(() => {
    checkAuth(location.pathname).then(setIsAllowed)
  }, [location])

  return isAllowed ? children : <Loading />
}

// 使用
<Route path="/dashboard" element={<AuthRoute><Dashboard /></AuthRoute>} />
```

---

### ⚠️ **注意事项**
1. **避免无限循环**：
   在路由监听回调中谨慎使用 `navigate`，需添加条件判断：
   ```tsx
   useEffect(() => {
     if (!isLogin && location.pathname !== '/login') {
       navigate('/login') // 避免重复跳转
     }
   }, [location])
   ```

2. **性能优化**：
   对高频操作（如滚动恢复）使用防抖：
   ```tsx
   import { debounce } from 'lodash'

   useEffect(() => {
     const handleScroll = debounce(() => {
       saveScrollPosition(location.key)
     }, 300)
   
     window.addEventListener('scroll', handleScroll)
     return () => window.removeEventListener('scroll', handleScroll)
   }, [location.key])
   ```

3. **SSR 兼容性**：
   服务端渲染时需特殊处理 `window` 对象：
   ```tsx
   useEffect(() => {
     if (typeof window !== 'undefined') {
       // 客户端代码
     }
   }, [])
   ```

---

### 🔧 **调试技巧**
在开发时打印完整路由信息：
```tsx
useEffect(() => {
  console.log('路由变更详情:', {
    pathname: location.pathname,
    search: location.search,
    hash: location.hash,
    state: location.state // 可通过 navigate('/path', { state: { key: value } }) 传递
  })
}, [location])
```

---

### 🌐 **各版本 React Router 对比**
| 功能               | v5 及之前           | v6                   |
|--------------------|--------------------|----------------------|
| 获取路由信息       | `withRouter` HOC   | `useLocation` hook   |
| 编程式导航         | `useHistory`       | `useNavigate`        |
| 监听所有路由变化   | 监听 history 对象  | `useLocation` 依赖   |
| 路由守卫           | 自定义 `<Route>`   | `useLocation` + 条件 |

---

### 📌 **最佳实践建议**
1. **优先使用 React Router 原生 hooks**（v6 的 `useLocation`/`useNavigate`）
2. **敏感操作放在最外层路由监听**（如权限校验）
3. **对第三方路由库**（如 Next.js），使用其提供的路由事件：
   ```tsx
   // Next.js 示例
   import { useRouter } from 'next/router'

   useEffect(() => {
     const handleRouteChange = (url) => {
       console.log('导航至:', url)
     }
     router.events.on('routeChangeComplete', handleRouteChange)
     return () => router.events.off('routeChangeComplete', handleRouteChange)
   }, [router])
   ```

4. **TypeScript 类型增强**：
   ```tsx
   import { Location } from 'react-router-dom'

   declare module 'react-router-dom' {
     interface Location {
       from?: string // 自定义扩展 state 类型
     }
   }
   ```

根据你的具体场景选择合适方案，通常组合使用 `useLocation` + `useEffect` 即可覆盖大多数需求。