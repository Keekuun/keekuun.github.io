## 114. 你认为组件封装的一些基本准则是什么？

组件封装是前端工程化的核心，好的封装能提升 **代码复用性**、**可维护性** 和 **团队协作效率**。以下是基于实战总结的组件封装准则（附 TypeScript 示例）：

---

### 🧩 **1. 单一职责原则（SRP）**
**准则**：一个组件只做一件事，避免成为“上帝组件”。
**示例**：
```tsx
// Bad: 混杂了列表渲染和搜索逻辑
const UserListWithSearch = () => { /* ... */ };

// Good: 拆分为两个组件
const UserSearch = () => { /* ... */ };
const UserList = ({ users }) => { /* ... */ };
```

---

### 🔌 **2. 明确 Props 设计**
**准则**：
- **类型安全**：用 TypeScript 定义清晰的接口。
- **默认值**：通过 `defaultProps` 或解构默认值提供兜底。
- **控制反转**：将状态管理权交给父组件（受控组件）。

**示例**：
```tsx
interface ButtonProps {
  type?: "primary" | "secondary";
  size?: "sm" | "md" | "lg";
  onClick?: () => void;
}

const Button = ({ type = "primary", size = "md", onClick }: ButtonProps) => {
  return <button className={`btn-${type} btn-${size}`} onClick={onClick} />;
};
```

---

### 🛡️ **3. 高内聚低耦合**
**准则**：
- **内部状态隔离**：避免直接暴露组件内部状态（如 `ref`）。
- **依赖最小化**：减少对全局状态（如 Redux）的依赖，优先通过 Props 通信。

**示例**：
```tsx
// Bad: 内部依赖全局状态
const CartBadge = () => {
  const { cartItems } = useStore(); // ❌ 耦合度高
  return <span>{cartItems.length}</span>;
};

// Good: 通过 Props 传入数据
interface CartBadgeProps {
  count: number;
}
const CartBadge = ({ count }: CartBadgeProps) => <span>{count}</span>;
```

---

### ♻️ **4. 支持组合（Composition）**
**准则**：
- **使用 `children` 或 `slots`**：灵活插入内容。
- **Render Props 模式**：动态注入渲染逻辑。

**示例**：
```tsx
// 组合示例
const Card = ({ children }: { children: React.ReactNode }) => (
  <div className="card">{children}</div>
);

// Render Props 示例
const Dropdown = ({ renderItem }: { renderItem: (item: string) => ReactNode }) => {
  const items = ["A", "B", "C"];
  return <div>{items.map(renderItem)}</div>;
};
```

---

### 📚 **5. 文档与示例**
**准则**：
- **写清晰的文档**：描述 Props、Events、Slots 和用例。
- **提供 Storybook 示例**：可视化展示组件行为。

**示例**：
```markdown
## Button 组件

### Props
| 参数     | 类型                | 默认值    | 说明         |
|----------|---------------------|-----------|--------------|
| type     | "primary"｜"secondary" | "primary" | 按钮类型     |
| onClick  | `() => void`        | -         | 点击事件回调 |

### 示例
```tsx
<Button type="secondary" onClick={() => alert("Clicked!")} />
```

---

### 🧪 **6. 可测试性**
**准则**：
- **隔离副作用**：将 API 调用抽离到自定义 Hook。
- **注入 Mock 数据**：便于单元测试。

**示例**：
```tsx
// 可测试的组件
const UserList = ({ fetchUsers }: { fetchUsers: () => Promise<User[]> }) => {
  const [users, setUsers] = useState<User[]>([]);
  useEffect(() => {
    fetchUsers().then(setUsers);
  }, []);
  return <ul>{users.map(user => <li key={user.id}>{user.name}</li>)}</ul>;
};

// 测试用例
test("UserList renders users", async () => {
  const mockFetch = jest.fn().mockResolvedValue([{ id: 1, name: "Alice" }]);
  render(<UserList fetchUsers={mockFetch} />);
  await waitFor(() => expect(screen.getByText("Alice")).toBeInTheDocument());
});
```

---

### 🎨 **7. 样式隔离**
**准则**：
- **CSS-in-JS**：使用 `styled-components` 或 `emotion` 避免全局污染。
- **Scoped CSS**：Vue 的 `<style scoped>` 或 CSS Modules。

**示例**：
```tsx
// styled-components 示例
const StyledButton = styled.button<{ $type: ButtonProps["type"] }>`
  background: ${props => (props.$type === "primary" ? "blue" : "gray")};
`;

const Button = ({ type }: ButtonProps) => (
  <StyledButton $type={type}>Click</StyledButton>
);
```

---

### 🔄 **8. 版本兼容与破坏性变更**
**准则**：
- **语义化版本（SemVer）**：遵循 `MAJOR.MINOR.PATCH` 规则。
- **废弃警告**：用 `deprecated` 注释逐步迁移。

**示例**：
```tsx
// v1.0.0
const OldButton = () => <button className="old-style" />;

// v2.0.0 (带废弃警告)
/**
 * @deprecated 请使用新版本 `<Button>` 组件
 */
const OldButton = () => <button className="old-style" />;
```

---

### 📊 **总结：组件封装 Checklist**
| 准则                | 关键点                          | 工具/技术               |
|---------------------|--------------------------------|------------------------|
| 单一职责            | 拆分复杂逻辑                   | React/Vue 组件拆分      |
| Props 设计          | 类型安全 + 默认值              | TypeScript             |
| 组合模式            | `children` / Render Props      | React Slots / Vue Slots |
| 文档化              | Storybook / MDX                | Storybook              |
| 测试                | 隔离副作用 + Mock              | Jest / Testing Library |
| 样式隔离            | CSS-in-JS / Scoped CSS         | styled-components      |

---

通过遵循这些准则，你的组件库将具备：

✅ **高复用性** — 像乐高一样灵活组合

✅ **低维护成本** — 修改一个组件不影响其他部分

✅ **团队友好** — 新人能快速理解设计意图

封装组件不仅是技术活，更是艺术！ 🎨