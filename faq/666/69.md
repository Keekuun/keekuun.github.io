## 69. 虚拟滚动加载原理是什么，用「React」代码简单实现一个虚拟滚动加载。

虚拟滚动（Virtual Scrolling）是一种优化长列表渲染性能的技术，通过 **仅渲染可视区域内的元素** 来减少 DOM 节点数量，从而大幅提升性能。以下是其核心原理和实现：

---

## **1. 虚拟滚动原理**
### **(1) 核心思想**
- **可视区域渲染**：只渲染用户当前可见的部分内容。
- **动态计算位置**：通过滚动位置动态计算需要渲染的起始和结束索引。
- **占位容器**：用空白区域（或占位元素）模拟完整列表的高度。

### **(2) 关键步骤**
1. **计算可视区域**：
    - 获取容器高度（`containerHeight`）和每个项的高度（`itemHeight`）。
    - 计算可视区域能显示的项数：`visibleCount = Math.ceil(containerHeight / itemHeight)`。

2. **动态渲染项**：
    - 根据滚动位置（`scrollTop`）计算起始索引：
      `startIndex = Math.floor(scrollTop / itemHeight)`
    - 结束索引：`endIndex = startIndex + visibleCount`。

3. **占位区域**：
    - 上方占位高度：`startIndex * itemHeight`。
    - 下方占位高度：`(totalCount - endIndex) * itemHeight`。

---

## **2. 代码实现**
以下是一个简单的虚拟滚动实现（使用 TypeScript + React）：

```tsx
import React, { useState, useRef, useEffect } from 'react';

interface VirtualScrollProps {
  itemHeight: number; // 每项高度
  totalCount: number; // 总项数
  renderItem: (index: number) => React.ReactNode; // 渲染单项的函数
  containerHeight: number; // 容器高度
}

const VirtualScroll: React.FC<VirtualScrollProps> = ({
  itemHeight,
  totalCount,
  renderItem,
  containerHeight,
}) => {
  const [startIndex, setStartIndex] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  // 计算可视区域能显示的项数
  const visibleCount = Math.ceil(containerHeight / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, totalCount - 1);

  // 处理滚动事件
  const handleScroll = () => {
    if (containerRef.current) {
      const { scrollTop } = containerRef.current;
      const newStartIndex = Math.floor(scrollTop / itemHeight);
      setStartIndex(newStartIndex);
    }
  };

  // 初始化容器高度
  useEffect(() => {
    if (containerRef.current) {
      containerRef.current.style.height = `${containerHeight}px`;
    }
  }, [containerHeight]);

  return (
    <div
      ref={containerRef}
      style={{
        overflowY: 'auto',
        border: '1px solid #ccc',
        position: 'relative',
      }}
      onScroll={handleScroll}
    >
      {/* 上方占位区域 */}
      <div style={{ height: `${startIndex * itemHeight}px` }}></div>

      {/* 渲染可视区域内的项 */}
      {Array.from({ length: endIndex - startIndex + 1 }).map((_, index) => {
        const itemIndex = startIndex + index;
        return (
          <div key={itemIndex} style={{ height: `${itemHeight}px` }}>
            {renderItem(itemIndex)}
          </div>
        );
      })}

      {/* 下方占位区域 */}
      <div
        style={{
          height: `${(totalCount - endIndex - 1) * itemHeight}px`,
        }}
      ></div>
    </div>
  );
};

// 使用示例
const App: React.FC = () => {
  const items = Array.from({ length: 10000 }, (_, i) => `Item ${i + 1}`);

  return (
    <VirtualScroll
      itemHeight={50}
      totalCount={items.length}
      containerHeight={500}
      renderItem={(index) => <div>{items[index]}</div>}
    />
  );
};

export default App;
```

---

## **3. 关键点解析**
1. **性能优化**：
    - 无论列表多长，实际渲染的 DOM 节点数仅为 `visibleCount + 2`（占位区域）。
    - 滚动时只更新 `startIndex`，触发局部重新渲染。

2. **动态高度支持**：
    - 如果项高度不固定，需先计算并缓存所有项的高度（复杂实现需用 `ResizeObserver`）。

3. **扩展功能**：
    - **滚动缓冲**：可提前渲染部分额外项（如 `startIndex - 5` 到 `endIndex + 5`），避免快速滚动时空白。
    - **异步加载**：结合分页加载数据（如滚动到底部时加载更多）。

---

## **4. 对比传统滚动**
| **特性**         | **传统滚动**               | **虚拟滚动**               |
|------------------|---------------------------|---------------------------|
| **DOM 节点数**   | 全部渲染（性能差）         | 仅渲染可视区域（性能优）   |
| **内存占用**     | 高                        | 低                        |
| **适用场景**     | 少量数据                  | 长列表（如表格、聊天记录） |

---

## **5. 现有库推荐**
- **React**：`react-window`、`react-virtualized`。
- **Vue**：`vue-virtual-scroller`。
- **原生 JS**：`IntersectionObserver` 实现动态渲染。

---

通过虚拟滚动，即使是百万级数据的列表也能流畅渲染！ 🚀