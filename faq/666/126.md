## 126. [React] 如何避免不必要的渲染？

在 React 中，避免不必要的渲染是优化性能的关键之一。以下是一些常见的方法和技巧，帮助你减少不必要的渲染：

---

### 1. **使用 `React.memo` 进行组件记忆**
`React.memo` 是一个高阶组件，用于对函数组件进行浅比较（shallow comparison），避免在 props 未变化时重新渲染。

```tsx
import React from 'react';

const MyComponent = React.memo(({ name }: { name: string }) => {
  console.log('MyComponent 渲染');
  return <div>{name}</div>;
});

// 使用示例
const App = () => {
  const [count, setCount] = React.useState(0);
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>点击 {count}</button>
      <MyComponent name="固定值" /> {/* 不会因 count 变化而重新渲染 */}
    </div>
  );
};
```

---

### 2. **使用 `useMemo` 缓存计算结果**
`useMemo` 可以缓存计算结果，避免在依赖项未变化时重复计算。

```tsx
import React from 'react';

const ExpensiveComponent = ({ list }: { list: number[] }) => {
  const sum = React.useMemo(() => {
    console.log('重新计算 sum');
    return list.reduce((acc, num) => acc + num, 0);
  }, [list]); // 仅在 list 变化时重新计算

  return <div>总和: {sum}</div>;
};
```

---

### 3. **使用 `useCallback` 缓存函数**
`useCallback` 可以缓存函数，避免因父组件重新渲染导致子组件的函数引用变化。

```tsx
import React from 'react';

const ChildComponent = React.memo(({ onClick }: { onClick: () => void }) => {
  console.log('ChildComponent 渲染');
  return <button onClick={onClick}>点击我</button>;
});

const ParentComponent = () => {
  const [count, setCount] = React.useState(0);

  const handleClick = React.useCallback(() => {
    console.log('点击事件');
  }, []); // 依赖项为空，函数引用不变

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>更新父组件 {count}</button>
      <ChildComponent onClick={handleClick} /> {/* 不会因父组件更新而重新渲染 */}
    </div>
  );
};
```

---

### 4. **避免在 `JSX` 中直接定义对象或函数**
在 `JSX` 中直接定义对象或函数会导致每次渲染时都生成新的引用，可能触发子组件的不必要渲染。

```tsx
// ❌ 不推荐
<ChildComponent style={{ color: 'red' }} onClick={() => console.log('点击')} />

// ✅ 推荐
const style = { color: 'red' };
const handleClick = () => console.log('点击');
<ChildComponent style={style} onClick={handleClick} />
```

---

### 5. **使用 `shouldComponentUpdate`（类组件）**
如果是类组件，可以通过 `shouldComponentUpdate` 手动控制是否重新渲染。

```tsx
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps) {
    // 仅当 name 变化时才重新渲染
    return nextProps.name !== this.props.name;
  }

  render() {
    return <div>{this.props.name}</div>;
  }
}
```

---

### 6. **避免不必要的状态更新**
确保 `setState` 只在数据实际变化时调用。

```tsx
const [user, setUser] = React.useState({ name: 'Alice', age: 25 });

// ❌ 不推荐（即使 name 未变化也会触发渲染）
setUser({ ...user, name: 'Alice' });

// ✅ 推荐（仅在 name 变化时更新）
if (user.name !== 'Alice') {
  setUser({ ...user, name: 'Alice' });
}
```

---

### 7. **使用 `React DevTools` 检测渲染**
通过 React DevTools 的 **Highlight Updates** 功能，可以直观地看到哪些组件在重新渲染。

---

### 8. **避免滥用 Context**
`Context` 的更新会触发所有消费者组件的重新渲染。可以通过以下方式优化：
- 将 `Context` 拆分为多个小的 `Context`。
- 使用 `useMemo` 或 `useCallback` 缓存 `Context` 提供的值。

```tsx
const UserContext = React.createContext();

const UserProvider = ({ children }) => {
  const [user, setUser] = React.useState({ name: 'Alice', age: 25 });

  const value = React.useMemo(() => ({ user, setUser }), [user]);

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
};
```

---

### 9. **使用 `React.lazy` 和 `Suspense` 按需加载组件**
通过代码分割（code splitting）减少初始加载时的渲染压力。

```tsx
const LazyComponent = React.lazy(() => import('./LazyComponent'));

const App = () => (
  <React.Suspense fallback={<div>加载中...</div>}>
    <LazyComponent />
  </React.Suspense>
);
```

---

### 总结
- **记忆化**：`React.memo`、`useMemo`、`useCallback`。
- **避免不必要的引用变化**：不要在 `JSX` 中直接定义对象或函数。
- **手动控制渲染**：`shouldComponentUpdate` 或条件更新状态。
- **工具辅助**：使用 React DevTools 检测渲染。
- **优化 Context**：拆分或缓存 `Context` 值。

通过这些方法，可以有效减少不必要的渲染，提升 React 应用的性能！ 🚀