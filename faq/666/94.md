## 94. 应用上线后，怎么通知用户刷新当前页面？

在应用上线后，通知用户刷新当前页面是一个常见的需求，尤其是在发布了重要更新或修复了关键 Bug 时。以下是几种实现方案，涵盖不同场景和技术手段：

---

## **1. 轮询检测版本更新**
### **原理**
- 前端定期向服务器发送请求，检查当前版本是否过期。
- 如果版本不一致，提示用户刷新页面。

### **实现代码**
```typescript
// 版本检测逻辑
const checkVersion = async () => {
  const currentVersion = '1.0.0'; // 当前版本（可打包时注入或从 meta 读取）
  const response = await fetch('/api/version');
  const { latestVersion } = await response.json();

  if (currentVersion !== latestVersion) {
    showRefreshNotification();
  }
};

// 轮询检测（每 5 分钟一次）
setInterval(checkVersion, 5 * 60 * 1000);
```

### **优点**
- 实现简单，适用于静态资源更新。

### **缺点**
- 频繁请求可能增加服务器压力。

---

## **2. WebSocket 实时通知**
### **原理**
- 通过 WebSocket 建立长连接，服务端主动推送更新通知。
- 适合需要实时性高的场景（如多人协作应用）。

### **实现代码**
```typescript
// 前端监听 WebSocket
const socket = new WebSocket('wss://example.com/ws');

socket.addEventListener('message', (event) => {
  const data = JSON.parse(event.data);
  if (data.type === 'RELOAD') {
    showRefreshNotification();
  }
});
```

### **优点**
- 实时性强，用户体验好。

### **缺点**
- 需要维护 WebSocket 服务。

---

## **3. Service Worker 缓存控制**
### **原理**
- 使用 Service Worker 拦截请求并检测资源是否更新。
- 如果发现新版本，提示用户刷新。

### **实现代码**
```typescript
// Service Worker 逻辑（sw.js）
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('my-cache').then((cache) => {
      return cache.addAll(['/index.html', '/app.js']);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      if (response) {
        return response;
      }
      return fetch(event.request);
    })
  );
});

// 检测更新并提示
self.addEventListener('message', (event) => {
  if (event.data === 'SKIP_WAITING') {
    self.skipWaiting().then(() => {
      // 通知页面刷新
      clients.matchAll().then((clients) => {
        clients.forEach((client) => client.postMessage('RELOAD'));
      });
    });
  }
});
```

### **前端监听更新**
```typescript
// 注册 Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').then((registration) => {
    registration.addEventListener('updatefound', () => {
      const newWorker = registration.installing;
      newWorker.addEventListener('statechange', () => {
        if (newWorker.state === 'installed') {
          showRefreshNotification();
        }
      });
    });
  });
}
```

### **优点**
- 离线可用，适合 PWA 应用。

### **缺点**
- 实现较复杂，需处理缓存策略。

---

## **4. 利用 `document.title` 或 Favicon 提示**
### **原理**
- 动态修改页面标题或 Favicon，吸引用户注意。
- 结合倒计时或闪烁效果增强提示。

### **实现代码**
```typescript
let isBlinking = false;

const showTitleNotification = () => {
  const originalTitle = document.title;
  let count = 0;

  const interval = setInterval(() => {
    document.title = isBlinking 
      ? '⚠️ 请刷新页面以获取更新！' 
      : originalTitle;
    isBlinking = !isBlinking;

    if (count++ >= 10) {
      clearInterval(interval);
      document.title = originalTitle;
    }
  }, 500);
};
```

### **优点**
- 无需用户交互即可引起注意。

### **缺点**
- 可能干扰用户体验。

---

## **5. 强制刷新（最后一招）**
### **原理**
- 如果用户长时间未操作，直接强制刷新页面。
- 通过 `localStorage` 或 `sessionStorage` 记录刷新状态。

### **实现代码**
```typescript
const forceRefreshIfNeeded = () => {
  const lastUpdate = localStorage.getItem('lastUpdate');
  const currentVersion = '1.0.0';

  if (!lastUpdate || lastUpdate !== currentVersion) {
    localStorage.setItem('lastUpdate', currentVersion);
    window.location.reload(true); // 强制刷新（忽略缓存）
  }
};
```

### **适用场景**
- 关键更新必须立即生效时。

### **缺点**
- 用户体验较差，可能导致数据丢失。

---

## **6. 优雅的 UI 提示**
### **实现代码**
```typescript
const showRefreshNotification = () => {
  const notification = document.createElement('div');
  notification.style.position = 'fixed';
  notification.style.bottom = '20px';
  notification.style.right = '20px';
  notification.style.padding = '10px';
  notification.style.backgroundColor = '#ff9800';
  notification.style.color = 'white';
  notification.style.borderRadius = '5px';
  notification.style.zIndex = '1000';
  notification.innerHTML = `
    <p>新版本已发布，请刷新页面以获取更新！</p>
    <button style="margin-top: 5px; padding: 5px 10px; background: white; color: #ff9800; border: none; border-radius: 3px;">
      立即刷新
    </button>
  `;

  notification.querySelector('button').addEventListener('click', () => {
    window.location.reload();
  });

  document.body.appendChild(notification);
};
```

### **优点**
- 用户体验友好，可自定义样式。

---

## **总结**
| **方案**               | **适用场景**                  | **优点**                     | **缺点**                     |
|------------------------|-----------------------------|-----------------------------|-----------------------------|
| 轮询检测版本           | 静态资源更新                 | 简单易实现                   | 频繁请求服务器               |
| WebSocket 实时通知      | 高实时性需求（如协作应用）    | 即时性强                     | 需维护 WebSocket 服务        |
| Service Worker         | PWA 或离线应用               | 离线可用，可控性强           | 实现复杂                     |
| 修改标题/Favicon       | 轻量级提示                   | 无需用户交互                 | 可能干扰用户                 |
| 强制刷新               | 关键更新必须立即生效          | 确保更新生效                 | 用户体验差                   |
| 优雅的 UI 提示         | 通用场景                     | 用户体验友好                 | 需用户手动操作               |

### **推荐组合**
1. **普通 Web 应用**：轮询检测 + 优雅 UI 提示。
2. **实时应用**：WebSocket + Service Worker。
3. **PWA**：Service Worker 自动更新 + 提示。

根据项目需求选择最适合的方案，平衡用户体验和技术成本！ 🚀