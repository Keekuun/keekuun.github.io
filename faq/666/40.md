## 40. 扫码登录实现方式

# 扫码登录实现方案详解

扫码登录已成为现代应用常见的身份验证方式，以下是完整的实现方案和技术细节：

## 一、扫码登录核心流程

1. **流程时序图**
```
用户端         服务端         手机端
  |              |              |
  |-- 获取二维码 -->|              |
  |<-- 返回二维码 --|              |
  |              |              |
  |              |<-- 扫码确认 ---|
  |              |--- 验证登录 -->|
  |<-- 登录成功 --|              |
```

## 二、服务端实现

### 1. 生成二维码（Node.js示例）
```typescript
import * as QRCode from 'qrcode';
import { v4 as uuidv4 } from 'uuid';

// 存储待验证的二维码
const pendingLogins = new Map();

async function generateQRCode() {
  const token = uuidv4(); // 生成唯一标识
  const url = `https://yoursite.com/auth/confirm?token=${token}`;

  // 生成二维码图片
  const qrCode = await QRCode.toDataURL(url);

  // 存储token，设置5分钟过期
  pendingLogins.set(token, {
    status: 'pending',
    expiresAt: Date.now() + 300000
  });

  return { token, qrCode };
}

// 定时清理过期的二维码
setInterval(() => {
  const now = Date.now();
  for (const [token, data] of pendingLogins) {
    if (data.expiresAt < now) {
      pendingLogins.delete(token);
    }
  }
}, 60000);
```

### 2. 轮询接口设计（Express示例）
```typescript
import express from 'express';
const app = express();

app.get('/auth/status/:token', (req, res) => {
  const { token } = req.params;
  const data = pendingLogins.get(token);

  if (!data) {
    return res.status(404).json({ error: '二维码已过期' });
  }

  res.json({
    status: data.status,
    user: data.user || null
  });
});
```

## 三、移动端实现

### 1. 扫码处理

+ Android示例（Java）
```java
// 使用ZXing库处理二维码
public void handleQRCodeScan(String qrContent) {
    Uri uri = Uri.parse(qrContent);
    String token = uri.getQueryParameter("token");
  
    // 调用确认登录API
    ApiClient.confirmLogin(token, new Callback() {
        @Override
        public void onSuccess(LoginResponse response) {
            showToast("登录成功");
        }
      
        @Override
        public void onFailure(Error error) {
            showToast("登录失败: " + error.getMessage());
        }
    });
}
```

+ flutter代码示例（dart）：
```dart
import 'package:flutter/material.dart';
import 'package:qr_code_scanner/qr_code_scanner.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
class QRLoginPage extends StatefulWidget {
  @override
  _QRLoginPageState createState() => _QRLoginPageState();
}
class _QRLoginPageState extends State<QRLoginPage> {
  final GlobalKey qrKey = GlobalKey(debugLabel: 'QR');
  QRViewController? controller;

  @override
  void reassemble() {
    super.reassemble();
    if (controller != null) {
      controller!.pauseCamera();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('扫码登录')),
      body: QRView(
        key: qrKey,
        onQRViewCreated: _onQRViewCreated,
      ),
    );
  }

  void _onQRViewCreated(QRViewController controller) {
    this.controller = controller;
    controller.scannedDataStream.listen((scanData) async {
      final token = scanData.code;
      if (token != null) {
        final response = await http.post(
          Uri.parse('https://yoursite.com/auth/confirm'),
          body: json.encode({'token': token}),
          headers: {'Content-Type': 'application/json'},
        );
        if (response.statusCode == 200) {
          // 登录成功处理
          showDialog(context: context, builder: (_) => AlertDialog(content: Text('登录成功')));
        } else {
          // 登录失败处理
          showDialog(context: context, builder: (_) => AlertDialog(content: Text('登录失败')));
        }
      }
    });
  }

  @override
  void dispose() {
    controller?.dispose();
    super.dispose();
  }
}
```

### 2. 确认登录API
+ Android示例（Kotlin）
```kotlin
@POST("/auth/confirm")
suspend fun confirmLogin(
    @Body request: ConfirmRequest
): Response<AuthResponse> {
    // 验证用户是否已登录移动端
    if (!userSession.isAuthenticated()) {
        return Response.error(401, "请先登录APP")
    }
  
    // 更新二维码状态
    val updated = qrCodeService.confirmLogin(
        token = request.token,
        userId = userSession.getUserId()
    )
  
    if (!updated) {
        return Response.error(404, "二维码已过期")
    }
  
    return Response.success(
        AuthResponse(userSession.getAuthToken())
    )
}
```

+ Swift示例（iOS）
```swift
import UIKit
import Alamofire
class QRLoginViewController: UIViewController {
    var token: String?

    func confirmLogin() {
        guard let token = token else { return }
        
        let url = "https://yoursite.com/auth/confirm"
        let parameters: [String: Any] = ["token": token]
        
        AF.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default)
            .responseJSON { response in
                switch response.result {
                case .success(let value):
                    print("登录成功: \(value)")
                case .failure(let error):
                    print("登录失败: \(error.localizedDescription)")
                }
            }
    }
}
```

+ flutter代码示例（dart）
```dart
import 'package:http/http.dart' as http;
import 'dart:convert';

Future<void> confirmLogin(String token) async {
  final response = await http.post(
    Uri.parse('https://yoursite.com/auth/confirm'),
    headers: {'Content-Type': 'application/json'},
    body: json.encode({'token': token}),
  );

  if (response.statusCode == 200) {
    // 登录成功处理
    print('登录成功');
  } else {
    // 登录失败处理
    print('登录失败: ${response.body}');
  }
}
```

## 四、Web前端实现

### 1. 获取并显示二维码（React示例）
```tsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function QRLogin() {
  const [qrCode, setQrCode] = useState('');
  const [token, setToken] = useState('');
  const [status, setStatus] = useState('pending');

  useEffect(() => {
    // 获取二维码
    const fetchQRCode = async () => {
      const { data } = await axios.get('/auth/qrcode');
      setQrCode(data.qrCode);
      setToken(data.token);
    
      // 开始轮询状态
      const interval = setInterval(async () => {
        const { data } = await axios.get(`/auth/status/${data.token}`);
        setStatus(data.status);
      
        if (data.status === 'confirmed') {
          clearInterval(interval);
          handleLoginSuccess(data.user);
        }
      }, 2000);
    
      return () => clearInterval(interval);
    };
  
    fetchQRCode();
  }, []);

  return (
    <div className="qr-login">
      {status === 'pending' && (
        <>
          <img src={qrCode} alt="扫描二维码登录" />
          <p>请使用APP扫码登录</p>
        </>
      )}
      {status === 'confirmed' && <p>登录成功！</p>}
    </div>
  );
}
```

### 2. WebSocket实时通知方案
```typescript
// 服务端
import WebSocket from 'ws';

const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  ws.on('message', (token) => {
    // 监听移动端确认后广播给对应客户端
    broadcastToToken(ws, token);
  });
});

// 客户端
const socket = new WebSocket('wss://yoursite.com');

function setupWebSocket(token) {
  socket.onopen = () => {
    socket.send(JSON.stringify({ type: 'subscribe', token }));
  };

  socket.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (data.type === 'login_confirmed') {
      // 处理登录成功
    }
  };
}
```

## 五、安全增强措施

### 1. 防重放攻击

> 什么是防重放攻击？
> 
> 防重放攻击是指通过对请求进行签名和验证，确保请求的唯一性和时效性，防止攻击者截获并重放合法请求。

```typescript
// 生成带签名的二维码URL
function generateSignedURL(token: string): string {
  const timestamp = Date.now();
  const nonce = crypto.randomBytes(8).toString('hex');
  const data = `${token}:${timestamp}:${nonce}`;

  const hmac = crypto.createHmac('sha256', SECRET_KEY);
  hmac.update(data);
  const signature = hmac.digest('hex');

  return `https://yoursite.com/auth/confirm?token=${token}&ts=${timestamp}&nonce=${nonce}&sig=${signature}`;
}

// 验证签名
function verifySignature(query: any): boolean {
  const { token, ts, nonce, sig } = query;
  const data = `${token}:${ts}:${nonce}`;

  const hmac = crypto.createHmac('sha256', SECRET_KEY);
  hmac.update(data);
  const expectedSig = hmac.digest('hex');

  return sig === expectedSig && 
         Date.now() - parseInt(ts) < 300000; // 5分钟内有效
}
```

### 2. 设备绑定
```typescript
// 扫码时绑定设备信息
function confirmLogin(token: string, user: User) {
  const loginData = pendingLogins.get(token);
  if (!loginData) return false;

  // 记录设备指纹
  const deviceFingerprint = generateDeviceFingerprint(
    user.currentDevice
  );

  loginData.status = 'confirmed';
  loginData.user = user;
  loginData.deviceFingerprint = deviceFingerprint;

  return true;
}

// 生成设备指纹
function generateDeviceFingerprint(device: Device): string {
  const { os, browser, ip } = device;
  const str = `${os}|${browser}|${ip}`;
  return crypto.createHash('sha1').update(str).digest('hex');
}
```

## 六、性能优化方案

### 1. 二维码过期策略
```typescript
// 分级过期策略
const QR_EXPIRE_STRATEGY = {
  // 初始阶段：快速轮询（2秒）
  FRESH: { ttl: 60000, pollInterval: 2000 },
  // 中期阶段：中等轮询（5秒）
  MID: { ttl: 240000, pollInterval: 5000 },
  // 最后阶段：慢速轮询（10秒）
  OLD: { ttl: 300000, pollInterval: 10000 }
};

function getPollStrategy(createdAt: number) {
  const elapsed = Date.now() - createdAt;

  if (elapsed < QR_EXPIRE_STRATEGY.FRESH.ttl) {
    return QR_EXPIRE_STRATEGY.FRESH;
  } else if (elapsed < QR_EXPIRE_STRATEGY.MID.ttl) {
    return QR_EXPIRE_STRATEGY.MID;
  } else {
    return QR_EXPIRE_STRATEGY.OLD;
  }
}
```

### 2. 服务端缓存优化
```typescript
// Redis存储实现
import Redis from 'ioredis';
const redis = new Redis();

async function storeQRToken(token: string, data: any) {
  await redis.set(
    `qr:${token}`,
    JSON.stringify(data),
    'PX',
    300000 // 5分钟过期
  );
}

async function getQRToken(token: string) {
  const data = await redis.get(`qr:${token}`);
  return data ? JSON.parse(data) : null;
}
```

## 七、异常处理方案

### 1. 错误状态码设计
```typescript
enum QRLoginError {
  // 二维码不存在或已过期
  INVALID_QR_CODE = 4001,
  // 用户未登录APP
  APP_NOT_AUTHENTICATED = 4002,
  // 设备不匹配
  DEVICE_MISMATCH = 4003,
  // 用户点击取消
  USER_CANCELLED = 4004,
  // 网络超时
  NETWORK_TIMEOUT = 5001
}
```

### 2. 重试机制
```typescript
// 指数退避重试
async function pollWithRetry(token: string, retries = 3) {
  let attempt = 0;
  let delay = 1000;

  while (attempt < retries) {
    try {
      const response = await fetch(`/auth/status/${token}`);
      return await response.json();
    } catch (error) {
      attempt++;
      delay *= 2;
      await new Promise(res => setTimeout(res, delay));
    }
  }

  throw new Error('Max retries reached');
}
```

## 八、多平台适配方案

### 1. 跨APP唤醒协议
```xml
<!-- Android -->
<intent-filter>
  <action android:name="android.intent.action.VIEW" />
  <category android:name="android.intent.category.DEFAULT" />
  <category android:name="android.intent.category.BROWSABLE" />
  <data android:scheme="yourapp" android:host="qrlogin" />
</intent-filter>

<!-- iOS -->
<dict>
  <key>CFBundleURLSchemes</key>
  <array>
    <string>yourapp</string>
  </array>
</dict>
```

### 2. 通用链接处理
```javascript
// 生成通用链接代替原始URL
function generateUniversalLink(token: string) {
  return `https://qr.yoursite.com/auth?token=${token}`;
}

// 服务端重定向
app.get('/auth', (req, res) => {
  const { token } = req.query;
  if (isIOS(req)) {
    return res.redirect(`yourapp://qrlogin?token=${token}`);
  } else if (isAndroid(req)) {
    return res.redirect(`intent://qrlogin?token=${token}#Intent;end`);
  }
  // Web回退方案
  res.redirect(`/app/download?token=${token}`);
});
```

## 九、数据分析方案

### 1. 埋点设计
```typescript
interface QRLoginEvent {
  eventType: 'display' | 'scan' | 'confirm' | 'cancel' | 'expire';
  timestamp: number;
  token: string;
  deviceInfo: {
    platform: 'web' | 'ios' | 'android';
    osVersion: string;
  };
  // 其他业务相关字段
}

function trackEvent(event: QRLoginEvent) {
  analytics.send('qr_login', event);
}
```

### 2. 转化率分析
```sql
-- 分析扫码登录转化漏斗
SELECT
  COUNT(DISTINCT qr_token) AS qr_displayed,
  COUNT(DISTINCT CASE WHEN scan_time IS NOT NULL THEN qr_token END) AS qr_scanned,
  COUNT(DISTINCT CASE WHEN confirm_time IS NOT NULL THEN qr_token END) AS login_confirmed
FROM qr_login_events
WHERE qr_time > NOW() - INTERVAL '7 days'
```

以上实现方案涵盖了扫码登录的完整技术栈，从服务端生成到各端交互，再到安全增强和性能优化。实际应用中可根据具体需求进行组合和调整。
