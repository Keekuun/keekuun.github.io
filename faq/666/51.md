## 51. 如何判断 DOM 元素是否在可视区域

判断一个 DOM 元素是否在**可视区域（viewport）**内，是前端开发中常见的需求，比如实现**懒加载图片**、**无限滚动**、**曝光统计**等功能。

---

### **1. 使用 `getBoundingClientRect()`（兼容性好）**
通过计算元素相对于视口的位置来判断是否可见。

#### **完全可见**（元素全部在视口内）
```typescript
function isFullyInViewport(element: HTMLElement): boolean {
  const rect = element.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= window.innerHeight &&
    rect.right <= window.innerWidth
  );
}
```

#### **部分可见**（元素哪怕只有 1px 在视口内）
```typescript
function isPartiallyInViewport(element: HTMLElement): boolean {
  const rect = element.getBoundingClientRect();
  return (
    rect.top < window.innerHeight &&
    rect.bottom > 0 &&
    rect.left < window.innerWidth &&
    rect.right > 0
  );
}
```

#### **阈值可见**（自定义可见比例，如 50%）
```typescript
function isThresholdInViewport(element: HTMLElement, threshold = 0.5): boolean {
  const rect = element.getBoundingClientRect();
  const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
  const visibleWidth = Math.min(rect.right, window.innerWidth) - Math.max(rect.left, 0);
  return (
    visibleHeight >= rect.height * threshold &&
    visibleWidth >= rect.width * threshold
  );
}
```

---

### **2. 使用 `IntersectionObserver`（高性能，推荐）**
现代浏览器原生 API，适合监听元素进入/离开视口的场景（如懒加载）。

#### **基本用法**
```typescript
function observeElement(
  element: HTMLElement,
  callback: (isVisible: boolean) => void,
  options?: IntersectionObserverInit
): () => void {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => callback(entry.isIntersecting));
  }, options);

  observer.observe(element);
  return () => observer.unobserve(element); // 返回取消监听的函数
}

// 使用示例
const cleanup = observeElement(
  document.getElementById("my-element")!,
  (isVisible) => {
    console.log(isVisible ? "可见" : "不可见");
  },
  { threshold: 0.1 } // 当 10% 可见时触发
);

// 需要时取消监听
// cleanup();
```

#### **React Hook 封装**
```tsx
import { useEffect, useRef, useState } from "react";

export function useVisibility<T extends HTMLElement>(
  threshold = 0.1
): [React.RefObject<T>, boolean] {
  const ref = useRef<T>(null);
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (!ref.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => setIsVisible(entry.isIntersecting),
      { threshold }
    );
    observer.observe(ref.current);

    return () => observer.disconnect();
  }, [threshold]);

  return [ref, isVisible];
}

// 使用示例
const [ref, isVisible] = useVisibility();
return <div ref={ref}>{isVisible ? "已显示" : "未显示"}</div>;
```

---

### **3. 滚动事件 + 手动计算（传统方法）**
兼容性最好，但性能较差（需节流）。

```typescript
function checkScrollVisibility(element: HTMLElement): boolean {
  const rect = element.getBoundingClientRect();
  return (
    rect.top < window.innerHeight && rect.bottom > 0 &&
    rect.left < window.innerWidth && rect.right > 0
  );
}

// 监听滚动（需节流）
window.addEventListener("scroll", () => {
  const isVisible = checkScrollVisibility(document.getElementById("my-element")!);
  console.log(isVisible ? "滚动到可见区域" : "已滚动离开");
});
```

---

### **4. 对比不同方法的优缺点**
| 方法                  | 优点                          | 缺点                          | 适用场景               |
|-----------------------|-------------------------------|-------------------------------|-----------------------|
| `getBoundingClientRect` | 兼容性好，直接计算            | 频繁调用可能引发性能问题      | 简单判断、非频繁操作  |
| `IntersectionObserver` | 高性能，支持阈值和异步回调    | 不兼容 IE11 及以下            | 懒加载、无限滚动      |
| 滚动事件 + 手动计算    | 兼容性极佳                    | 性能差，需手动优化            | 传统项目或兼容性要求高 |

---

### **5. 实际应用建议**
- **懒加载图片**：用 `IntersectionObserver` + `data-src` 替换 `src`。
- **无限滚动**：监听列表底部元素是否可见，加载更多数据。
- **动画触发**：当元素进入视口时播放动画。
- **曝光统计**：记录广告或内容的可见状态。

---

### **完整工具函数（TypeScript）**
```typescript
/**
 * 判断元素是否在视口中（支持完全/部分/阈值可见）
 * @param element 目标元素
 * @param mode "full" | "partial" | "threshold"
 * @param threshold 阈值比例（0-1，仅 mode="threshold" 时生效）
 */
export function isInViewport(
  element: HTMLElement,
  mode: "full" | "partial" | "threshold" = "partial",
  threshold = 0.5
): boolean {
  const rect = element.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;

  if (mode === "full") {
    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= innerHeight &&
      rect.right <= innerWidth
    );
  }

  if (mode === "partial") {
    return (
      rect.top < innerHeight &&
      rect.bottom > 0 &&
      rect.left < innerWidth &&
      rect.right > 0
    );
  }

  // Threshold 模式
  const visibleHeight = Math.min(rect.bottom, innerHeight) - Math.max(rect.top, 0);
  const visibleWidth = Math.min(rect.right, innerWidth) - Math.max(rect.left, 0);
  return (
    visibleHeight >= rect.height * threshold &&
    visibleWidth >= rect.width * threshold
  );
}
```

---

通过以上方法，你可以根据项目需求选择最适合的方式判断元素的可见性！
