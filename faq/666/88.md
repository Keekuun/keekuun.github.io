## 88. [webpack] 打包时 hash 码是如何生成的

在 Webpack 打包过程中，**hash 码**（如 `[hash]`、`[chunkhash]`、`[contenthash]`）用于生成唯一的文件标识，通常用于解决浏览器缓存问题。以下是它们的生成原理和区别：

---

## **1. Hash 码的作用**
- **缓存优化**：通过文件名中的 hash 值，确保文件内容变化时文件名也变化，强制浏览器加载新资源。
- **版本控制**：避免用户因缓存问题看到旧内容。

---

## **2. Webpack 中三种 Hash 码**
| **类型**         | **作用范围**                | **适用场景**               |
|------------------|---------------------------|--------------------------|
| `[hash]`         | 整个项目的所有文件          | 不推荐（任何文件变化都会更新所有文件名） |
| `[chunkhash]`    | 单个 chunk（代码块）        | 适用于 JS 文件             |
| `[contenthash]`  | 文件内容（如 CSS、图片）     | 推荐用于 CSS 或静态资源     |

---

## **3. Hash 码生成原理**
### **(1) 基于内容的哈希算法**
Webpack 默认使用 **MD4** 算法（可通过配置修改）对文件内容计算哈希值，生成唯一的字符串。例如：
- **输入**：文件内容 `console.log("hello")`。
- **哈希计算**：`md4("console.log(\"hello\")")` → `a1b2c3d4`。
- **输出文件名**：`bundle.a1b2c3d4.js`。

### **(2) 触发条件**
- **`[hash]`**：项目中任何文件变化，所有文件的 hash 值都会更新。
- **`[chunkhash]`**：只有当前 chunk 的依赖变化时，hash 值才会更新。
- **`[contenthash]`**：仅当文件内容变化时更新。

---

## **4. 配置示例**
### **(1) 输出文件名带 hash**
```javascript
// webpack.config.js
module.exports = {
  output: {
    filename: '[name].[contenthash].js', // 使用 contenthash
    path: path.resolve(__dirname, 'dist'),
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css', // CSS 文件也用 contenthash
    }),
  ],
};
```

### **(2) 优化 hash 的稳定性**
默认情况下，Webpack 的 hash 可能因模块 ID 或依赖顺序变化而改变，即使内容未变。可通过以下配置固定 hash：
```javascript
module.exports = {
  optimization: {
    moduleIds: 'deterministic', // 固定模块 ID
    runtimeChunk: 'single',     // 分离 runtime 代码
  },
};
```

---

## **5. 底层实现（简化版）**
Webpack 的哈希生成流程：
1. **读取文件内容**：获取所有 chunk 或文件的代码。
2. **计算哈希**：
   ```javascript
   const crypto = require('crypto');
   const content = 'console.log("hello")';
   const hash = crypto.createHash('md4').update(content).digest('hex').slice(0, 8);
   ```
3. **生成文件名**：将哈希值插入文件名模板（如 `[name].[hash].js`）。

---

## **6. 注意事项**
1. **`[hash]` vs `[chunkhash]`**：
    - 使用 `[chunkhash]` 时，需注意公共依赖（如 `node_modules`）变化会导致所有 chunk 的 hash 更新。
    - 解决方案：用 `SplitChunksPlugin` 分离第三方库。
      ```javascript
      optimization: {
        splitChunks: {
          chunks: 'all',
        },
      },
      ```

2. **CSS 的 `[contenthash]`**：
    - 如果 JS 中引入的 CSS 内容未变，但 JS 变化，可能导致 CSS 的 hash 也被更新。
    - 解决方案：使用 `MiniCssExtractPlugin` 独立提取 CSS。

---

## **7. 总结**
| **要点**               | **说明**                                                                 |
|------------------------|--------------------------------------------------------------------------|
| **哈希类型**           | `[hash]`（全局）、`[chunkhash]`（chunk 级）、`[contenthash]`（文件级）。 |
| **生成算法**           | 默认 MD4，基于文件内容计算。                                             |
| **缓存优化**           | 内容变化 → hash 变化 → 文件名变化 → 强制浏览器更新。                     |
| **稳定性配置**         | 固定模块 ID 和 runtime 代码，避免无关 hash 变化。                        |

---

通过合理配置 hash 策略，可以高效管理前端资源的缓存和版本控制！ 🚀