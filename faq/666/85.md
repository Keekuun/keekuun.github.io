## 85. 不同标签页或窗口间的【主动推送消息机制】的方式有哪（不借助服务端）？

在不借助服务端的情况下，实现不同标签页或窗口间的主动推送消息机制，可以通过以下几种方式实现：

---

## **1. `localStorage` 事件监听**
### **原理**
- 利用 `localStorage` 的跨标签页特性，通过监听 `storage` 事件实现消息推送。
- **限制**：同源策略下有效，且无法直接传递复杂对象（需序列化）。

### **代码示例**
#### **发送消息**
```javascript
// 在标签页A中发送消息
localStorage.setItem('cross-tab-message', JSON.stringify({ type: 'alert', data: 'Hello!' }));
```

#### **接收消息**
```javascript
// 在标签页B中监听消息
window.addEventListener('storage', (event) => {
  if (event.key === 'cross-tab-message') {
    const message = JSON.parse(event.newValue);
    console.log('Received:', message);
  }
});
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 简单易用               | 只能传递字符串（需序列化）   |
| 支持跨标签页           | 同源策略限制                 |

---

## **2. `BroadcastChannel` API**
### **原理**
- 使用 `BroadcastChannel` 创建一个命名频道，所有同源的标签页可通过该频道广播和接收消息。
- **支持**：现代浏览器（IE 不支持）。

### **代码示例**
#### **发送消息**
```javascript
// 在标签页A中
const channel = new BroadcastChannel('my_channel');
channel.postMessage({ type: 'update', data: 'New data!' });
```

#### **接收消息**
```javascript
// 在标签页B中
const channel = new BroadcastChannel('my_channel');
channel.onmessage = (event) => {
  console.log('Received:', event.data);
};
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 支持复杂对象           | IE 不支持                    |
| 无需序列化             | 同源策略限制                 |

---

## **3. `SharedWorker`**
### **原理**
- 通过 `SharedWorker` 创建一个共享的 Web Worker，多个标签页可连接到同一个 Worker 实现消息中转。
- **适用场景**：需要长时间通信的复杂应用。

### **代码示例**
#### **SharedWorker 脚本（worker.js）**
```javascript
// worker.js
const ports = [];
onconnect = (e) => {
  const port = e.ports[0];
  ports.push(port);
  port.onmessage = (event) => {
    ports.forEach(p => {
      if (p !== port) p.postMessage(event.data);
    });
  };
};
```

#### **标签页A 和 B**
```javascript
// 在标签页A和B中
const worker = new SharedWorker('worker.js');
worker.port.onmessage = (event) => {
  console.log('Received:', event.data);
};

// 发送消息
worker.port.postMessage({ type: 'broadcast', data: 'Hello!' });
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 支持复杂通信逻辑       | 实现较复杂                   |
| 适合长期连接           | 需要额外 Worker 文件         |

---

## **4. `window.postMessage` + `window.opener`**
### **原理**
- 通过 `window.open` 或 `window.opener` 获取其他标签页的 `window` 对象，直接调用 `postMessage`。
- **限制**：需知道目标窗口的引用（如通过 `window.open` 打开）。

### **代码示例**
#### **标签页A（父窗口）**
```javascript
// 打开标签页B
const childWindow = window.open('child.html');

// 向标签页B发送消息
childWindow.postMessage({ type: 'greet', data: 'Hello from parent!' }, '*');
```

#### **标签页B（子窗口）**
```javascript
// 监听父窗口消息
window.addEventListener('message', (event) => {
  if (event.source === window.opener) {
    console.log('Received:', event.data);
  }
});

// 向父窗口回传消息
window.opener.postMessage({ type: 'reply', data: 'Hi back!' }, '*');
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 直接通信               | 需维护窗口引用               |
| 支持跨域（需配置）     | 仅适用于特定窗口关系         |

---

## **5. `IndexedDB` + 轮询**
### **原理**
- 使用 `IndexedDB` 存储消息，其他标签页通过轮询检查数据变化。
- **适用场景**：需要持久化存储消息。

### **代码示例**
#### **发送消息**
```javascript
// 在标签页A中
const dbRequest = indexedDB.open('message_db');
dbRequest.onsuccess = (event) => {
  const db = event.target.result;
  const transaction = db.transaction('messages', 'readwrite');
  const store = transaction.objectStore('messages');
  store.put({ id: Date.now(), content: 'New message!' });
};
```

#### **接收消息（轮询）**
```javascript
// 在标签页B中
setInterval(() => {
  const dbRequest = indexedDB.open('message_db');
  dbRequest.onsuccess = (event) => {
    const db = event.target.result;
    const transaction = db.transaction('messages', 'readonly');
    const store = transaction.objectStore('messages');
    const request = store.getAll();
    request.onsuccess = () => {
      console.log('Messages:', request.result);
    };
  };
}, 1000); // 每秒轮询一次
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 支持持久化存储         | 延迟高（依赖轮询）           |
| 适合大数据量           | 实现复杂                     |

---

## **6. Service Worker + `postMessage`**
### **原理**
- 通过 Service Worker 作为消息中转站，利用 `postMessage` 实现标签页间通信。
- **适用场景**：PWA 或离线应用。

### **代码示例**
#### **Service Worker 脚本（sw.js）**
```javascript
// sw.js
const clients = [];
self.addEventListener('message', (event) => {
  clients.forEach(client => {
    client.postMessage(event.data);
  });
});

self.addEventListener('activate', (event) => {
  event.waitUntil(self.clients.claim());
});
```

#### **标签页A 和 B**
```javascript
// 注册 Service Worker
navigator.serviceWorker.register('sw.js');

// 发送消息
navigator.serviceWorker.controller.postMessage({ type: 'broadcast', data: 'Hello!' });

// 接收消息
navigator.serviceWorker.onmessage = (event) => {
  console.log('Received:', event.data);
};
```

### **优缺点**
| **优点**               | **缺点**                     |
|------------------------|------------------------------|
| 支持离线场景           | 实现复杂度高                 |
| 适合 PWA               | 需处理 Service Worker 生命周期 |

---

## **总结与选型建议**
| **方案**                | **适用场景**                  | **兼容性**       | **实时性** |
|-------------------------|-----------------------------|------------------|------------|
| `localStorage` 事件     | 简单消息通知                | 高（IE8+）       | 高         |
| `BroadcastChannel`      | 现代浏览器中的复杂通信      | 中（非 IE）      | 高         |
| `SharedWorker`          | 长期多标签页通信            | 中（非 IE）      | 高         |
| `window.postMessage`    | 特定窗口间通信              | 高               | 高         |
| `IndexedDB` + 轮询      | 持久化存储 + 大数据量       | 高               | 低         |
| Service Worker          | PWA/离线应用               | 中（非 IE）      | 高         |

### **推荐选择**
1. **简单场景**：`localStorage` 或 `BroadcastChannel`。
2. **复杂场景**：`SharedWorker` 或 Service Worker。
3. **特定窗口通信**：`window.postMessage`。

通过合理选择方案，可以实现高效、实时的跨标签页通信！ 🚀