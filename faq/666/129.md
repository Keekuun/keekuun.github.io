## 129. [React] 从 React 层面上，能做的性能优化有哪些？

在 React 层面进行性能优化是提升应用流畅度和用户体验的关键。以下是一份**系统化、可落地**的性能优化指南，涵盖从组件设计到状态管理的多个维度，并结合 TypeScript 和现代 React 特性（如 Hooks、Concurrent Mode）的最佳实践。

---

### 📌 **1. 减少不必要的渲染**
React 的核心性能瓶颈通常是**过多的重新渲染**。优化目标是让组件只在必要时更新。

#### **1.1 使用 `React.memo` 缓存组件**
- **适用场景**：纯函数组件，Props 变化不频繁时。
- **原理**：对 Props 进行浅比较，避免相同 Props 下的重复渲染。
- **示例**：
  ```tsx
  const MemoizedComponent = React.memo(function MyComponent({ data }: { data: DataType }) {
    return <div>{data.value}</div>;
  });
  ```

#### **1.2 避免传递内联对象/函数作为 Props**
- **问题**：每次渲染都会生成新的引用，导致子组件无效更新。
- **优化方案**：
    - 将对象提升到组件外部或使用 `useMemo`。
    - 函数用 `useCallback` 包裹。
  ```tsx
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);

  <Child onClick={handleClick} />
  ```

#### **1.3 精细化状态管理**
- **问题**：全局状态（如 Redux）更新时，所有订阅的组件都会重新渲染。
- **优化方案**：
    - 使用 **Recoil** 或 **Zustand** 这类支持原子化状态的库。
    - 在 Redux 中，通过 `useSelector` 选择性订阅字段：
      ```tsx
      const value = useSelector((state) => state.specificField);
      ```

---

### 📌 **2. 高效处理列表渲染**
列表渲染是性能敏感场景，尤其是长列表或动态列表。

#### **2.1 使用 `key` 的正确姿势**
- **错误示范**：用数组索引 `index` 作为 `key`（可能导致渲染错乱）。
- **正确做法**：使用唯一且稳定的 ID（如 `item.id`）。

#### **2.2 虚拟化长列表**
- **推荐库**：`react-window` 或 `react-virtualized`。
- **原理**：只渲染可视区域内的元素，减少 DOM 节点数量。
- **示例**：
  ```tsx
  import { FixedSizeList as List } from 'react-window';

  const Row = ({ index, style }) => (
    <div style={style}>Row {index}</div>
  );

  <List height={600} itemCount={1000} itemSize={35} width={300}>
    {Row}
  </List>
  ```

---

### 📌 **3. 优化副作用（Effects）**
滥用 `useEffect` 会导致性能问题和难以追踪的 Bug。

#### **3.1 避免不必要的 Effect**
- **反模式**：用 Effect 同步派生状态。
- **优化方案**：直接在渲染期间计算派生状态。
  ```tsx
  // ❌ 避免
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(`${firstName} ${lastName}`);
  }, [firstName, lastName]);

  // ✅ 推荐
  const fullName = `${firstName} ${lastName}`;
  ```

#### **3.2 依赖项数组的优化**
- **问题**：依赖项过多或频繁变化会导致 Effect 重复执行。
- **解决方案**：
    - 减少依赖项（如用 `useRef` 存储可变值）。
    - 使用 `useMemo` 缓存依赖项。

---

### 📌 **4. 代码分割与懒加载**
减少首屏加载时间的关键。

#### **4.1 组件级懒加载**
- **工具**：`React.lazy` + `Suspense`。
- **示例**：
  ```tsx
  const LazyComponent = React.lazy(() => import('./LazyComponent'));

  function App() {
    return (
      <Suspense fallback={<Spinner />}>
        <LazyComponent />
      </Suspense>
    );
  }
  ```

#### **4.2 路由级懒加载（Next.js 适用）**
- **示例**：
  ```tsx
  // Next.js 中动态导入页面
  import dynamic from 'next/dynamic';

  const DynamicPage = dynamic(() => import('../components/HeavyPage'), {
    loading: () => <Loading />,
    ssr: false, // 如需禁用 SSR
  });
  ```

---

### 📌 **5. 使用 Concurrent Mode 特性**
React 18+ 的并发特性可提升交互响应速度。

#### **5.1 用 `useTransition` 区分紧急/非紧急更新**
- **场景**：搜索框输入时，延迟渲染结果列表。
- **示例**：
  ```tsx
  const [isPending, startTransition] = useTransition();

  function handleInput(value) {
    startTransition(() => {
      setSearchQuery(value); // 非紧急更新
    });
  }
  ```

#### **5.2 用 `useDeferredValue` 延迟派生值**
- **示例**：
  ```tsx
  const deferredQuery = useDeferredValue(searchQuery);
  ```

---

### 📌 **6. 其他实用技巧**
- **避免内联样式**：CSS-in-JS 库（如 Emotion）在动态样式时可能有性能开销，优先使用 CSS 类名。
- **生产环境构建**：确保启用 React 的 `production` 模式（移除开发警告和优化代码）。
- **分析工具**：
    - **React DevTools**：高亮渲染组件。
    - **Chrome Performance Tab**：记录组件生命周期耗时。

---

### 🎯 **总结：React 性能优化 Checklist**
| 优化方向          | 具体措施                          | 工具/API                      |
|-------------------|-----------------------------------|-------------------------------|
| 减少渲染          | `React.memo`, `useCallback`       | React Core                    |
| 列表优化          | 虚拟滚动, 正确的 `key`            | `react-window`                |
| 状态管理          | 原子化状态, 选择性订阅            | Recoil, Zustand               |
| 副作用控制        | 减少 `useEffect`, 精细依赖        | ESLint `exhaustive-deps` 规则 |
| 代码分割          | 懒加载组件/路由                   | `React.lazy`, Next.js Dynamic |
| 并发模式          | `useTransition`, `useDeferredValue` | React 18+                    |

通过结合这些策略，你可以显著提升 React 应用的性能。记住：**先测量（Profiling），再优化**！用数据驱动决策，避免过度优化。 🚀