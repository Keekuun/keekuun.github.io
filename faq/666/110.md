## 110. 封装一个请求超时，发起重试的代码

以下是一个封装了**请求超时**和**自动重试**功能的代码示例，使用 TypeScript 和 `fetch` API 实现。该代码支持自定义超时时间、重试次数以及重试间隔，并提供了良好的类型提示和错误处理。

---

### 📜 **代码实现**
```typescript
/**
 * 封装带超时和重试的请求
 * @param url 请求地址
 * @param options 请求配置（可选）
 * @param timeout 超时时间（毫秒，默认 5000ms）
 * @param maxRetries 最大重试次数（默认 3 次）
 * @param retryDelay 重试间隔（毫秒，默认 1000ms）
 * @returns 响应数据
 */
async function fetchWithTimeoutAndRetry<T = any>(
    url: string,
    options?: RequestInit,
    timeout: number = 5000,
    maxRetries: number = 3,
    retryDelay: number = 1000
): Promise<T> {
    let retryCount = 0;
    let lastError: Error | null = null;

    while (retryCount < maxRetries) {
        try {
            // 创建超时控制器
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            // 发起请求（合并信号和配置）
            const response = await fetch(url, {
                ...options,
                signal: controller.signal,
            });

            clearTimeout(timeoutId); // 清除超时定时器

            if (!response.ok) {
                throw new Error(`请求失败，状态码: ${response.status}`);
            }

            return await response.json() as T; // 返回解析后的数据
        } catch (error) {
            lastError = error as Error;
            retryCount++;

            if (retryCount >= maxRetries) {
                break; // 不再重试
            }

            console.warn(`请求失败，第 ${retryCount} 次重试...`, error);
            await new Promise(resolve => setTimeout(resolve, retryDelay)); // 延迟重试
        }
    }

    throw new Error(`请求超时或失败，重试 ${maxRetries} 次后仍无法成功: ${lastError?.message}`);
}

// 示例调用
interface ApiResponse {
    data: {
        id: number;
        name: string;
    };
}

async function main() {
    try {
        const result = await fetchWithTimeoutAndRetry<ApiResponse>(
            'https://api.example.com/data',
            { method: 'GET' },
            3000, // 超时时间
            2,    // 重试次数
            500   // 重试间隔
        );
        console.log('请求成功:', result.data);
    } catch (error) {
        console.error('请求最终失败:', error);
    }
}

main();
```

---

### 🎯 **功能说明**
1. **超时控制**：
    - 使用 `AbortController` 实现请求超时，避免长时间等待。
    - 超时后自动取消请求并抛出错误。

2. **自动重试**：
    - 支持自定义重试次数（`maxRetries`）和重试间隔（`retryDelay`）。
    - 每次重试前会等待指定的间隔时间。

3. **错误处理**：
    - 捕获网络错误、超时错误和 HTTP 状态码错误。
    - 重试次数用尽后抛出最终错误。

4. **类型安全**：
    - 使用泛型 `T` 定义返回数据的类型，方便 TypeScript 类型推断。

---

### ⚙️ **使用场景**
- **不稳定的网络环境**：如移动端或弱网条件下，通过重试提高请求成功率。
- **关键 API 请求**：需要确保数据获取成功的场景（如支付、登录）。
- **第三方服务调用**：对不可控的第三方服务增加容错机制。

---

### 📊 **参数说明**
| **参数名**    | **类型**      | **默认值** | **说明**                     |
|---------------|---------------|------------|-----------------------------|
| `url`         | `string`      | -          | 请求地址                     |
| `options`     | `RequestInit` | `{}`       | Fetch API 的请求配置         |
| `timeout`     | `number`      | `5000`     | 超时时间（毫秒）             |
| `maxRetries`  | `number`      | `3`        | 最大重试次数                 |
| `retryDelay`  | `number`      | `1000`     | 重试间隔（毫秒）             |

---

### 🌟 **优化建议**
1. **指数退避**：重试间隔可以动态增加（如 `retryDelay * retryCount`），避免频繁重试。
2. **日志记录**：记录每次重试的详细错误信息，便于排查问题。
3. **自定义重试条件**：根据错误类型决定是否重试（如仅对超时或 5xx 错误重试）。

---

### 🚀 **示例扩展（指数退避）**
```typescript
async function fetchWithExponentialBackoff<T = any>(
    url: string,
    options?: RequestInit,
    timeout: number = 5000,
    maxRetries: number = 3,
    initialDelay: number = 1000
): Promise<T> {
    let retryCount = 0;
    let delay = initialDelay;

    while (retryCount < maxRetries) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            const response = await fetch(url, {
                ...options,
                signal: controller.signal,
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`请求失败，状态码: ${response.status}`);
            }

            return await response.json() as T;
        } catch (error) {
            retryCount++;
            if (retryCount >= maxRetries) {
                throw new Error(`重试 ${maxRetries} 次后失败: ${error.message}`);
            }

            console.warn(`第 ${retryCount} 次重试，等待 ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2; // 指数退避
        }
    }

    throw new Error('未知错误');
}
```

---

通过这个封装，你可以轻松实现**高可靠性**的网络请求，适用于生产环境中的复杂场景！ 🎉