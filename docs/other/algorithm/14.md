---
title: 二分查找
sidebar: auto
categories:
  - 算法
tags:
  - 算法
---

## 二分查找

二分查找算法模板：

查找一维数组arr 中的 target:

```js
// 普通二分查找
function binarySearch(arr, target) {
  let left = 0, right = arr.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid
    } else if (arr[mid] < target) {
      left = mid + 1
    } else if (arr[mid] > target) {
      right = mid - 1
    }
  }

  return -1
}

// 搜索左侧边界的二分查找1：左闭右开
function leftBoundBinarySearch1(arr, target) {
  let left = 0, right = arr.length;

  while (left < right) {
    let mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      right = mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else if (arr[mid] > target) {
      right = mid;
    }
  }

  return arr[left] === target ? left : -1
}

// 搜索左侧边界的二分查找2：左闭右闭
function leftBoundBinarySearch2(arr, target) {
  let left = 0, right = arr.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      right = mid - 1;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else if (arr[mid] > target) {
      right = mid - 1;
    }
  }

  if (left >= arr.length || arr[left] !== target) {
    return -1;
  }

  return left
}


// 搜索右侧边界的二分查找1：左闭右开
function rightBoundBinarySearch1(arr, target) {
  let left = 0, right = arr.length;

  while (left < right) {
    let mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      left = mid + 1;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else if (arr[mid] > target) {
      right = mid;
    }
  }
  if (left == 0) return -1;

  return arr[left - 1] === target ? (left - 1) : -1;
}

// 搜索右侧边界的二分查找2：左闭右闭
function rightBoundBinarySearch2(arr, target) {
  let left = 0, right = arr.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      left = mid + 1;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else if (arr[mid] > target) {
      right = mid - 1;
    }
  }
  if (right < 0 || arr[right] !== target) return -1;

  return right;
}
```

## 案例

### 1.[搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

```
给你一个满足下述两条属性的 m x n 整数矩阵：

每行中的整数从左到右按非严格递增顺序排列。
每行的第一个整数大于前一行的最后一个整数。
给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。



示例 1：


输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
示例 2：


输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false


提示：

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-104 <= matrix[i][j], target <= 104
```

+ 暴力法
```js
function searchMatrix(matrix, target) {
  for (let i = 0; i < matrix.length; i++) {
    if (matrix[i].includes(target)) return true
  }
  
  return false
}

```

+ 二分查找解法1

第一次：二分查找找到target所在的行

第二次：二分查找找到target所在的列

```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
function searchMatrix(matrix, target) {
    let m = matrix.length, n = matrix[0].length
    
    // 找到target所在的行
    let left = 0, right = m - 1
    while (left <= right) {
        let mid = Math.floor((left + right) / 2)
        if (matrix[mid][0] === target) {
            return true
        }
        if (matrix[mid][0] < target) {
            left = mid + 1
        }
        if (matrix[mid][0] > target) {
            right = mid - 1
        }
    }
    
    // 判断 是否找到target所在的行
    if(right < 0 || matrix[right][0] > target) {
        return false
    }
    if(matrix[right][0] === target) {
        return true
    }
    
    let row = right
    // 找到target所在的列
    left = 0, right = n - 1
    while (left <= right) {
        let mid = Math.floor((left + right) / 2)
        if (matrix[row][mid] === target) {
            return true
        }
        if (matrix[row][mid] < target) {
            left = mid + 1
        }
        if (matrix[row][mid] > target) {
            right = mid - 1
        }
    }
    
    let col = right
    return matrix[row][col] === target
}
```
+ 二分查找解法2

将二维数组展开为一维数组，直接进行二分查找

```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
function searchMatrix(matrix, target) {
    let m = matrix.length, n = matrix[0].length
    
    let left = 0, right = m * n - 1
    while (left <= right) {
        let mid = Math.floor((left + right) / 2)
        let cur = matrix[Math.floor(mid / n)][mid % n]
        if (cur === target) {
            return true
        }
        
        if (cur < target) {
            left = mid + 1
        }
        
        if (cur > target) {
            right = mid - 1
        }
    }
    
    return false
}
```
+ 二叉搜索树思路

将二维数组看做是以右上角为根节点的二叉树。

![](https://pic.leetcode-cn.com/1617066993-AyRIiF-image.png)

```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
function searchMatrix(matrix, target) {
    let m = matrix.length, n = matrix[0].length
    
    function isValid(x, y) {
        return x >= 0 && x < m && y >= 0 && y < n
    }
    
    let row = 0, col = n - 1
    
    while(isValid(row, col) && matrix[row][col] !== target) {
        if(matrix[row][col] < target) {
            row++
        } else {
            col--
        }
    }
    
    return isValid(row, col) && matrix[row][col] === target
}
```
