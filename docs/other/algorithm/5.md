---
title: 经典排序算法及二分查找
sidebar: auto
categories:
- 算法
tags:
- 算法

---

## 冒泡排序(稳定)
### 1.常规冒泡排序
```js
function bubbleSort(data) {
    if(data.length < 2) return data;
    for(let i=0;i<data.length;i++) {
        for(let j=0;j<data.length - 1 - i; j++) {
            if(data[j] > data[j+1]) {
                [data[j], data[j+1]] = [data[j+1], data[j]];
            }   
        }   
    }
    return data;
}
```

### 2.改进冒泡排序-标志位

```js
function bubbleSort(data) {
    if(data.length < 2) return data;
    let len = data.length;
  	let flag;
    for(let i=0;i<len;i++) {
        flag = false
        for(let j=0; j<len -i -1; j++) {
            if(data[j]>data[j+1]) {
                [data[j], data[j+1]] = [data[j+1], data[j]];
                // 交换了
                flag = true;
            }
        }
        // 如果没有发生交换，则退出循环
        if(flag) break;
    }
    return data
}
```

### 2.改进冒泡排序-双向

```js
function bubbleSort(data) {
    if(data.length < 2) return data;
    let left = 0;
    let right = data.length - 1;
    
    while(left < right) {
        for(let i=left;i<right;i++) {
            if(data[i] > data[i+1]) {
                [data[i], data[i+1]] = [data[i+1], data[i]];
            }  
        }
        right--;
        for(let i=right;i>left;i--) {
            if(data[i] < data[i-1]) {
                [data[i], data[i-1]] = [data[i-1], data[i]];
            }  
        }
        left++;
    }
    return data;
}
```

## 选择排序(稳定)

+ 基础版

每轮记录最小的下标，然后交换到首位
```js
function selectionSort1(data) {
    let n = data.length
    let minIndex;
    for (let i = 0; i < n - 1; i++) {
        // 假设当前的最小数的下标为i, 记录一下
        minIndex = i;
        // 比较之后的数，找到更小的数的下表然后替换minIndex
        for (let j = i + 1; j < n; j++) {
            if (data[j] < data[minIndex]) {
                minIndex = j;
            }
        }
        // 交换位置
        [data[i], data[minIndex]] = [data[minIndex], data[i]];
    }
    return data;
}
```

为了便于后续优化的理解，使用while循环实现：
```js
function selectionSort2(nums) {
    let n = nums.length

    let left = 0
    let right = n - 1

    while (left < right) {
        let minIndex = left
      
        // 处理最小值
        for (let i = left; i <= right; i++) {
            if (nums[i] < nums[minIndex]) minIndex = i
        }
        if (minIndex !== left) {
            [nums[minIndex], nums[left]] = [nums[left], nums[minIndex]]
        }

        // 左向右递进
        left++
    }
    
    return nums
}
```

+ 优化版
  每轮记录最小数的下标和最大数的下标，然后将最小数交换到首位，最大数交换到尾部

```js
function optimizedSelectionSort1(nums) {
  let n = nums.length

  let left = 0
  let right = n - 1

  while (left < right) {
    let minIndex = left
    let maxIndex = right

    // 先处理最小值
    for (let i = left; i <= right; i++) {
      if (nums[i] < nums[minIndex]) minIndex = i
    }
    if (minIndex !== left) {
      [nums[minIndex], nums[left]] = [nums[left], nums[minIndex]]
    }

    // 再处理最大值
    for (let i = left; i <= right; i++) {
      if (nums[i] > nums[maxIndex]) maxIndex = i
    }
    if (maxIndex !== right) {
      [nums[maxIndex], nums[right]] = [nums[right], nums[maxIndex]]
    }

    // 左右向中间收敛
    left++
    right--
  }
  
  return nums
}
```

进一步优化，将最大最小值的判断合并为一个：
```js
function optimizedSelectionSort2(nums) {
  let n = nums.length

  let left = 0
  let right = n - 1

  while (left < right) {
    let minIndex = left
    let maxIndex = right

    for (let i = left; i <= right; i++) {
      if (nums[i] < nums[minIndex]) minIndex = i
      if (nums[i] > nums[maxIndex]) maxIndex = i
    }

    if (minIndex !== left) {
      [nums[minIndex], nums[left]] = [nums[left], nums[minIndex]]
    }

    // 如果最大的在左边，由于上一步已经把左边的交换了，所以需要修正
    if (maxIndex === left) {
      maxIndex = minIndex;
    }

    if (maxIndex !== right) {
      [nums[maxIndex], nums[right]] = [nums[right], nums[maxIndex]]
    }

    left++
    right--
  }

  return nums
}
```

## 插入排序
```js
function insertSort(data) {
    if(data.length < 2) return data;
    
    for(let i=1; i<data.length; i++) {
        for(let j=i-1; j>=0; j--) {
            if(data[j] > data[i]) {
                [data[i], data[j]] = [data[j], data[i]]
            }
        }
    }
    return data;
}
```

## 快速排序(不稳定)
```js
function quickSort(data) {
    if(data.length < 2) return data;
    // 提出最后一个作为基准
    let pivot = data.pop();
    
    // 将data分为基准两侧的
    let left = [];
    let right = [];
    for(let i=0;i<data.length;i++) {
        if(data[i] < pivot) {
            left.push(data[i]);
        } else {
            right.push(data[i])
        }
    }

    // 递归调用 [基准左侧， 基准， 基准右侧]
    return [...quickSort(left), pivot, ...quickSort(right)];
}
```

## 归并排序(稳定)
```js
function mergeSort(arr) {
    if(arr.length < 2) return arr;
    
    let mid = arr.length >> 1;
    let left = arr.slice(0, mid);
    let right = arr.slice(mid);
    
    return merge(mergeSort(left), mergeSort(right));
    
    function merge(left, right) {
        let res = [];
        let i=0, j=0;
        
        while(i<left.length && j <right.length) {
            if(left[i] <=right[j]) {
                res.push(left[i]);
                i++;
            } else {
                res.push(right[j]);
                j++;
            }
        }
        
        return [...res, ...left.slice(i), ...right.slice(j)]
    }
}
```

> https://www.cnblogs.com/jztan/p/12273671.html
>
> https://www.jianshu.com/p/a28db3d3cc18


## 二分查找

### 1.查找一个数的二分查找
```js
function binarySearch(arr, target) {
    if(!arr || arr.length === 0) return -1;
    
    let left = 0, right = arr.length - 1;
    
    while(left <= right) {
        let mid = left + (right - left) >> 2;
        
        if(arr[mid] === target) {
            return mid;
        } else if(arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

### 2.查找左侧边界的二分查找
```js
function leftBoundBinarySearch(arr, target) {
    if(!arr || arr.length === 0) return -1;

    let left = 0, right = arr.length;
    
    while(left < right) {
        let mid = left + (right - left) >> 2;
        
        if(arr[mid] === target) { // 收缩右侧边界
            right = mid;
        } else if(arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return arr[left] === target ? left : -1;
}
```

### 3.查找右侧边界的二分查找
```js
function rightBoundBinarySearch(arr, target) {
    if(!arr || arr.length === 0) return -1;

    let left = 0, right = arr.length;
    
    while(left < right) {
        let mid = left + (right - left) >> 2;
        
        if(arr[target] === mid) { // 收缩左侧边界
            left = mid + 1;
        } else if(arr[target] < mid) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return arr[right - 1] === target ? right - 1 : -1;
}
```
