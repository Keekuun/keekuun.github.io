---
title: 经典排序算法及二分查找
sidebar: auto
categories:
  - 算法
tags:
  - 算法

---

# 排序

![](../../../images/algorithm/10-sort.png)

![](../../../images/algorithm/10-sort1.png)

## 冒泡排序(稳定)(n^2)

### 1.常规冒泡排序

相邻比较，两两交换
```js
function bubbleSort1(nums) {
    const n = nums.length
  // 从前往后遍历
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (data[j] > data[j + 1]) {
        [data[j], data[j + 1]] = [data[j + 1], data[j]];
      }
    }
  }
  return data;
}


function bubbleSort2(nums) {
  let n = nums.length
  // 从后往前遍历
  for (let i = n - 1; i > 0; i--) {
    for (let j = 0; j < i; j++) {
      if (nums[j] > nums[j + 1]) {
        [nums[j], nums[j + 1]] = [nums[j + 1], nums[j]]
      }
    }
  }

  return nums
}
```

### 2.改进冒泡排序-标志位

```js
function bubbleSort(data) {
    if (data.length < 2) return data;
    let len = data.length;
    let flag = true;
    for (let i = 0; i < len; i++) {
        flag = true
        for (let j = 0; j < len - i - 1; j++) {
            if (data[j] > data[j + 1]) {
                [data[j], data[j + 1]] = [data[j + 1], data[j]];
                // 交换了
                flag = false;
            }
        }
        // 如果没有发生交换，则退出循环
        if (flag) break;
    }
    return data
}
```

### 2.改进冒泡排序-双向

```js
function bubbleSort(data) {
    if (data.length < 2) return data;
    let left = 0;
    let right = data.length - 1;

    while (left < right) {
        let flag = true

        for (let i = left; i < right; i++) {
            if (data[i] > data[i + 1]) {
                [data[i], data[i + 1]] = [data[i + 1], data[i]];
                flag = false
            }
        }
        // 最右边已经是最大的了
        right--;
        for (let i = right; i > left; i--) {
            if (data[i] < data[i - 1]) {
                [data[i], data[i - 1]] = [data[i - 1], data[i]];
                flag = false
            }
        }
        // 最左边已经时最小的了
        left++;

        if (flag) break;
    }
    return data;
}
```

## 选择排序(不稳定)(n^2)

+ 基础版

每轮记录最小的下标，然后交换到首位

```js
function selectionSort1(data) {
    let n = data.length
    let minIndex;
    for (let i = 0; i < n - 1; i++) {
        // 假设当前的最小数的下标为i, 记录一下
        minIndex = i;
        // 比较之后的数，找到更小的数的下表然后替换minIndex
        for (let j = i + 1; j < n; j++) {
            if (data[j] < data[minIndex]) {
                minIndex = j;
            }
        }
        // 交换位置
        [data[i], data[minIndex]] = [data[minIndex], data[i]];
    }
    return data;
}
```

为了便于后续优化的理解，使用while循环实现：

```js
function selectionSort2(nums) {
    let n = nums.length

    let left = 0
    let right = n - 1

    while (left < right) {
        let minIndex = left

        // 处理最小值
        for (let i = left; i <= right; i++) {
            if (nums[i] < nums[minIndex]) minIndex = i
        }
        if (minIndex !== left) {
            [nums[minIndex], nums[left]] = [nums[left], nums[minIndex]]
        }

        // 左向右递进
        left++
    }

    return nums
}
```

+ 优化版
  每轮记录最小数的下标和最大数的下标，然后将最小数交换到首位，最大数交换到尾部

```js
function optimizedSelectionSort1(nums) {
    let n = nums.length

    let left = 0
    let right = n - 1

    while (left < right) {
        let minIndex = left
        let maxIndex = right

        // 先处理最小值
        for (let i = left; i <= right; i++) {
            if (nums[i] < nums[minIndex]) minIndex = i
        }
        if (minIndex !== left) {
            [nums[minIndex], nums[left]] = [nums[left], nums[minIndex]]
        }

        // 再处理最大值
        for (let i = left; i <= right; i++) {
            if (nums[i] > nums[maxIndex]) maxIndex = i
        }
        if (maxIndex !== right) {
            [nums[maxIndex], nums[right]] = [nums[right], nums[maxIndex]]
        }

        // 左右向中间收敛
        left++
        right--
    }

    return nums
}
```

进一步优化，将最大最小值的判断合并为一个：

```js
function optimizedSelectionSort2(nums) {
    let n = nums.length

    let left = 0
    let right = n - 1

    while (left < right) {
        let minIndex = left
        let maxIndex = right

        for (let i = left; i <= right; i++) {
            if (nums[i] < nums[minIndex]) minIndex = i
            if (nums[i] > nums[maxIndex]) maxIndex = i
        }

        if (minIndex !== left) {
            [nums[minIndex], nums[left]] = [nums[left], nums[minIndex]]
        }

        // 如果最大的在左边，由于上一步已经把左边的交换了，所以需要修正
        if (maxIndex === left) {
            maxIndex = minIndex;
        }

        if (maxIndex !== right) {
            [nums[maxIndex], nums[right]] = [nums[right], nums[maxIndex]]
        }

        left++
        right--
    }

    return nums
}
```

## 插入排序(稳定)(n^2)

```js
function insertionSort(nums) {
    let n = nums.length

    for (let i = 1; i < n; i++) {
        for (let j = i; j > 0 && nums[j] < nums[j - 1]; j--) {
          [nums[j], nums[j - 1]] = [nums[j - 1], nums[j]]
        }
    }

    return nums
}
```

## 希尔排序(不稳定)(Nlog2N))
希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

```js
function shellSort(nums) {
  let n = nums.length
  
  // 选择 n/2作为gap
  for(let gap = n >> 1; gap > 0; gap = gap >> 1) {
    for(let i=gap; i < n; i++) {
      for(let j=i; j>gap-1 && nums[j] < nums[j-gap]; j -= gap) {
        [nums[j], nums[j-gap]] = [nums[j-gap], nums[j]]
      }
    }
  }

  return nums
}
```

使用Knuth序列：
```js
function shellSort(nums) {
  let n = nums.length

  // 计算gap
  let h = 1;
  while (h < n / 3) {
    h = h * 3 + 1;
  }
  
  for(let gap = h; gap > 0; gap = Math.floor((gap - 1) / 3)) {
    for(let i=gap; i < n; i++) {
      for(let j=i; j>gap-1 && nums[j] < nums[j-gap]; j -= gap) {
        [nums[j], nums[j-gap]] = [nums[j-gap], nums[j]]
      }
    }
  }

  return nums
}
```

## 快速排序(不稳定)

```js
function quickSort(data) {
    if (data.length < 2) return data;
    // 提出最后一个作为基准
    let pivot = data.pop();

    // 将data分为基准两侧的
    let left = [];
    let right = [];
    for (let i = 0; i < data.length; i++) {
        if (data[i] < pivot) {
            left.push(data[i]);
        } else {
            right.push(data[i])
        }
    }

    // 递归调用 [基准左侧， 基准， 基准右侧]
    return [...quickSort(left), pivot, ...quickSort(right)];
}
```

## 归并排序(稳定)

```js
function mergeSort(arr) {
    if (arr.length < 2) return arr;

    let mid = arr.length >> 1;
    let left = arr.slice(0, mid);
    let right = arr.slice(mid);

    return merge(mergeSort(left), mergeSort(right));

    function merge(left, right) {
        let res = [];
        let i = 0, j = 0;

        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                res.push(left[i]);
                i++;
            } else {
                res.push(right[j]);
                j++;
            }
        }

        return [...res, ...left.slice(i), ...right.slice(j)]
    }
}
```

> https://www.cnblogs.com/jztan/p/12273671.html
>
> https://www.jianshu.com/p/a28db3d3cc18

# 二分查找

### 1.查找一个数的二分查找

```js
function binarySearch(arr, target) {
    if (!arr || arr.length === 0) return -1;

    let left = 0, right = arr.length - 1;

    while (left <= right) {
        let mid = left + (right - left) >> 2;

        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}
```

### 2.查找左侧边界的二分查找

```js
function leftBoundBinarySearch(arr, target) {
    if (!arr || arr.length === 0) return -1;

    let left = 0, right = arr.length;

    while (left < right) {
        let mid = left + (right - left) >> 2;

        if (arr[mid] === target) { // 收缩右侧边界
            right = mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return arr[left] === target ? left : -1;
}
```

### 3.查找右侧边界的二分查找

```js
function rightBoundBinarySearch(arr, target) {
    if (!arr || arr.length === 0) return -1;

    let left = 0, right = arr.length;

    while (left < right) {
        let mid = left + (right - left) >> 2;

        if (arr[target] === mid) { // 收缩左侧边界
            left = mid + 1;
        } else if (arr[target] < mid) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return arr[right - 1] === target ? right - 1 : -1;
}
```
