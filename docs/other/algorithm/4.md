---
title: 链表训练
sidebar: auto
categories:
  - 算法
tags:
  - 算法
---


## [链表](https://leetcode-cn.com/tag/linked-list/)

### 1.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
+ 迭代：
```js
var reverseList = function(head) {
    let prev = null;
    let curr = head;
    while (curr) {
        const next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
};
```

+ 递归：
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  if (!head || !head.next) return head;
  
  let last = reverseList(next);
  head.next.next = head;
  head.next = null;

  return last;
}

// 怎么理解递归操作？
function reverse1(head) {
  // 1.递归结束判断，只剩一个节点
  if(!head || !head.next) return head

  // 2.递归把head.next之后的反转：head -> reversedHead
  let newHead = reverseList(head.next)

  let oldHead = head
  // 原来：oldHead -> (未反转部分 a->b->c, oldHead.next == a, c.next == oldLast)-> (oldLast = null)
  // reverseList(head.next)操作之后：oldHead -> (已反转部分 a<-b-<c, oldHead.next == a, c.next == b, a.next == oldLast)-> (oldLast = null)
  let oldLast = oldHead.next.next
  // 3.反转head, 补充null
  oldHead.next.next = oldLast
  oldHead.next = oldLast

  return newHead
}
```

### 2.[反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
+ [迭代解法](https://leetcode.cn/problems/reverse-linked-list-ii/solutions/634701/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq)

```js
var reverseBetween = function(head, left, right) {
    // 使用dummy节点，可以避免过多的判断
    //     -1 -> 1 -> 2 -> 3 -> 4
    // dummy -> a -> b -> c -> d
    const dummy_node = new ListNode(-1);
    dummy_node.next = head;
    let pre = dummy_node;
    // 找到left的前一个节点
    for (let i = 0; i < left - 1; ++i) {
        pre = pre.next;
    }

    // [left = 2, right = 4]之间开始反转
    //    -1 -> 1 -> 2 -> 3 -> 4
    // dummy -> a -> b -> c -> d
    let cur = pre.next; // pre = 1 cur = 2
    for (let i = 0; i < right - left; ++i) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummy_node.next;
};
```

+ [递归解法](https://leetcode.cn/problems/reverse-linked-list-ii/solutions/37247/bu-bu-chai-jie-ru-he-di-gui-di-fan-zhuan-lian-biao)
```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function reverseBetween(head: ListNode | null, left: number, right: number): ListNode | null {
  if (!head || !head.next) return head

  if (left === 1) {
    return reverseN(head, right)
  }

  head.next = reverseBetween(head.next, left - 1, right - 1)

  return head
};

// 反转链表前 N 个节点
function reverseN(head: ListNode | null, n: number): ListNode | null {
  if (!head || !head.next) return head

  if (n === 1) {
    return head
  }

  const last = reverseN(head.next, n - 1)

  let suc = head.next.next
  head.next.next = head
  head.next = suc

  return last
}
```

### 3.[旋转链表](https://leetcode-cn.com/problems/rotate-list/)

### 4.[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

### 5.[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if(!head || !head.next) return false;
    
    let slow = head, fast = head;
    
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        
        if(slow === fatse) return true;
    }
    
    return false;
}
```

### 6.[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

### 7.[两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    if(!headA || !headB) return null;

    var n1 = headA;
    var n2 = headB;
    while(n1 != n2) {
        n1 = n1 == null ? headB : n1.next;
        n2 = n2 == null ? headA : n2.next;
    }

    return n1;

};
```

### 8.[合并k个升序链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmerge-k-sorted-lists%2F)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if(lists.length === 0) return null;
    
    return mergeArr(lists)
}

// 归并排序
function mergeArr(lists) {
    if(lists.length < 2) return lists[0];
    let index = Math.floor(lists.length / 2);
    const left = mergeArr(lists.slice(0, index));
    const right = mergeArr(lists.slice(index));
    
    return merge(left, right);
}

function merge(l1, l2) {
    if(l1 === null || l2 === null) return l1 || l2;
    
    let head = null, newHead = null;
    
    while(l1 !== null && l2 !== null) {
        if(l1.val < l2.val) {
            if(!head) {
                head = l1;
                newHead = l1;
            } else {
                newHead.next = l1;
                newHead = l1;
            }
            l1 = l1.next
        } else {
            if(!head) {
                head = l2;
                newHead = l2;
            } else {
                newHead.next = l2;
                newHead = l2;
            }
            l2 = l2.next
        }
    }
    
    newHead.next = l1 || l2;
    
    return head;
}
```

### 9.[K个一组翻转链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-nodes-in-k-group%2F)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    let a = head, b = head;
    
    // 先找到第一组k的分界节点
    for(let i=0; i<k; i++) {
        if(b===null) return head;
        b = b.next;
    }
    // 翻转head和分界节点之间的节点b（翻转链表）
    const newHead = reverse(a, b);
    // 继续翻转b之后的节点
    a.next = reverseGroup(b, k);
    return newHead;
}

// 翻转a,b节点之间的节点
function reverse(a, b) {
    let prev = null, cur = a, next;
    
    while(cur !== b) {
        next = cur.next;
        cur.next = prev;
        prev = cur;
        cur = next;
    }
    
    return prev;
}
```

### 10.[排序链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsort-list%2F)

```js

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
    if (head == null) return null;
    let newHead = head;
    return mergeSort(head);
};
function mergeSort(head) {
    if (head.next != null) {
        let slower = getCenter(head);
        let nxt = slower.next;
        slower.next = null;
        const left = mergeSort(head);
        const right = mergeSort(nxt);
        head = merge(left, right);
    }
    return head;
}
function merge(left, right) {
    let newHead = null, head = null;
    while (left != null && right != null) {
        if (left.val < right.val) {
            if (!head) {
                newHead = left;
                head = left;
            } else {
                newHead.next = left;
                newHead = newHead.next;
            }
            left = left.next;
        } else {
            if (!head) {
                newHead = right;
                head = right;
            } else {
                newHead.next = right;
                newHead = newHead.next;
            }
            right = right.next;
        }
    }
    newHead.next = left ? left : right;
    return head;
}
function getCenter(head) {
    let slower = head, faster = head.next;
    while (faster != null && faster.next != null) {
        slower = slower.next;
        faster = faster.next.next;
    }
    return slower;
}

```

### 11.[相交链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fintersection-of-two-linked-lists%2F)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    if(!headA || !headB) return null;
    
    let a = headA, b = headB;
    
    while(a !== b) {
       a = a === null ? headB : a.next;
       b = b === null ? headA : b.next;
    }
    
    return a;
};
```
