---
title: 链表训练
sidebar: auto
categories:
  - 算法
tags:
  - 算法
---


## [链表](https://leetcode-cn.com/tag/linked-list/)

### 1.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if(!head || !head.next) return head;
    
    let next = head.next;
    let last = reverseList(next);
    next.next = head;
    head.next = null;
    
    return last;
}
```

### 2.[反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

### 3.[旋转链表](https://leetcode-cn.com/problems/rotate-list/)

### 4.[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

### 5.[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if(!head || !head.next) return false;
    
    let slow = head, fast = head;
    
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        
        if(slow === fatse) return true;
    }
    
    return false;
}
```

### 6.[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

### 7.[两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    if(!headA || !headB) return null;

    var n1 = headA;
    var n2 = headB;
    while(n1 != n2) {
        n1 = n1 == null ? headB : n1.next;
        n2 = n2 == null ? headA : n2.next;
    }

    return n1;

};
```

### 8.[合并k个升序链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmerge-k-sorted-lists%2F)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if(lists.length === 0) return null;
    
    return mergeArr(lists)
}

// 归并排序
function mergeArr(lists) {
    if(lists.length < 2) return lists[0];
    let index = Math.floor(lists.length / 2);
    const left = mergeArr(lists.slice(0, index));
    const right = mergeArr(lists.slice(index));
    
    return merge(left, right);
}

function merge(l1, l2) {
    if(l1 === null || l2 === null) return l1 || l2;
    
    let head = null, newHead = null;
    
    while(l1 !== null && l2 !== null) {
        if(l1.val < l2.val) {
            if(!head) {
                head = l1;
                newHead = l1;
            } else {
                newHead.next = l1;
                newHead = l1;
            }
            l1 = l1.next
        } else {
            if(!head) {
                head = l2;
                newHead = l2;
            } else {
                newHead.next = l2;
                newHead = l2;
            }
            l2 = l2.next
        }
    }
    
    newHead.next = l1 || l2;
    
    return head;
}
```

### 9.[K个一组翻转链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-nodes-in-k-group%2F)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    let a = head, b = head;
    
    // 先找到第一组k的分界节点
    for(let i=0; i<k; i++) {
        if(b===null) return head;
        b = b.next;
    }
    // 翻转head和分界节点之间的节点b（翻转链表）
    const newHead = reverse(a, b);
    // 继续翻转b之后的节点
    a.next = reverseGroup(b, k);
    return newHead;
}

// 翻转a,b节点之间的节点
function reverse(a, b) {
    let prev = null, cur = a, next;
    
    while(cur !== b) {
        next = cur.next;
        cur.next = prev;
        prev = cur;
        cur = next;
    }
    
    return prev;
}
```

### 10.[排序链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsort-list%2F)

```js

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
    if (head == null) return null;
    let newHead = head;
    return mergeSort(head);
};
function mergeSort(head) {
    if (head.next != null) {
        let slower = getCenter(head);
        let nxt = slower.next;
        slower.next = null;
        const left = mergeSort(head);
        const right = mergeSort(nxt);
        head = merge(left, right);
    }
    return head;
}
function merge(left, right) {
    let newHead = null, head = null;
    while (left != null && right != null) {
        if (left.val < right.val) {
            if (!head) {
                newHead = left;
                head = left;
            } else {
                newHead.next = left;
                newHead = newHead.next;
            }
            left = left.next;
        } else {
            if (!head) {
                newHead = right;
                head = right;
            } else {
                newHead.next = right;
                newHead = newHead.next;
            }
            right = right.next;
        }
    }
    newHead.next = left ? left : right;
    return head;
}
function getCenter(head) {
    let slower = head, faster = head.next;
    while (faster != null && faster.next != null) {
        slower = slower.next;
        faster = faster.next.next;
    }
    return slower;
}

```

### 11.[相交链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fintersection-of-two-linked-lists%2F)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    if(!headA || !headB) return null;
    
    let a = headA, b = headB;
    
    while(a !== b) {
       a = a === null ? headB : a.next;
       b = b === null ? headA : b.next;
    }
    
    return a;
};
```