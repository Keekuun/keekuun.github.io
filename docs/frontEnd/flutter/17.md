---
title: Flutter webview 实现h5秒开
isComment: true
categories:
- flutter
tags:
- flutter
---

## Flutter webview 实现h5秒开

> 要实现 webview 秒开h5页面，关键在于对H5静态资源的缓存管理。通过合理的缓存策略，可以显著提升页面加载速度，同时确保资源在更新后能及时刷新。

要实现Flutter中WebView对H5静态资源的缓存管理（既保证缓存提升加载速度，又能及时更新），需要结合**版本控制**、**缓存策略配置**和**主动清理机制**。以下是具体方案和代码实现：


### **核心思路**
1. **H5静态资源版本化**：让H5的静态文件（JS/CSS/图片）文件名或路径包含版本标识（如哈希值、版本号，例：`app.1.0.1.js` 或 `app.js?v=1.0.1`），确保更新时资源URL变化，浏览器会自动重新请求（无需手动清理缓存）。
2. **版本校验机制**：Flutter端通过请求服务器的“版本文件”（如`version.txt`），对比本地存储的版本号，判断是否需要更新缓存。
3. **缓存策略配置**：WebView优先使用缓存，版本更新时主动清除旧缓存，加载新资源。


### **实现步骤与代码**

#### **1. 依赖准备**
需要以下插件：
- `webview_flutter`：加载H5页面
- `shared_preferences`：本地存储版本号
- `dio`：网络请求（获取服务器版本号）

在`pubspec.yaml`中添加：
```yaml
dependencies:
  flutter:
    sdk: flutter
  webview_flutter: ^4.4.2
  shared_preferences: ^2.2.2
  dio: ^5.3.3
```


#### **2. 版本控制工具类**
用于管理本地版本存储、与服务器版本对比、缓存清理。

```dart
import 'package:shared_preferences/shared_preferences.dart';
import 'package:dio/dio.dart';

class H5CacheManager {
  // 本地存储的版本键名
  static const _localVersionKey = 'h5_static_version';
  // 服务器版本文件URL（由后端提供，内容为当前H5静态资源版本号，如"1.0.2"）
  static const _serverVersionUrl = 'https://your-h5-domain.com/version.txt';

  // 获取本地存储的版本号
  static Future<String?> getLocalVersion() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_localVersionKey);
  }

  // 保存版本号到本地
  static Future<void> saveLocalVersion(String version) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_localVersionKey, version);
  }

  // 获取服务器最新版本号
  static Future<String?> getServerVersion() async {
    try {
      final dio = Dio();
      final response = await dio.get(_serverVersionUrl);
      if (response.statusCode == 200) {
        return response.data.toString().trim(); // 版本号需trim（避免空格）
      }
      return null;
    } catch (e) {
      print('获取服务器版本失败：$e');
      return null;
    }
  }

  // 检查是否需要更新缓存（版本不一致则需要）
  static Future<bool> needUpdateCache() async {
    final localVersion = await getLocalVersion();
    final serverVersion = await getServerVersion();

    // 首次加载（无本地版本）或版本不一致时，需要更新
    return localVersion == null || serverVersion != null && serverVersion != localVersion;
  }

  // 清理WebView缓存（配合WebViewController使用）
  static Future<void> clearWebCache(WebViewController controller) async {
    await controller.clearCache(); // 清除磁盘缓存
    await controller.clearLocalStorage(); // 清除本地存储（如localStorage）
    await controller.clearSessionStorage(); // 清除会话存储
    print('旧缓存已清理');
  }
}
```


#### **3. WebView页面实现（核心逻辑）**
根据版本对比结果，决定是否清理缓存，再加载H5页面。

```dart
import 'package:flutter/material.dart';
import 'package:webview_flutter/webview_flutter.dart';
import 'package:dio/dio.dart';

class H5WebViewPage extends StatefulWidget {
  // H5首页URL（确保静态资源已版本化）
  final String h5HomeUrl; // 例：https://your-h5-domain.com/index.html
  const H5WebViewPage({super.key, required this.h5HomeUrl});

  @override
  State<H5WebViewPage> createState() => _H5WebViewPageState();
}

class _H5WebViewPageState extends State<H5WebViewPage> {
  late final WebViewController _controller;
  bool _isLoading = true;
  String? _errorMsg;

  @override
  void initState() {
    super.initState();
    _initWebView();
  }

  // 初始化WebView（先检查版本，再决定是否清理缓存）
  Future<void> _initWebView() async {
    try {
      // 1. 检查是否需要更新缓存
      final needUpdate = await H5CacheManager.needUpdateCache();

      // 2. 初始化WebViewController
      _controller = WebViewController()
        ..setJavaScriptMode(JavaScriptMode.unrestricted)
        ..setCacheMode(CacheMode.loadCacheElseNetwork) // 优先使用缓存，无缓存则请求网络
        ..setNavigationDelegate(NavigationDelegate(
          onPageStarted: (url) => setState(() => _isLoading = true),
          onPageFinished: (url) => setState(() => _isLoading = false),
          onWebResourceError: (error) {
            setState(() {
              _isLoading = false;
              _errorMsg = '加载失败：${error.description}';
            });
          },
        ));

      // 3. 若需要更新，清理旧缓存并更新本地版本
      if (needUpdate) {
        await H5CacheManager.clearWebCache(_controller);
        final serverVersion = await H5CacheManager.getServerVersion();
        if (serverVersion != null) {
          await H5CacheManager.saveLocalVersion(serverVersion);
        }
      }

      // 4. 加载H5页面
      await _controller.loadRequest(Uri.parse(widget.h5HomeUrl));

      setState(() {}); // 刷新UI
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMsg = '初始化失败：$e';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('H5页面')),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_errorMsg != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(_errorMsg!),
            ElevatedButton(
              onPressed: () => _initWebView(), // 重试
              child: const Text('重新加载'),
            ),
          ],
        ),
      );
    }

    if (!_isLoading && _controller == null) {
      return const Center(child: Text('初始化中...'));
    }

    return Stack(
      children: [
        WebViewWidget(controller: _controller),
        if (_isLoading)
          const Positioned(
            top: 0,
            left: 0,
            right: 0,
            child: LinearProgressIndicator(),
          ),
      ],
    );
  }
}
```


#### **4. H5端配合（关键）**
为确保静态资源更新时能被正确缓存和替换，H5端需要：
- **静态资源版本化**：JS/CSS/图片等文件名添加哈希或版本号（例：`main.8f2b7.js` 而非 `main.js`），确保内容更新时文件名变化。
- **服务器缓存策略**：
    - 对版本化的静态资源设置长期缓存（`Cache-Control: max-age=31536000`，1年），避免重复请求。
    - 对HTML文件设置不缓存或短缓存（`Cache-Control: no-cache`），确保每次加载最新HTML（从而引用最新的静态资源）。


### **关键说明**
1. **版本校验时机**：建议在App启动时或首次加载H5前执行版本校验，避免每次打开H5都校验（减少网络请求）。
2. **缓存清理范围**：`clearCache()` 会清除WebView的磁盘缓存，`clearLocalStorage()` 清除H5的`localStorage`（若H5用其存储非静态资源数据，需谨慎清理，可根据需求调整）。
3. **极端情况处理**：若服务器版本文件请求失败（如网络差），默认使用本地缓存（避免H5无法打开），下次网络恢复时再校验。
4. **调试建议**：开发阶段可强制清理缓存（如添加“清除缓存”按钮），方便测试更新效果。


通过以上方案，既能利用缓存提升H5加载速度，又能通过版本控制确保静态资源及时更新，兼顾用户体验和更新时效性。