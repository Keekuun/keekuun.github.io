---
title: 【面试】前端高级面试
date: 2020-09-03
sidebar: 'auto'
categories: 
- 前端
tags: 
- JS
- 面试
publish: true
---

# 前端高级面试

> [最新前端面试题攻略](https://juejin.im/post/6844903791246966791#heading-11)

## 1.CSS相关

### 1.`css3`特性中的`transform：translateZ(0)`有什么作用?

**GPU**加速，优化前端性能

```css 
.example {
  /*开启硬件加速*/
  transform: translateZ(0);
  /*优化：告诉浏览器，哪些属性需要硬件加速，提前开启硬件加速*/
  will-change: transform, opacity;
  /*人为干扰复合层的排序,可以有效减少chrome创建不必要的复合层，提升渲染性能*/
  z-index: 1
}
```



> [在 CSS 动画中使用硬件加速(翻译)](https://juejin.im/post/6844903649974435854)
>
> [CSS3 transform介绍](https://www.jianshu.com/p/17e289fcf467)
>
> [CSS3硬件加速也有坑](https://juejin.im/entry/6844903597772111886#comment)
>
> [CSS3开启硬件加速的使用和坑](https://www.jianshu.com/p/9596c82086d5)
>
> [CSS will-change 属性](https://www.cnblogs.com/yuzhongwusan/p/4186405.html)
>
> [iScroll, smooth scrolling for the web](https://github.com/Keekuun/iscroll)

## 2.浏览器相关

### 1.列举三种禁止浏览器缓存的头字段，并写出响应的设置值？

```js
/**
* 禁用浏览器缓存通过Cache-Control、pragma、expires 
*/
response.setHeader("Cache-Control","no-cache");
response.setHeader("pragma", "no-cache");
response.setDateHeader("expires", -1);
```

在现代的浏览器里，为了增强用户体验，浏览器一般都会把网页上所需的静态文件缓存到本地，再次刷新的时候则无需再重新加载，但是我们有时候就是不需要浏览器缓存这些文件，而是每次都从服务器端读取数据，可以用以下做法：

在html文件头部加上：

```html
<meta HTTP-EQUIV="pragma" CONTENT="no-cache">
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate">
<meta HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT">
<meta HTTP-EQUIV="expires" CONTENT="0">
```

然而这些还是不够的，有些浏览器还是缓存了文件，那么就必须给每个文件加个后缀时间戳，告诉浏览器这个是新文件，必须重新加载，浏览器就会从新到服务器端读取数据文件显示出来。

例如：

```html
<link href="reset.css?v=20150127" rel="stylesheet">
```

那么，浏览器缓存有哪些呢？

+ 强缓存
+ 协商缓存

#### 1.强缓存

+ HTTP1.0：`Expires`即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。(坑：**服务器的时间和浏览器的时间可能并不一致**，那服务器返回的这个过期时间可能就是不准确的)

  ```makefile
  Expires: Wed, 22 Nov 2019 08:41:00 GMT
  ```

+ HTTP1.1：`Cache-Control`,采用过期时长来控制缓存，对应的字段是**max-age**

  ```makefile
  # 代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。
  Cache-Control: max-age=3600
  ```

  `Cache-Control`属性值：

  + `max-age`：过期时长s

  + `private`： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
  + `no-cache`: 跳过当前的**强缓存**，发送HTTP请求，即直接进入`协商缓存阶段`。
  + `no-store`：非常粗暴，不进行任何形式的缓存。
  + `s-maxage`：这和`max-age`长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。
  + `must-revalidate`: 是缓存就会有过期的时候，加上这个字段一旦缓存过期，就必须回到源服务器验证。

  值得注意的是，当**Expires**和**Cache-Control**同时存在的时候，**Cache-Control**会优先考虑。

  当然，还存在一种情况，当资源缓存时间超时了，也就是`强缓存`失效了，接下来怎么办？没错，这样就进入到第二级屏障——**协商缓存**了。

#### 2.协商缓存

强缓存失效之后，浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是**协商缓存**。

+ `Last-Modified`: 最后修改时间(单位s)（性能优于ETag）

在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中`该资源的最后修改时间`对比:

1. 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。

2. 否则返回304，告诉浏览器直接用缓存。

`ETag`: 文件生成的唯一标识。（精准度优于Last-Modified）

服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过`响应头`把这个值给浏览器。

浏览器接收到`ETag`的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。

服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对:

- 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
- 否则返回304，告诉浏览器直接用缓存。

#### 3.缓存位置

- Service Worker 

Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问`DOM`。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如`离线缓存`、`消息推送`和`网络代理`等功能。其中的`离线缓存`就是 **Service Worker Cache**。

Service Worker 同时也是 PWA 的重要实现机制

- Memory Cache 内存缓存，效率最快
- Disk Cache 磁盘缓存
- Push Cache 推送缓存（HTTP/2）

#### 4.总结

首先通过 `Cache-Control` 验证强缓存是否可用

- 如果强缓存可用，直接使用，不用发起HTTP请求

- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的

  ```
  If-Modified-Since
  ```

  或者

  ```
  If-None-Match
  ```

  这些条件请求字段检查资源是否更新

  - 若资源更新，返回资源和200状态码
  - 否则，返回304，告诉浏览器直接从缓存获取资源

> [能不能说一说前端缓存?](http://47.98.159.95/my_blog/perform/001.html)
>
> [关于浏览器缓存的控制cache-control,expires,last-modified,etag,及编程示例](https://blog.csdn.net/iteye_11287/article/details/82618718?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)

### 3.从输入url到页面展示发生了什么？

> [(超详细）从输入url到页面展示发生了什么？](https://juejin.im/post/6869279683230629896)
>
> [经典面试题！从输入URL到页面展示你还不赶紧学起来？](https://juejin.im/post/6858551640220729351)

1.进程：浏览器进程（主进程） --- 网络进程 --- 渲染进程 --- GPU进程----穿插其他进程（插件进程等）

2.具体过程：

- 1.用户在浏览器导航栏输入信息： 非url 是query--- 默认搜索引擎去搜索；url --- 浏览器进程间通信，交给网络进程处理

- 2.网络进程会先看有没有缓存，否则进行 DNS解析获取IP地址建立TCP连接

- 3.DNS解析：网络进程拿到URL后会请求DNS域名服务器，解析获取ip地址。

- 4.建立TCP连接，三次握手，如果是https协议，还会建立SSL/TLS连接

- 5.发送HTTP请求，四次挥手

- 6.服务器响应：服务器收到请求信息后，会根据请求信息生成**响应行**、**响应头**、**响应体**，并发给网络进程。网络进程接受了响应信息之后，就开始解析响应头的内容。

- 7.**网络进程解析响应行和响应头信息的过程**：

  - 重定向：如果响应行状态码为301（永久重定向）和302（临时），那么说明需要重定向到其他url。这时候网络进程会从响应头中的Location字段里读取重定向的地址，并重新发起网络请求。
  - 响应数据处理：通过请求头的**Content-type**字段判断**响应体**数据的类型，从而决定怎么处理响应的数据。如果是文本或html用渲染进程渲染，否则如果是文件通知下载管理器；

- 8.准备渲染进程：默认情况，每个页面一个渲染进程。但若处于**同一站点**（同根域名+协议），那么**渲染进程就会复用**。

- 9.提交文档：渲染进程准备好后，浏览器进程发出**“提交文档的消息”**。等数据传输完成了，渲染进程会告诉浏览器进程，**确认文档提交**，这时候浏览器会更新页面，安全状态，url，前进后退的历史。

  到这里导航结束，进入渲染阶段。

  >  注：当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为百度首页的页面。因为需要等待提交文档阶段，页面内容才会被替换。

+ ### 10.浏览器的渲染过程

  + 1.浏览器无法直接读取html，需要先构建**Dom**树。

  + 2.把读取到的css，变成浏览器可以理解的**cssom**树。

    **转换样式表中的属性值，使其标准化**。2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……

    **计算出 DOM 树中每个节点的具体样式**。利用css继承、css优先级、css层叠规则等计算出来。

  + 3.浏览器会先从DOM树的根节点开始遍历每个可见节点，并把这些节点添加到**渲染**树中。不可见的节点不会添加到渲染树，比如css设置了display为none 属性的节点。

  + 4.根据生成的渲染树，进行**布局**（也可以叫做回流），得到各个节点在页面中的确切位置和大小。（自动重排）。布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对的测量值也都会被转换为屏幕内的绝对像素值（重绘）。

  + 5.生成分层树，页面都是一层一层叠加在一起形成的。比如一些复杂的css动画，z-index等，渲染引擎会为他们生成专用的图层，并生成对应的**图层树**。

  + 6.构建完图层之后，渲染引擎会对图层树中的每个元素进行**绘制**。合成线程会把分层树的图层变成**图块**。

  + 7.GPU的栅格化把视窗附近的图块变成位图，然后保存在GPU的进程中。（因为一个页面可能很大，而用户只能看到视口中页面的一部分，如果全部绘制开销会很大，所以合成线程会按照视口附近的图块来优先生成位图）

    栅格化完成之后，浏览器进去GPU进程里取出页面内容显示在屏幕上，这就完成了渲染阶段

  + 当 渲染器进程 渲染结束（渲染结束意味着该页面内的所有的页面，包括所有 iframe 都触发了 onload 时），会发送 IPC 信号到 浏览器进程， UI线程会停止展示 tab 中的 spinner。

    > **总结**:生成各种树，包括dom tree, css tree, layout tree, layer true, render tree，这些是`渲染器进程`中的`GUI渲染线程`做的事。其中js脚本的解析执行是同进程下的js引擎线程来做的，也就是大名鼎鼎的`V8引擎`。至于定时器回调，是`定时器线程`来计数，计数完毕会把回调推入事件触发线程维护的`任务队列`，当js线程空闲并且此线程维护的微任务队列无事件，才会去任务队列拿`宏任务`执行处理。)

## 3.DOM相关

### 1. 精确获取页面元素位置的方式有哪些？

+ `dom.getBoundingClientRect`: 返回 一个`TextRectangle`对象，即使DOM里没有文本也能返回`TextRectangle`对象。

+ `dom.getClientRects` : 返回一个`TextRectangle`集合，就是`TextRectangleList`对象。

`TextRectangle`包含元素相对于视图窗口的左上角的位置（top, right, bottom,left, x, y）以及元素本身的属性（width, height）。

```js
const dom = documnet.getElementById('#box');
// 元素的相对位置
let X = dom.getBoundingClientRect().left;
let Y = dom.getBoundingClientRect().top;
// 获取滚动条位置
let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
let scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
// 再加上滚动距离，就可以得到绝对位置
let X = dom.getBoundingClientRect().left + scrollLeft;
let Y = dom.getBoundingClientRect().top + scrollTop;
```

> [getClientRects() 和 getBoundingClientRect() 的用法和区别](https://www.webhek.com/post/getclientrects-getboundingclientrect.html)
>
> [用Javascript获取页面元素的位置](http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html)

## 4.JS相关

### 1.正则从`2018-10-07T11:48:47 Asia/zh-cn` 提取出来结果`[2018,10,07,11,48,47]`

```js
const date = new Date().toString();
// 返回匹配的数组
const ans = date.match(/\d+/g); 
// 惰性：返回RegExpStringIterator
const ans = date.matchAll(/\d+/); 
```

### 2.如何判断object是数组类型？

```js
alert(typeof 1);                // 返回字符串"number" 
alert(typeof "1");              // 返回字符串"string" 
alert(typeof true);             // 返回字符串"boolean" 
alert(typeof {});               // 返回字符串"object" 
alert(typeof []);               // 返回字符串"object " 
alert(typeof function(){});     // 返回字符串"function" 
alert(typeof null);             // 返回字符串"object" 
alert(typeof undefined);        // 返回字符串"undefined"
alert(typeof Symbol());        // 返回字符串""symbol""
```

+ 从原型入手，`Array.prototype.isPrototypeOf(obj)`;利用`isPrototypeOf()`方法，判定Array是不是在obj的原型链中，如果是，则返回true,否则false。
+ 从原型入手，`Object.prototype.toString.call(obj) === '[object Array]'`

+ `Array.isArray()`方法

### 3.手动实现compose和pipe函数

```js
// 使用reduce实现
const compose = (...args) => value => args.reduceRight((acc, fn) => fn(acc), value);
const pipe = (...args) => value => args.reduce((acc, fn) => fn(acc), value);
```

```js
// 原生实现compose从右往左执行
function compose() {
    var fns = [].slice.call(arguments);
    return function(value) {
        var res = value;
        for(var i=fns.length - 1; i>=0;i--) {
            res = fns[i](res);
        }
        return res;
    }
}
//pipe从左往右执行
function pipe() {
    var fns = [].slice.call(arguments);
    return function(value) {
        var res = value;
        for(var i=0; i<fns.length;i++) {
            res = fns[i](res);
        }
        return res;
    }
}
```

> [实现compose的五种思路](https://segmentfault.com/a/1190000011447164)

### 4. 实现add(1)(2)(3)(4) 输出 10(**函数柯里化**)

> [toString && valueOf && Symbol.toPrimitive 辨析](https://juejin.im/post/6844903813749407752)
>
> [聊一聊valueOf和toString](https://juejin.im/post/6844903967097356302)
>
> [由Object.prototype.toString.call( )引发关于toString( )方法的思考](https://juejin.im/post/6844903604990509063)
>
> [How can I make var a = add(2)(3); //5 work?](https://stackoverflow.com/questions/2272902/how-can-i-make-var-a-add23-5-work)
>
> [toString()的几种用法](https://juejin.im/post/6844903897618710541)

```js
// add(1)(2) = 3
const add = (a, b) => a + b;
const add2 = a => b => a + b;

// 多個
function add(x) {
    return function(y) {
        if (typeof y !== 'undefined') {
            x = x + y;
            return arguments.callee;
        } else {
            return x;
        }
    };
}

// add(1)(2)(3)(4)()

function add(n){
  var addNext = function(x) {
    return add(n + x);
  };

  addNext.valueOf = function() {
    return n;
  };

  return addNext;
}

// more
function add(a, b){
 return a && b ? a+b : function(c){return a+c;}
}

console.log(add(2, 3));
console.log(add(2)(3));

```

```js
add(1) // 1
add(1)(2) //3
add(1)(2)(3) // 6
add(1,2)(3) // 6
add(1,2,3) // 6

function add(...args) {
    let _add = function(..._args) {
        return add.apply(null, [...args, ..._args]);
    }
    _add.toString = function() {
        return args.reduce((a, b) => a+b)
    }
    return _add;
}
```



> [前端经典面试题解密-add(1)(2)(3)(4) == 10到底是个啥？](https://blog.csdn.net/qfluohao/article/details/105602707)

### 5.求1234567890.32格式化为：1,234,567,890.32。

> [把一串数字表示成千位分隔形式——JS正则表达式的应用](https://juejin.im/post/6844903584031571975)

```js
let n = 1234567890.32;
// 最简洁
n.toLocaleString()

// 正则
// 在\d前面加一个非单词边界\B，用来表示所匹配的这个空后面不能是一个单词边界
let reg = /(?=(\B\d{3})+$)/g;
let str = '' + n;
str.replace(reg, ",")
```

### 6.、如何理解JavaScript原型链

- JavaScript中的每个对象都有一个__proto__属性（函数对象即有__proto__，又有prototype，prototype指向自己的原型而__proto__指向父级的原型）我们称之为原型，而原型的值也是一个对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是Object.prototype.__proto_,它的值比较特殊，值为null。
- 原型链的作用是用于对象继承，函数A的原型属性(prototype property)是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。
-  当访问对象的一个属性时, 首先查找对象本身, 找到则返回; 若未找到, 则继续查找其原型对象的属性(如果还找不到实际上还会沿着原型链向上查找, 直至到根). 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined；

## 5.编程相关

### 1.已知数据结构`users`，请实现语法支持`user.unique`能够按照`name`字段去重，并输出结构为：`[“a”,“b”，“c"]`

```js
var users=[{
   id:1,name:"a"
},{
   id:2,name:"a"
},{
   id:3,name:"b"
},{
   id:4,name:"c"
}]
```

```js
// 要支持user.unique语法，需要在数组原型上做文章
Array.prototype.unique = function(key = '') {
    if(!key) return [...new Set(this)];
   return [...new Set(this.map(d => d[key]))];
}

```

```js
 // 使用`reduce`:
Array.prototype.unique = function(key = '') {
   if(!key) return [...new Set(this)];
   return this.reduce((accumulator, currentValue) => {
       if(!accumulator.includes(currentValue[key])) {
            accumulator.push(currentValue[key]);
       }
       return accumulator;
   }, []);
}

users.unique(key)
```

### 2.已知如下对象，请基于`es6`的`proxy`方法设计一个属性拦截读取操作的例子，要求实现去访问目标对象`example`中不存在的属性时，抛出错误：`Property “$(property)” does not exist`

```js
const man={
    name:'jscoder',
    age:22
}
 //补全代码
const proxy = new Proxy(...)
proxy.name //"jscoder"
proxy.age //22
proxy.location //Property "$(property)" does not exist
```

```js
const proxy = new Proxy(obj, {
    // getter拦截
    get: function(target, property) {
        if(property in target) {
            return target[property];
        } else {
            throw new Error(`Property $(property) does not exist.`);
        }
    },
    // setter拦截
    set: function(target, property, value) {
        target[property] = value;
    },
    has:function() {
        console.log('in操作符的拦截')
    },
    deleteProperty: function(){
        console.log('delete操作符的拦截')
    },
})
```

+ 考点`es6`的`Proxy` 实例的方法

```js
const p = new Proxy(target, handler)
```

`Proxy.revocable()` 方法可以用来创建一个可撤销的代理对象。`Proxy.revocable(target, handler);`

> [Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

### 3.给出如下虚拟dom的数据结构，如何实现简单的虚拟dom，渲染到目标dom树

```js
//样例数据
let demoNode = ({
    tagName: 'ul',
    props: {'class': 'list'},
    children: [
        ({tagName: 'li', children: ['douyin']}),
        ({tagName: 'li', children: ['toutiao']})
    ]
});
```

构建一个render函数，将demoNode对象渲染为以下dom:

```html
<ul class="list">
    <li>douyin</li>
    <li>toutiao</li>
</ul>
```

通过JavaScript，我们可以很容易构建它，如下：

```js
var elem = Element({
    tagName: 'ul',
    props: {'class': 'list'},
    children: [
        Element({tagName: 'li', children: ['item1']}),
        Element({tagName: 'li', children: ['item2']})
    ]
});
```

下面实现Element类：

Element为一个构造函数，返回一个Element对象。为了更清晰的呈现虚拟DOM结构，我们省略了new，而在Element中实现

```js
function Element({tagName, props, children}) {
    if (!(this instanceof Element)) {
        return new Element({tagName, props, children});
    }
	this.tagName = tagName;
	this.props = props;
	this.children = children;
}
```

现在可以通过Element我们可以任意地构建虚拟DOM树，那么怎么转为真正的DOM呢？

可以通过DOM操作，`createElement`创建元素节点，`createTextNode`创建文本节点：

```js
// 使用DFS
Element.prototype.render = function() {
    // 创建父节点
    let el = document.createElement(this.tagName);
    for(let propName in this.props) {
        el.setAttribute(propName, this.props[propName]);
    }
    // 遍历子节点 -》 子节点-》...
    this.children.forEach(function(child) {
        let childEl = null;
        // 是Element类
        if(child instanceof Element) {
            childEl = child.render();
        // 不是Element类，但是{tagName, props, children}
        } else if (child.tagName) {
           childEl = Element(child).render();        
        } else {
           childEl = document.createTextNode(JSON.stringfy(child));
        }
        el.appendChild(childEl);
    });
    return el;
}
```

### 4. 手写深拷贝

```js
function deepClone(value) {
    if(value === null) return value;
    if(typeof value !== 'object') return value;
    if(value instanceof RegExp) return new RegExp(value);
    if(value instanceof Date) return new Date(value);
    // [] 或者{}
    let obj = new value.constructor();
    // 使用for ... in遍历自身属性
    for(let key in value) {
        // 只拷贝对象自身的属性
        if(value.hasOwnProperty(key)) {
            // 递归调用
             obj[key] = deepClone(value[key]);
        }
    }
    return obj;
}
```

### 5.手写数组扁平化

> [数组多维转一维度（扁平化）的6种方法](https://juejin.im/post/6850037272964759566)

```js
function flatten(arr, depth=1) {
   if(depth > 0) {
       return arr.reduce((acc, cur) => {
           return acc.concat(Array.isArray(cur) ? flatten(cur, depth-1) : cur)
       }, [])
   } else {
       return arr;
   }
}
```

### 6.手写new操作符

首先，理解new操作符干了什么？

1. 创建了一个新对象
2. 将this指向新对象
3. 将创建的对象的原型指向构造函数的原型
4. 返回一个对象。如果构造函数本身有返回值并且返回的也是对象，那么就返回这个返回值，否则否会创建的对象。

```js
function _new(fn, ...args) {
    // 创建一个空对象，并将对象的__proto__指向fn的ptototype
    let obj = Object.create(fn.prototype);
    // 将fn的this指向obj，并获取返回值
    let ret = fn.apply(obj, args);
    // 如果fn返回一个新对象，就返回这个对象，否则返回刚创建的对象
    return Object.prototype.toString.call(ret) === '[Object Object]' ? ret : obj;
}
```



### 7.手写对象继承

### 8. 手写防抖

+ 简单实现

```js
function debounce(fn, wait) {
    let timer = null;
    return function(..args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, wait);
    };
};
```

+ 控制立即执行

```js
function debounce(fn, wait=200, immediate=true) {
    let timer = null;
    return function(...args) {
        if(immediat) {
            fn.apply(this, args)
        }
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args)
        }, wait)
    }
}
```

### 9.手写节流

+ 简单实现

```js
// 定时器版
function throttle() {
    let timer = null;
    return function(...args) {
        if(timer) return;
        timer = setTimeout(() => {
            fn.call(this, ...args);
            timer = null;
        }, wait);
    };
};

// 时间戳版
const throttle = (func, wait) => {
  let last = 0;
  return (...args) => {
    const current_time = +new Date();
    if (current_time - last_time > wait) {
      func.apply(this, args);
      last_time = +new Date();
    }
  };
};
```

+ 节流或防抖切换

```js
function throttleOrDebounce(fn, wait, isDebounce=true) {
    let timer = null;
    let prev = 0;
    return function(..args) {
        if(isDebounce) {
           if(timer) clearTimeout(timer);
           timer = setTimeout(() => {
               fn.apply(this, ...args);
           }, wait)
        } else {
            const now = +new Date();
            if(now - prev < wait) return;
            prev = now;
            fn.apply(this, args);
        }
    }
}
```

### 10. 手写call

+ 简易版（不考虑context非对象情况，不考虑Symbol\BigInt 不能 new.constructor( context )情况）

```js
Function.prototype._call = function(context, ...args) {
    // null,undefined,空 --- context为window
    context = context == null ? window : context;
    
    // 将要被替换的fn放入context中
    context['fn'] = this;
    // 此时执行fn,其this自然指向了context
    const ret = context['fn'](...args);
    // 用完卸载
    delete context['fn'];
    // 返回执行结果
    return ret;
}
```

+ 完善版（context必须对象类型，兼容Symbol等情况）

```js
Function.prototype._call = function(context, ...args) {
    // null,undefined,空 --- context为window
    context = context == null ? window : context;
    
    // 必须保证 context 是一个对象类型
  	let contextType = typeof context;
    if (!/^(object|function)$/i.test(contextType)) {
   	 	// context = new context.constructor(context); // 不适用于 Symbol/BigInt
    	context = Object(context);
    }

    // 将要被替换的fn放入context中
    context['fn'] = this;
    // 此时执行fn,其this自然指向了context
    const ret = context['fn'](...args);
    // 用完卸载
    delete context['fn'];
    // 返回执行结果
    return ret;
}
```

### 11. 手写apply

原理： 利用函数通过`obj.func()`执行的方式，将函数的this指向这个对象。

```js
Function.prototype._apply = function(context, ...args) {
     context = context == null ? window : context;
    let contextType = typeof context;
  	if (!/^(object|function)$/i.test(contextType)) {
        // Object会将context包装成对应的包装对象
    	context = Object(context);
    }
    
    context['fn'] = this;
    // 此处参数是与call的区别
    let ret = context['fn'](args);
    delete context['fn'];
    
    return ret;
}
```

### 12. 手写bind

```js
Function.prototype._bind = function(context, ...args) {
    // 缓存要处理函数的this
    let this = that;
    return function(...args) {
        that.call(context, ...args);
        // 或者
        // that.apply(context, args);
        // 或者在这里手动实现call/apply
    }
}
```



## 6.算法相关
